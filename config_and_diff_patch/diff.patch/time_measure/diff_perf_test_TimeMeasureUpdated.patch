diff --git a/quaggasrx/bgpd/bgp_attr.c b/quaggasrx/bgpd/bgp_attr.c
index b31c9ed..5d5df5e 100644
--- a/quaggasrx/bgpd/bgp_attr.c
+++ b/quaggasrx/bgpd/bgp_attr.c
@@ -1692,6 +1698,48 @@ bgp_mp_unreach_parse (struct bgp_attr_parser_args *args,
   return BGP_ATTR_PARSE_PROCEED;
 }
 
+#ifdef USE_SRX
+#define TIME_MEASURE_TEST_ENABLED
+#ifdef TIME_MEASURE_TEST_ENABLED
+struct ecommunity_val srx_gettime(as_t local_as)
+{
+
+  /* time measure here and put the data into 8 byte long ecommunity payload
+   * (cf.) tv_sec, tv_usec: __SLONGWORD_TYPE ( == long int type )
+   */
+  unsigned long int val;
+  unsigned short sec;
+  struct timeval community_now;         /* current time */
+  struct ecommunity_val eval;
+  //
+  quagga_gettime(1 /*QUAGGA_CLK_MONOTONIC*/, &community_now);
+  /*
+  printf("+++ [%s] TIME -- sec: %lu(0x%08x) msec: %lu(0x%08x)\n",
+      __FUNCTION__,
+      community_now.tv_sec, community_now.tv_sec,
+      community_now.tv_usec/1000, community_now.tv_usec/1000);
+      */
+
+  sec = (community_now.tv_sec) & 0xFFFF; // sec : 2 byte-long
+  val = community_now.tv_usec / 1000; // mili-sec: 4 byte-long
+
+  /*
+  printf("sec = 0x%02x val = 0x%08X\n", sec, val);
+  printf("local as: %02x\n", local_as);
+  */
+
+
+  /* fill the ecommunity value here */
+  memset(&eval, 0x00, sizeof(struct ecommunity_val));
+  memcpy(&eval, &local_as, 2);
+  memcpy(&eval.val[2], &sec, 2);
+  memcpy(&eval.val[4], &val, 4);
+
+  return eval;
+}
+#endif
+#endif
+
 /* Extended Community attribute. */
 static bgp_attr_parse_ret_t
 bgp_attr_ext_communities (struct bgp_attr_parser_args *args)
@@ -1710,6 +1758,39 @@ bgp_attr_ext_communities (struct bgp_attr_parser_args *args)
 
   (bgp_attr_extra_get (attr))->ecommunity =
     ecommunity_parse ((u_int8_t *)stream_pnt (peer->ibuf), length);
+
+#ifdef USE_SRX
+#ifdef TIME_MEASURE_TEST_ENABLED
+  /* Prepare one structure for adding a new value into the a new
+   * Extended Communities  */
+  struct ecommunity_val eval;
+  struct ecommunity *old_ecom, *new_ecom;
+
+  old_ecom = (bgp_attr_extra_get (attr))->ecommunity;
+
+  if (old_ecom)
+  {
+    new_ecom = ecommunity_dup (old_ecom);
+  }
+
+  // fill eval with time measured
+  eval = srx_gettime(peer->local_as);
+
+  if ( call_ecommunity_add_val (new_ecom, &eval))
+  {
+    ecommunity_unintern (&old_ecom);
+    attr->extra->ecommunity = ecommunity_intern (new_ecom);
+  }
+  else
+  {
+    if(new_ecom)
+      ecommunity_free (&new_ecom);
+  }
+
+#endif
+#endif
+
+
   /* XXX: fix ecommunity_parse to use stream API */
   stream_forward_getp (peer->ibuf, length);
 
@@ -2707,6 +2799,12 @@ bgp_packet_attribute (struct bgp *bgp, struct peer *peer,
       stream_putc_at (s, sizep, (stream_get_endp (s) - sizep) - 1);
     }
 
+
+#ifdef USE_SRX
+#ifdef TIME_MEASURE_TEST_ENABLED
+  unsigned long pos_eval;
+#endif
+#endif
   /* Extended Communities attribute. */
   if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY)
       && (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES)))
@@ -2715,6 +2813,29 @@ bgp_packet_attribute (struct bgp *bgp, struct peer *peer,
 
       assert (attre);
 
+#ifdef USE_SRX
+#ifdef TIME_MEASURE_TEST_ENABLED
+      /* change ecommunity value for time-measure purpose.
+       * And later return the origianl pointer
+       */
+      struct ecommunity *ecom_orig=NULL;
+      struct ecommunity *old_ecom, *new_ecom;
+      struct ecommunity_val eval;
+
+      old_ecom = attre->ecommunity;
+      new_ecom = ecommunity_dup (old_ecom);
+
+      /* the reasone commented out: need to use dummy first */
+      memcpy(eval.val, &peer->local_as, 2);
+      memset(&eval.val[2], 0xff, 6); // in order to advance than other ecomm values
+      //eval = srx_gettime(peer->local_as);
+
+      if( call_ecommunity_add_val (new_ecom, &eval))
+      {
+        attre->ecommunity = new_ecom;
+      }
+#endif
+#endif
       if (peer->sort == BGP_PEER_IBGP
           || peer->sort == BGP_PEER_CONFED)
 	{
@@ -2787,10 +2908,29 @@ bgp_packet_attribute (struct bgp *bgp, struct peer *peer,
                   if (CHECK_FLAG (tbit, ECOMMUNITY_FLAG_NON_TRANSITIVE))
                     continue;
 #endif
+
+#ifdef USE_SRX
+#ifdef TIME_MEASURE_TEST_ENABLED
+                  pos_eval = stream_get_endp (s);
+#endif
+#endif
 		  stream_put (s, pnt, 8);
 		}
 	    }
 	}
+
+#ifdef USE_SRX
+#ifdef TIME_MEASURE_TEST_ENABLED
+      // return back the origianl value to attr
+      if(attre->ecommunity != old_ecom)
+        attre->ecommunity = old_ecom;
+
+      // release the previous temp instance
+      if(new_ecom)
+        ecommunity_free (&new_ecom);
+#endif
+#endif
+
     }
 
   if ( send_as4_path )
@@ -2916,22 +3058,58 @@ bgp_packet_attribute (struct bgp *bgp, struct peer *peer,
     }
     else
     {
+#if 0
       if (BGP_DEBUG (bgpsec, BGPSEC_DETAIL))
-      {
         zlog_debug("[BGPSEC] total length: %d ", bgpsec_ret);
-      }
+#endif
       stream_putw_at(s, bgpsec_sizep, bgpsec_ret); /* attr_length */
     }
   }
 
   /* release aspath pointer used for bgpsec */
   if (aspath_bgpsec)
-  {
     aspath_free (aspath_bgpsec);
-  }
 
 #endif /* USE_SRX */
 
+#ifdef USE_SRX
+#ifdef TIME_MEASURE_TEST_ENABLED
+  if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY)
+      && (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES)))
+  {
+    struct ecommunity_val eval;
+    volatile uint64_t tmpq =0;
+    int i=0;
+    eval = srx_gettime(peer->local_as);
+
+#if 0
+    printf("------ eval: 0x");
+    for(i=0; i< ECOMMUNITY_SIZE; i++)
+      printf("%02x ", eval.val[i] & 0xFF);
+    printf("\n");
+#endif
+
+    tmpq |= (uint64_t) (eval.val[0] & 0xFF) << 56;
+    tmpq |= (uint64_t) (eval.val[1] & 0xFF) << 48;
+    tmpq |= (uint64_t) (eval.val[2] & 0xFF) << 40;
+    tmpq |= (uint64_t) (eval.val[3] & 0xFF) << 32;
+    tmpq |= (uint64_t) (eval.val[4] & 0xFF) << 24;
+    tmpq |= (uint64_t) (eval.val[5] & 0xFF) << 16;
+    tmpq |= (uint64_t) (eval.val[6] & 0xFF) << 8;
+    tmpq |= (uint64_t) (eval.val[7] & 0xFF);
+
+    stream_putq_at (s, pos_eval, tmpq); // replace
+
+    //printf(" ------ pos(s): %d tmpq: %16x \n", pos_eval, (uint64_t) tmpq);
+#if 0
+    printf(" ------ s->data : 0x");
+    for(i=0; i< ECOMMUNITY_SIZE; i++)
+      printf("%02x ", s->data[pos_eval + i]);
+    printf("\n");
+#endif
+  }
+#endif
+#endif
   /* Unknown transit attribute. */
   if (attr->extra && attr->extra->transit)
     stream_put (s, attr->extra->transit->val, attr->extra->transit->length);
diff --git a/quaggasrx/bgpd/bgp_ecommunity.c b/quaggasrx/bgpd/bgp_ecommunity.c
index 49fc6d5..85bdebd 100644
--- a/quaggasrx/bgpd/bgp_ecommunity.c
+++ b/quaggasrx/bgpd/bgp_ecommunity.c
@@ -594,6 +594,12 @@ ecommunity_bgpsec_str2com(int type, unsigned int state_value)
 
   return ecom;
 }
+
+/* wrapper function to call ecommunity_add_val from outside */
+int call_ecommunity_add_val (struct ecommunity *ecom, struct ecommunity_val *eval)
+{
+  return ecommunity_add_val (ecom, eval);
+}
 #endif
 
 /* Convert extended community attribute to string.
diff --git a/quaggasrx/bgpd/bgp_ecommunity.h b/quaggasrx/bgpd/bgp_ecommunity.h
index 9b6c6e2..06e10c4 100644
--- a/quaggasrx/bgpd/bgp_ecommunity.h
+++ b/quaggasrx/bgpd/bgp_ecommunity.h
@@ -94,6 +94,7 @@ extern unsigned int ecommunity_hash_make (void *);
 extern struct ecommunity *ecommunity_str2com (const char *, int, int);
 #ifdef USE_SRX
 extern struct ecommunity *ecommunity_bgpsec_str2com(int, unsigned int);
+int call_ecommunity_add_val (struct ecommunity *, struct ecommunity_val *);
 #endif
 extern char *ecommunity_ecom2str (struct ecommunity *, int);
 extern int ecommunity_match (const struct ecommunity *, const struct ecommunity *);
diff --git a/quaggasrx/bgpd/bgp_main.c b/quaggasrx/bgpd/bgp_main.c
index cd8053c..7a5e1b2 100644
--- a/quaggasrx/bgpd/bgp_main.c
+++ b/quaggasrx/bgpd/bgp_main.c
@@ -117,6 +117,10 @@ static const char *pid_file = PATH_BGPD_PID;
 int vty_port = BGP_VTY_PORT;
 char *vty_addr = NULL;
 
+#ifdef USE_SRX
+unsigned int g_measureCount=0;
+#endif
+
 /* privileges */
 static zebra_capabilities_t _caps_p [] =  
 {
@@ -164,6 +168,7 @@ redistribution between different routing protocols.\n\n\
 -g, --group        Group to run as\n\
 -v, --version      Print program version\n\
 -C, --dryrun       Check configuration for validity and exit\n\
+-c,                Time Measuring count\n\
 -h, --help         Display this help and exit\n\
 \n\
 Report bugs to %s\n", progname, ZEBRA_BUG_ADDRESS);
@@ -343,7 +348,10 @@ main (int argc, char **argv)
   /* Command line argument treatment. */
   while (1) 
     {
-      opt = getopt_long (argc, argv, "df:i:z:hp:l:A:P:rnu:g:vC", longopts, 0);
+#ifdef USE_SRX
+      //opt = getopt_long (argc, argv, "df:i:z:hp:l:A:P:rnu:g:vC", longopts, 0);
+      opt = getopt_long (argc, argv, "df:i:z:hp:l:A:P:rnu:g:vCc:", longopts, 0);
+#endif
     
       if (opt == EOF)
 	break;
@@ -408,6 +416,12 @@ main (int argc, char **argv)
 	case 'C':
 	  dryrun = 1;
 	  break;
+#ifdef USE_SRX
+        case 'c':
+          g_measureCount=atoi(optarg);
+          printf("[%s] Time Measuring Count: %ld\n", __FUNCTION__, g_measureCount);
+          break;
+#endif
 	case 'h':
 	  usage (progname, 0);
 	  break;
diff --git a/quaggasrx/bgpd/bgp_packet.c b/quaggasrx/bgpd/bgp_packet.c
index f5409ff..6620874 100644
--- a/quaggasrx/bgpd/bgp_packet.c
+++ b/quaggasrx/bgpd/bgp_packet.c
@@ -158,13 +158,15 @@ struct ecommunity* srxEcommunityChange(struct bgp *bgp, struct attr *attr, struc
 
   if(attre)
   {
+    ecom_orig = ecom = attre->ecommunity;
+    if(!ecom)
+    {
     ecom = ecommunity_bgpsec_str2com (bgp->srx_ecommunity_subcode, state);
-    attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES);
-    ecom_orig = attre->ecommunity;
     attre->ecommunity = ecom;
+      ecom_orig = NULL;
+    }
+    attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES);
   }
-  else
-    return NULL;
 
   return ecom_orig;
 }
@@ -175,6 +177,8 @@ int srxEcommunityRestore(struct attr *attr, struct ecommunity* ecom_orig)
   struct ecommunity *ecom=NULL;
   int ret=0;
 
+  if(ecom_orig == NULL)
+  {
   if(attre && attre->ecommunity && (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES)))
   {
     attr->flag &= ~(ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES));
@@ -182,6 +186,7 @@ int srxEcommunityRestore(struct attr *attr, struct ecommunity* ecom_orig)
     attre->ecommunity = ecom_orig;
     ret = 1;
   }
+  }
 
   if(ecom)
     free(ecom);
@@ -2709,6 +2728,14 @@ bgp_read (struct thread *thread)
 
   size = (peer->packet_size - BGP_HEADER_SIZE);
 
+
+//#define TIME_MEASURE_TEST_ENABLED
+#ifdef TIME_MEASURE_TEST_ENABLED
+  extern unsigned int g_measureCount;
+  unsigned long realtime, cputime;
+  static unsigned long tCount=0;
+  static RUSAGE_T before, after;
+#endif /* TIME_MEASURE_TEST_ENABLED */
   /* Read rest of the packet and call each sort of packet routine */
   switch (type)
     {
@@ -2717,8 +2744,26 @@ bgp_read (struct thread *thread)
       bgp_open_receive (peer, size); /* XXX return value ignored! */
       break;
     case BGP_MSG_UPDATE:
+#ifdef TIME_MEASURE_TEST_ENABLED
+      if(tCount==0)
+      {
+        printf("[%s] g_measureCount:%ld starting...\n", __FUNCTION__, g_measureCount);
+        GETRUSAGE (&before);
+      }
+#endif /* TIME_MEASURE_TEST_ENABLED */
       peer->readtime = bgp_recent_clock ();
       bgp_update_receive (peer, size);
+#ifdef TIME_MEASURE_TEST_ENABLED
+      tCount++;
+      if(tCount >= g_measureCount && g_measureCount != 0)
+      {
+        GETRUSAGE (&after);
+        realtime = thread_consumed_time (&after, &before, &cputime);
+        printf ("\n RECV TASK(single): ran for %lums (cpu time %lums)\n", realtime/1000, cputime/1000);
+        tCount=0;
+      }
+#endif /* TIME_MEASURE_TEST_ENABLED */
+
       break;
     case BGP_MSG_NOTIFY:
       bgp_notify_receive (peer, size);
diff --git a/quaggasrx/bgpd/bgp_validate.c b/quaggasrx/bgpd/bgp_validate.c
index 34d97fa..b2eda8d 100644
--- a/quaggasrx/bgpd/bgp_validate.c
+++ b/quaggasrx/bgpd/bgp_validate.c
@@ -1,3 +1,4 @@
+
 #include <zebra.h>
 #ifdef USE_SRX
 
@@ -19,7 +20,11 @@
 #ifdef USE_SRX_CRYPTO_API
 #include "srxcryptoapi.h"
 SRxCryptoAPI *g_capi;
+#define TIME_MEASURE_TEST_ENABLED
+#include "bgpd/bgp_ecommunity.h"
 #define RET_ID_OFFSET 1
+extern unsigned int g_measureCount;
+unsigned long long bgpsec_consumed_time (RUSAGE_T *, RUSAGE_T *, unsigned long long *);
 #endif
 
 /* Hash for bgpsec path.  This is the top level structure of BGPSEC AS path. */
@@ -146,11 +155,12 @@ void bgpsec_path_attr_init (void)
   g_capi->sign_with_id = NULL;
   g_capi->sign_with_key = NULL;
   g_capi->validate = NULL;
-  g_capi->isExtended = NULL;
   if(srxCryptoInit(g_capi) == 0)
   {
     zlog_err("[BGPSEC] SRxCryptoAPI not initialized!\n");
   }
+  if(g_measureCount)
+    printf("[%s] Time Measuring Count: %ld\n", __FUNCTION__, g_measureCount);
 #endif
 }
 
@@ -470,7 +486,8 @@ static struct SigBlock* sigBlock_New(void)
  */
 struct BgpsecPathAttr * bgpsec_parse(struct peer *peer, struct stream *s,
                                      size_t length, afi_t afi,
-                                     struct bgp_nlri *mp_update, int *errCode)
+                                     struct bgp_nlri *mp_update, int *errCode,
+                                     struct attr *attr)
 {
   struct BgpsecPdu pdu;
   u_char *startp, *endp;
@@ -578,8 +601,7 @@ struct BgpsecPathAttr * bgpsec_parse(struct peer *peer, struct stream *s,
   struct SigSegment *ss;
 
 #ifdef USE_SRX_CRYPTO_API
-  u_int8_t keyID_pub=0;
-  u_int8_t fEnablePubKeyValidate=0;
+  static u_int8_t keyID_pub=0;
 #endif
   /*
    * If this is the originating AS
@@ -670,32 +698,40 @@ struct BgpsecPathAttr * bgpsec_parse(struct peer *peer, struct stream *s,
         /* once again to register */
         keyID_pub = g_capi->registerPublicKey(outKeyInfo);
       }
-      else
-      {
-        fEnablePubKeyValidate = 1;
-      }
 
-      if (BGP_DEBUG (bgpsec, BGPSEC_IN) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
+#if 0
+      if (BGP_DEBUG (bgpsec, BGPSEC_OUT) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
       {
         if(outKeyInfo && outKeyInfo->keyData)
-          zlog_debug("[IN] out key: %p, pkey pub key:%p(len:%d) key_id:%x", \
+          zlog_debug("[OUT] out key: %p, pkey pub key:%p(len:%d) key_id:%x", \
               outKeyInfo, outKeyInfo->keyData, outKeyInfo->keyLength, keyID_pub - RET_ID_OFFSET);
       }
+#endif
     }
 #endif /* end VERIFY_WITH_KEY_ENABLED */
 
 #ifdef TIME_MEASURE_TEST_ENABLED
-    unsigned long realtime, cputime;
-    RUSAGE_T before, after;
+#define TIMER_SECOND_MICRO 1000000L
+#define ECOMMUNITY_SIZE                        8
+    unsigned long long realtime, cputime;
+    static RUSAGE_T before, after;
+    struct timeval time_before, time_now;         /* current time */
+    static unsigned long tCount=0;
 
+    if (!CHECK_FLAG (peer->bgp->srx_ecommunity_flags, SRX_BGP_FLAG_ECOMMUNITY))
+    {
+      if(tCount==0)
     GETRUSAGE (&before);
+    }
 #endif /* TIME_MEASURE_TEST_ENABLED */
 
     /* perform validation */
-    if(!fEnablePubKeyValidate && outKeyInfo && outKeyInfo->keyData)
+    if(outKeyInfo && outKeyInfo->keyData)
     {
+#if 0
       if (BGP_DEBUG (bgpsec, BGPSEC_IN) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
         zlog_debug("[%s:%d] calling validation function with keys ", __FUNCTION__, __LINE__);
+#endif
 
       if( g_capi->validate((BgpsecPathAttr*)bpa, num_key, &outKeyInfo, &p, peer->local_as) != BGPSEC_VERIFY_SUCCESS)
       {
@@ -703,23 +739,12 @@ struct BgpsecPathAttr * bgpsec_parse(struct peer *peer, struct stream *s,
         goto ValidateFail;
       }
     }
-    else if(fEnablePubKeyValidate && g_capi->isExtended && g_capi->isExtended())
-    {
-      if (BGP_DEBUG (bgpsec, BGPSEC_IN) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
-        zlog_debug("[%s:%d] calling Extended validation function WITH id ", __FUNCTION__, __LINE__);
-
-      u_int8_t extCode;
-      /* call the library function --> cl_ExtBgpsecVerify */
-      if( g_capi->extValidate((BgpsecPathAttr*)bpa, &p, peer->local_as, &extCode) != BGPSEC_VERIFY_SUCCESS)
-      {
-        *errCode = BGPSEC_VERIFY_ERROR;
-        goto ValidateFail;
-      }
-    }
     else
     {
+#if 0
       if (BGP_DEBUG (bgpsec, BGPSEC_IN) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
         zlog_debug("[%s:%d] calling validation function WITHOUT keys ", __FUNCTION__, __LINE__);
+#endif
 
       /* call the library function --> cl_BgpsecVerify */
       if( g_capi->validate((BgpsecPathAttr*)bpa, 0, NULL, &p, peer->local_as) != BGPSEC_VERIFY_SUCCESS)
@@ -729,10 +754,65 @@ struct BgpsecPathAttr * bgpsec_parse(struct peer *peer, struct stream *s,
       }
     }
 #ifdef TIME_MEASURE_TEST_ENABLED
+    if (!CHECK_FLAG (peer->bgp->srx_ecommunity_flags,  SRX_BGP_FLAG_ECOMMUNITY))
+    {
+      tCount++;
+      if(tCount >= g_measureCount && g_measureCount != 0)
+      {
     GETRUSAGE (&after);
+        //realtime = thread_consumed_time (&after, &before, &cputime);
+        realtime = bgpsec_consumed_time (&after, &before, &cputime); // return in milisecond
+        //printf ("VALIDATION TASK(single): ran for %lld ms (cpu time %lld ms)\n", realtime/1000, cputime/1000);
+        printf ("VALIDATION TASK(single): ran for %lld ms (cpu time %lld ms)\n", realtime, cputime);
+        tCount=0;
+      }
+    }
+    else
+    {
+      if (CHECK_FLAG (peer->bgp->srx_ecommunity_flags,  SRX_BGP_FLAG_ECOMMUNITY_END))
+      {
+        RUSAGE_T temp;
+        GETRUSAGE (&temp);
+        struct timeval tval = temp.real;
 
-    realtime = thread_consumed_time (&after, &before, &cputime);
-    zlog_info ("VALIDATION TASK(single): ran for %lums (cpu time %lums)", realtime/1000, cputime/1000);
+        printf("+++ [%s] GERRUSAGE TIME -- sec: %lu(0x%08x) msec: %lu(0x%08x)\n",
+            __FUNCTION__,
+            tval.tv_sec, tval.tv_sec,
+            tval.tv_usec/1000, tval.tv_usec/1000);
+
+        /* here extended community time-stamp parsing */
+        struct ecommunity_val eval;
+        struct ecommunity *ecom;
+        int c=0;
+        unsigned long int val;
+        unsigned short sec;
+        u_int8_t *p;
+        as_t asn=0;
+
+        if(attr->extra)
+          ecom = attr->extra->ecommunity;
+
+        if(ecom)
+        {
+          for (p = ecom->val; c < ecom->size; p += ECOMMUNITY_SIZE, c++)
+          {
+            memcpy (&eval, p, ECOMMUNITY_SIZE);
+            if(eval.val[2] == 0) continue;
+            memcpy (&asn, &eval.val[0], 2);
+            memcpy (&sec, &eval.val[2], 2);
+            memcpy (&val, &eval.val[4], 4);
+            printf("ecommunity time stamps - as: 0x%04x %lu(0x%04x)sec %lu(0x%08x)msec \n",
+                asn, sec, sec, val, val );
+          }
+          printf("ecommunity time stamps - as: 0x%04x %lu(0x%04x)sec %lu(0x%08x)msec \n",
+              asn, tval.tv_sec & 0xFFFF, tval.tv_sec & 0xFFFF, tval.tv_usec/1000, tval.tv_usec/1000);
+        }
+        else
+        {
+          printf("there's no extended community \n");
+        }
+      }
+    }
 #endif /* TIME_MEASURE_TEST_ENABLED */
 
     /* release parameter resources */
@@ -822,12 +908,6 @@ struct BgpsecPathAttr * bgpsec_parse(struct peer *peer, struct stream *s,
 
       stream_get(ss->ski, s, BGPSEC_SKI_LENGTH);    // SKI
       ss->sigLen           = stream_getw(s);        // Signature Length
-
-      if (STREAM_READABLE(s) < ss->sigLen)          // bounds check
-      {
-        zlog_err("Bad bgpsec signautre length: bigger than remaining byte");
-        return NULL;                                // syntatic check failed
-      }
       ss->signature = signature_new(ss->sigLen);
       stream_get(ss->signature, s, ss->sigLen);     // signauture
 
@@ -876,28 +956,25 @@ struct BgpsecPathAttr * bgpsec_parse(struct peer *peer, struct stream *s,
         /* load key info for pubkey in forms of DER */
         if(sca_loadKey(arrOutKeyInfo[idx], 0 /* pubkey */) == 0)
         {
-          if (BGP_DEBUG (bgpsec, BGPSEC_IN) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
+          if (BGP_DEBUG (bgpsec, BGPSEC_OUT) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
             zlog_err("[%s:%d] failed to load pubkey", __FUNCTION__, __LINE__);
           arrOutKeyInfo[idx]->keyData = NULL;
           arrOutKeyInfo[idx]->keyLength = 0;
         }
         /* once again to register */
-        // TODO: pub key ids also should be stored as a list
         keyID_pub = g_capi->registerPublicKey(arrOutKeyInfo[idx]);
       }
-      else
-      {
-        fEnablePubKeyValidate = 1;
-      }
 
       /* chaining for iteration */
       if(tmp_ss->next)
@@ -921,17 +998,26 @@ struct BgpsecPathAttr * bgpsec_parse(struct peer *peer, struct stream *s,
     }
 
 #ifdef TIME_MEASURE_TEST_ENABLED
-    unsigned long realtime, cputime;
-    RUSAGE_T before, after;
+    unsigned long long realtime, cputime;
+    static unsigned long tCount=0;
+    static RUSAGE_T before, after;
+    struct timeval time_before, time_now;         /* current time */
+
+    if (!CHECK_FLAG (peer->bgp->srx_ecommunity_flags,  SRX_BGP_FLAG_ECOMMUNITY))
+    {
+      if(tCount==0)
     GETRUSAGE (&before);
+    }
 #endif /* TIME_MEASURE_TEST_ENABLED */
 
     /* TODO: more robust function to check all key pointers in array below */
     //IS_KEYINFO_OK
     if(!arrOutKeyInfo[0])
     {
 
       /* call the library function --> bgpsecVerify */
       if( g_capi->validate((BgpsecPathAttr*)bpa, 0, NULL, &p, peer->local_as)\
@@ -943,38 +1029,78 @@ struct BgpsecPathAttr * bgpsec_parse(struct peer *peer, struct stream *s,
     }
     else
     {
-      /* TODO: need to check for each id is to match with fEnablePubKey flag */
-      if(fEnablePubKeyValidate && g_capi->isExtended && g_capi->isExtended())
-      {
+#if 0
         if (BGP_DEBUG (bgpsec, BGPSEC_IN) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
-          zlog_debug("[%s:%d] calling Extended validation function WITH id ", __FUNCTION__, __LINE__);
-
-        u_int8_t extCode;
-        /* call the library function --> cl_ExtBgpsecVerify */
-        if( g_capi->extValidate((BgpsecPathAttr*)bpa, &p, peer->local_as,
-              &extCode) != BGPSEC_VERIFY_SUCCESS)
+        zlog_debug("[%s:%d] calling validation function with keys ", __FUNCTION__, __LINE__);
+#endif
+      if( g_capi->validate((BgpsecPathAttr*)bpa, numSecurePathSegment, \
+            arrOutKeyInfo, &p, peer->local_as) != BGPSEC_VERIFY_SUCCESS)
         {
           *errCode = BGPSEC_VERIFY_ERROR;
           goto ValidateFail;
         }
       }
-      else
+#ifdef TIME_MEASURE_TEST_ENABLED
+    if (!CHECK_FLAG (peer->bgp->srx_ecommunity_flags,  SRX_BGP_FLAG_ECOMMUNITY))
       {
-        if (BGP_DEBUG (bgpsec, BGPSEC_IN) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
-          zlog_debug("[%s:%d] calling validation function with keys ", __FUNCTION__, __LINE__);
+      tCount++;
+      if(tCount >= g_measureCount && g_measureCount != 0)
+      {
+        GETRUSAGE (&after);
+        //realtime = thread_consumed_time (&after, &before, &cputime);
+        realtime = bgpsec_consumed_time (&after, &before, &cputime); // return in milisecond
+        //printf ("VALIDATION TASK: ran for %lld ms (cpu time %lld ms)\n", realtime/1000, cputime/1000);
+        printf ("VALIDATION TASK: ran for %lld ms (cpu time %lld ms)\n", realtime, cputime);
+        tCount=0;
+      }
+    }
+    else /* ext community calculation for end-node */
+    {
+      if (CHECK_FLAG (peer->bgp->srx_ecommunity_flags,  SRX_BGP_FLAG_ECOMMUNITY_END))
+      {
+        RUSAGE_T temp;
+        GETRUSAGE (&temp);
+        struct timeval tval = temp.real;
 
-        if( g_capi->validate((BgpsecPathAttr*)bpa, numSecurePathSegment, \
-              arrOutKeyInfo, &p, peer->local_as) != BGPSEC_VERIFY_SUCCESS)
+        printf("+++ [%s] GERRUSAGE TIME -- sec: %lu(0x%08x) msec: %lu(0x%08x)\n",
+            __FUNCTION__,
+            tval.tv_sec, tval.tv_sec,
+            tval.tv_usec/1000, tval.tv_usec/1000);
+
+        /* here extended community time-stamp parsing */
+        struct ecommunity_val eval;
+        struct ecommunity *ecom;
+        int c=0;
+        unsigned long int val;
+        unsigned short sec;
+        u_int8_t *p;
+        as_t asn=0;
+
+        if(attr->extra)
+          ecom = attr->extra->ecommunity;
+
+        if(ecom)
         {
-          *errCode = BGPSEC_VERIFY_ERROR;
-          goto ValidateFail;
+          for (p = ecom->val; c < ecom->size; p += ECOMMUNITY_SIZE, c++)
+          {
+            memcpy (&eval, p, ECOMMUNITY_SIZE);
+            if(eval.val[2] == 0) continue;
+            memcpy (&asn, &eval.val[0], 2);
+            memcpy (&sec, &eval.val[2], 2);
+            memcpy (&val, &eval.val[4], 4);
+            printf("ecommunity time stamps - as: 0x%04x %lu(0x%04x)sec %lu(0x%08x)msec \n",
+                asn, sec, sec, val, val );
         }
+          printf("ecommunity time stamps - as: 0x%04x %lu(0x%04x)sec %lu(0x%08x)msec \n",
+                asn, tval.tv_sec & 0xFFFF, tval.tv_sec & 0xFFFF, tval.tv_usec/1000, tval.tv_usec/1000);
       }
+        else
+        {
+          printf("there's no extended community \n");
+        }
+      }
+
     }
-#ifdef TIME_MEASURE_TEST_ENABLED
-    GETRUSAGE (&after);
-    realtime = thread_consumed_time (&after, &before, &cputime);
-    zlog_info ("VALIDATION TASK: ran for %lums (cpu time %lums)", realtime/1000, cputime/1000);
 #endif /* TIME_MEASURE_TEST_ENABLED */
 
     /* release all resources - keyInfoData or others */
@@ -1223,7 +1367,6 @@ int bgpsecPathAttribute(struct bgp *bgp, struct peer *peer,
   u_int8_t pCount = 0;
   u_int8_t spFlags = 0x00;
   int sig_length = 0;
-  int ret=0;
   unsigned int i;
 
 #define OFFSET_BGP_FLAG 4
@@ -1254,6 +1397,7 @@ int bgpsecPathAttribute(struct bgp *bgp, struct peer *peer,
   if(aspath->segments == NULL)
     return -1;
 
+#if 0
   if (BGP_DEBUG (bgpsec, BGPSEC_OUT) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
   {
     zlog_debug("[OUT] duplicated bgpsec_aspath:%p aspath->segments:%p", aspath, aspath->segments);
@@ -1267,10 +1411,10 @@ int bgpsecPathAttribute(struct bgp *bgp, struct peer *peer,
     zlog_debug("[OUT] ATTR:cp[%d]: 0x%02X FLAG:cp[%d]: 0x%02X ",
         cp-OFFSET_BGP_ATTR, fBgpAttr, cp-OFFSET_BGP_FLAG, fBgpFlag );
   }
+#endif
 
 #ifdef USE_SRX_CRYPTO_API
   static u_int8_t       keyID_priv=0;
-  static BGPSecKey*     outKeyInfo=NULL;
 #endif
 
   // TODO: enable this after error debuggin
@@ -1304,10 +1448,6 @@ int bgpsecPathAttribute(struct bgp *bgp, struct peer *peer,
      * +-------------------------------------+
      * | Algorithm Suite Id.     : 1 octet   |
      * +-------------------------------------+
-     * | AFI                     : 2 octet   |
-     * +-------------------------------------+
-     * | SAFI                    : 1 octet   |
-     * +-------------------------------------+
      * | NLRI Length             : 1 octet   |
      * +-------------------------------------+
      * | NLRI prefix             : (variable)|
@@ -1315,48 +1455,69 @@ int bgpsecPathAttribute(struct bgp *bgp, struct peer *peer,
      */
 
     pCount = 1;
+    /* create data to sign */
+    put_u32(hashbuff, remoteAS);
+    put_u32(hashbuff+4, oas);
+
 
+#if 0
     if (BGP_DEBUG (bgpsec, BGPSEC_OUT) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
       zlog_debug("[OUT] ++ origin AS: %d remote AS:%d local AS: %d", oas, remoteAS, localAS);
+#endif
 
+    /* pCount of 1, and no confed flag handling yet */
+    hashbuff[8] = pCount;
+    hashbuff[9] = 0x00;
+    hashbuff[10] = BGPSEC_ALGO_ID;
+    hashbuff[11] = p->prefixlen; // NLRI length
 
     size_t psize = PSIZE (p->prefixlen);
+    memcpy((hashbuff+12), &p->u.prefix, psize); // NLRI prefix
+
+#ifdef HAVE_IPV6
+    hashbuff[12+psize] = (p->family == AF_INET6) ? AFI_IP6 : AFI_IP;
+#endif /* HAVE_IPV6 */
 
+#if 0
     if (BGP_DEBUG (bgpsec, BGPSEC_OUT) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
       zlog_debug("[OUT] prefix_length: %d psize: %d, prefix: 0x%08x", \
           p->prefixlen, psize, p->u.prefix);
+#endif
 
 #ifdef USE_SRX_CRYPTO_API
+    //u_int8_t keyID=0;
+    BGPSecKey* outKeyInfo=NULL;
+
     BGPSecSignData bgpsecSignData = {
+#ifdef HAVE_IPV6
+      .dataLength       = (p->family == AF_INET6)? 12+psize+BGPSEC_AFI_LENGTH:
+                                                                     12+psize,
+#else
+      .dataLength       = (12+psize),
+#endif /* HAVE_IPV6 */
       .data             = hashbuff,
-      .dataLength       = sizeof(hashbuff),
+      .algoID           = BGPSEC_ALGO_ID,
       .sigLen           = BGPSEC_MAX_SIG_LENGTH,
       .signature        = sigbuff,
     };
 
-    /* call srx-crypto-api function */
-    sca_generateMSG1(bgpsecSignData.data, &bgpsecSignData.dataLength,
-        remoteAS, oas,
-        pCount, spFlags, BGPSEC_ALGO_ID, AFI_IP, SAFI_UNICAST,
-        p->prefixlen, &p->u.prefix);
-
+    bgpsecSignData.ski = (u_int8_t *)malloc(BGPSEC_SKI_LENGTH);
+    memcpy(bgpsecSignData.ski, bski, BGPSEC_SKI_LENGTH);
 
     /*
      * Register Private Key information
      */
-    if(!outKeyInfo) // intializing only first time
-    {
       outKeyInfo= (BGPSecKey*) malloc(sizeof(BGPSecKey));
-      memset(outKeyInfo, 0x0, sizeof(BGPSecKey));
-    }
-
     if(!outKeyInfo)
     {
+#if 0
       if (BGP_DEBUG (bgpsec, BGPSEC_OUT) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
         zlog_err("[%s:%d] mem allocation failed", __FUNCTION__, __LINE__);
+#endif
     }
     else
     {
+      memset(outKeyInfo, 0x0, sizeof(BGPSecKey));
       outKeyInfo->algoID        = BGPSEC_ALGO_ID;
       outKeyInfo->asn           = localAS;
       memcpy(outKeyInfo->ski, bski, BGPSEC_SKI_LENGTH);
@@ -1514,40 +1678,56 @@ int bgpsecPathAttribute(struct bgp *bgp, struct peer *peer,
 
     /* create data to sign */
     size_t sigSegLen = new_bpa->sigBlocks->sigSegments->sigLen;
-
+    put_u32(hashbuff, remoteAS);
+    put_u32(hashbuff+4, localAS);
     /* pCount of 1, and no confed flag handling yet */
     pCount = 1;
+    hashbuff[8] = pCount;   // pCount
+    hashbuff[9] = 0x00;     // Flags
+    memcpy(hashbuff+10, new_bpa->sigBlocks->sigSegments->signature, sigSegLen);
+
     size_t totalHashLen = 10 + sigSegLen;
 
 
 #ifdef USE_SRX_CRYPTO_API
+    //u_int32_t keyID=0;
+    BGPSecKey* outKeyInfo=NULL;
 
     BGPSecSignData bgpsecSignData = {
-      .dataLength       = sizeof(hashbuff),
+      .dataLength       = totalHashLen,
       .data             = hashbuff,
+      .algoID           = BGPSEC_ALGO_ID,
       .sigLen           = BGPSEC_MAX_SIG_LENGTH,
       .signature        = sigbuff,
     };
 
-    /* call srx-crypto-api function */
-    sca_generateMSG2(bgpsecSignData.data , &bgpsecSignData.dataLength,
-        remoteAS, localAS, pCount, spFlags,
-        sigSegLen, new_bpa->sigBlocks->sigSegments->signature);
+    bgpsecSignData.ski = (u_int8_t *)malloc(BGPSEC_SKI_LENGTH);
+    memcpy(bgpsecSignData.ski, bski, BGPSEC_SKI_LENGTH);
 
     /* Register Private Key information */
-    if(!outKeyInfo)
-    {
       outKeyInfo= (BGPSecKey*) malloc(sizeof(BGPSecKey));
-      memset(outKeyInfo, 0x0, sizeof(BGPSecKey));
-    }
-
     if(!outKeyInfo)
     {
+#if 0
       if (BGP_DEBUG (bgpsec, BGPSEC_OUT) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
         zlog_err("[%s:%d] mem allocation failed", __FUNCTION__, __LINE__);
+#endif
     }
     else
     {
+      memset(outKeyInfo, 0x0, sizeof(BGPSecKey));
       outKeyInfo->algoID        = BGPSEC_ALGO_ID;
       outKeyInfo->asn           = localAS;
       memcpy(outKeyInfo->ski, bski, BGPSEC_SKI_LENGTH);
@@ -1568,59 +1750,52 @@ int bgpsecPathAttribute(struct bgp *bgp, struct peer *peer,
       /* call register function in srx crypto api */
       keyID_priv = g_capi->registerPrivateKey(outKeyInfo);
 
+#if 0
       if (BGP_DEBUG (bgpsec, BGPSEC_OUT) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
       {
         if(outKeyInfo && outKeyInfo->keyData)
           zlog_debug("[OUT] out key: %p, ec key:%p key_id:%x", \
               outKeyInfo, outKeyInfo->keyData, keyID_priv - RET_ID_OFFSET);
       }
+#endif
     }
 
-    if (bgp->bgpsec_sign_method_flag == BGPSEC_SIGN_WITH_ID)
-    {
-      ret = g_capi->libHandle == NULL ? 0
-        : keyID_priv != 0 ? g_capi->sign_with_id(&bgpsecSignData, keyID_priv)
-        : g_capi->sign_with_key(&bgpsecSignData, outKeyInfo);
-    }
-    else // default: sign with key
-    {
-      ret = g_capi->libHandle == NULL ? 0
+#ifdef SIGN_WITH_ID_ENABLED
+    sig_length = g_capi->libHandle == NULL ? 0
+                 : keyID_priv != 0 ? g_capi->sign_with_id(totalHashLen, hashbuff,
+                     keyID_priv, BGPSEC_MAX_SIG_LENGTH, sigbuff)
         : g_capi->sign_with_key(&bgpsecSignData, outKeyInfo);
-    }
 
-    sig_length = bgpsecSignData.sigLen;
+#else /* SIGN_WITH_ID_ENABLED */
+    sig_length = g_capi->libHandle == NULL ? 0
+                 : g_capi->sign_with_key(&bgpsecSignData, outKeyInfo);
+#endif /* SIGN_WITH_ID_ENABLED */
 
-    /* release temporary allocated pointer if it was allocated by sca_generateMSG
-     * in srxcryptoapi */
-    if(bgpsecSignData.data != hashbuff && bgpsecSignData.data)
-    {
-      free(bgpsecSignData.data);
-    }
+    /* release parameter resources */
+    if(bgpsecSignData.ski)
+      free(bgpsecSignData.ski);
 
-    /*
-     * TODO: need to release outKeyInfo and it's keyData, in order to do that, this pointer needs
-     * to be a part of the upper pointer structure. e.g., bgp or peer
     if(outKeyInfo)
     {
       if(outKeyInfo->keyData)
         free(outKeyInfo->keyData);
       free(outKeyInfo);
     }
-    */
 #endif /* USE_SRX_CRYPTO_API */
 
-    if ( 1 >= sig_length || sig_length > 72)
+    if ( 1 >= sig_length )
     {
+#if 0
       if (BGP_DEBUG (bgpsec, BGPSEC_OUT) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
         zlog_err("[OUT] bgpsec_sign:%d>%d:o: signing failed", localAS, remoteAS);
+#endif
       return -1;
     }
 
+#if 0
     if (BGP_DEBUG (bgpsec, BGPSEC_OUT) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
     {
       zlog_debug("[OUT] signature print");
-      if(zlog_default->maxlvl[ZLOG_DEST_STDOUT] > 0)
-      {
         /* signature print out */
         for( i=0; i< (unsigned int)sig_length; i++ )
         {
@@ -1629,7 +1804,7 @@ int bgpsecPathAttribute(struct bgp *bgp, struct peer *peer,
         }
         printf("\n");
       }
-    }
+#endif
 
     /* first, fill in and concatenate this router information */
     /* BGPSEC_Path attribute and Secure_Path structures */
@@ -1937,51 +2115,12 @@ extern int bgpsecVerifyCaller(struct peer *peer, struct BgpsecPathAttr *bpa, str
 
   int retVal;
 
-  /*
-   * key load processing
-   */
-  const int numSecurePathSegment =
-      (bpa->securePathLen - OCTET_SECURE_PATH_LEN) / OCTET_SECURE_PATH_SEGMENT;
-
-  BGPSecKey *arrOutKeyInfo[numSecurePathSegment];
-  memset(arrOutKeyInfo, 0, numSecurePathSegment * sizeof(BGPSecKey*));
-  int idx=0; u_int32_t keyCnt=0;
-
-  int iter = numSecurePathSegment;                // reset iterration
-  struct PathSegment *curr_ps = bpa->pathSegments;
-  struct SigSegment  *curr_ss = bpa->sigBlocks->sigSegments;
-
-  while (iter && curr_ps && curr_ss)
-  {
-    idx = numSecurePathSegment - iter;
-
-    arrOutKeyInfo[idx] = (BGPSecKey*) malloc(sizeof(BGPSecKey));
-    memset(arrOutKeyInfo[idx] , 0x0, sizeof(BGPSecKey));
-
-    arrOutKeyInfo[idx]->asn = curr_ps->as;
-    memcpy(arrOutKeyInfo[idx]->ski, curr_ss->ski, BGPSEC_SKI_LENGTH);
-
-    if(sca_loadKey(arrOutKeyInfo[idx], 0 /* pubkey */) == 0)
-    {
-      if (BGP_DEBUG (bgpsec, BGPSEC_OUT) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
-        zlog_err("[%s:%d] failed to load pubkey", __FUNCTION__, __LINE__);
-      arrOutKeyInfo[idx]->keyData = NULL;
-      arrOutKeyInfo[idx]->keyLength = 0;
-    }
-
-    curr_ps = curr_ps->next;
-    curr_ss = curr_ss->next;
-    iter--;
-    keyCnt++;
-  }
-
-
   /* call the library function --> bgpsecVerify */
   if (g_capi->libHandle == NULL)
   {
     retVal = BGPSEC_VERIFY_ERROR;
   }
-  else if( (retVal =  g_capi->validate((BgpsecPathAttr*)bpa, numSecurePathSegment, &arrOutKeyInfo, &p, peer->local_as)) != BGPSEC_VERIFY_SUCCESS)
+  else if( (retVal =  g_capi->validate((BgpsecPathAttr*)bpa, 0, NULL, &p, peer->local_as)) != BGPSEC_VERIFY_SUCCESS)
   {
     retVal = BGPSEC_VERIFY_ERROR;
 
@@ -1991,17 +2130,6 @@ extern int bgpsecVerifyCaller(struct peer *peer, struct BgpsecPathAttr *bpa, str
     // --> change above, because even though validation failed, bpa should be remained in aspath interned structure
   }
 
-  /* release all resources - keyInfoData or others */
-  for(idx=0; idx < keyCnt; idx++)
-  {
-    if(arrOutKeyInfo[idx])
-    {
-      if(arrOutKeyInfo[idx]->keyData)
-        free(arrOutKeyInfo[idx]->keyData);
-      free(arrOutKeyInfo[idx]);
-    }
-  }
-
   return retVal;
 #else
   return 0;
@@ -2043,11 +2171,7 @@ void test_print(struct BgpsecPdu pdu, size_t *bptr, char *sigbuff, char* hashbuf
 }
 
 
-/**
- * Print the given information using std-io
- *
- * @param bpa The BgpsecPathAttr.
- */
+
 void print_signature(struct BgpsecPathAttr *bpa)
 {
   //struct BgpsecPathAttr *new_bpa;
@@ -2059,9 +2183,6 @@ void print_signature(struct BgpsecPathAttr *bpa)
 
   int i;
   int sig_length = ss->sigLen;
-
-  if(zlog_default->maxlvl[ZLOG_DEST_STDOUT] > 0)
-  {
     /* signature print out */
     for(i=0; i<sig_length; i++ )
     {
@@ -2069,7 +2190,7 @@ void print_signature(struct BgpsecPathAttr *bpa)
       printf("%02x ", (unsigned char)ss->signature[i]);
     }
     printf(" - from[%s]\n", __FUNCTION__);
-  }
+
 }
 
 int bgpsecSanityCheck(struct BgpsecPathAttr *bpa)
@@ -2227,6 +2348,28 @@ unsigned char hex2bin_byte(char* in)
   return result;
 }
 
+#ifdef TIME_MEASURE_TEST_ENABLED
+#define TIMER_SECOND_MILI 1000L
+static unsigned long long
+bgpsec_timeval_elapsed (struct timeval a, struct timeval b)
+{
+  return (((a.tv_sec - b.tv_sec) * TIMER_SECOND_MILI)
+	  + (a.tv_usec - b.tv_usec) / TIMER_SECOND_MILI);
+}
+
+unsigned long long
+bgpsec_consumed_time (RUSAGE_T *now, RUSAGE_T *start, unsigned long long *cputime)
+{
+#ifdef HAVE_RUSAGE
+  /* This is 'user + sys' time.  */
+  *cputime = bgpsec_timeval_elapsed (now->cpu.ru_utime, start->cpu.ru_utime) +
+	     bgpsec_timeval_elapsed (now->cpu.ru_stime, start->cpu.ru_stime);
+#else
+  *cputime = 0;
+#endif /* HAVE_RUSAGE */
+  return bgpsec_timeval_elapsed (now->real, start->real);
+}
+#endif /* TIME_MEASURE_TEST_ENABLED */
 
 
 
diff --git a/quaggasrx/bgpd/bgp_validate.h b/quaggasrx/bgpd/bgp_validate.h
index 344ad66..9a3b58d 100644
--- a/quaggasrx/bgpd/bgp_validate.h
+++ b/quaggasrx/bgpd/bgp_validate.h
@@ -19,9 +19,9 @@
 #define BGPSEC_DEFAULT_CURVE BGPSEC_ALGORITHM_SHA256_ECDSA_P_256
 #define DEFAULT_KEY_REPO_PATH "/users/kyehwanl/proj-bgp/bgpsec-keys/"
 
-#define BGPSEC_VERIFY_SUCCESS       1
-#define BGPSEC_VERIFY_ERROR         -1
-#define BGPSEC_VERIFY_MISMATCH      0
+#define BGPSEC_VERIFY_SUCCESS       0
+#define BGPSEC_VERIFY_ERROR         1
+#define BGPSEC_VERIFY_MISMATCH      2
 
 #define OCTET_SECURE_PATH_SEGMENT   6
 #define OCTET_SECURE_PATH_LEN       2
@@ -113,7 +113,7 @@ int bgpsecVerifySingle(struct peer *, struct BgpsecPathAttr *, struct prefix);
 int bgpsecVerify(struct peer *, struct BgpsecPathAttr *, struct prefix);
 int bgpsecSanityCheck(struct BgpsecPathAttr *);
 struct BgpsecPathAttr *bgpsec_parse(struct peer *, struct stream *, size_t,
-                                    afi_t, struct bgp_nlri *, int*);
+                                    afi_t, struct bgp_nlri *, int*, struct attr *);
 struct BgpsecPathAttr * bgpsec_parse_iBGP(struct peer *, struct stream *, size_t);
 int bgpsecPathAttribute_iBGP(struct bgp *, struct peer *, struct aspath *,
                         struct prefix *, struct stream *, struct BgpsecPathAttr *);
diff --git a/quaggasrx/bgpd/bgp_vty.c b/quaggasrx/bgpd/bgp_vty.c
index 7878f69..52dd3af 100644
--- a/quaggasrx/bgpd/bgp_vty.c
+++ b/quaggasrx/bgpd/bgp_vty.c
@@ -1620,6 +1620,7 @@ DEFUN (bgpsec_ski,
 
   if (strlen(argv[0]) == 0)
   {
+    // TODO: SKI length sould be checked here as 20-letter long hex-string
     vty_out (vty, "%% Empty SKI %s", VTY_NEWLINE);
     return CMD_ERR_INCOMPLETE;
   }
@@ -1644,31 +1645,6 @@ DEFUN (bgpsec_ski,
   return CMD_SUCCESS;
 }
 
-DEFUN (bgpsec_sign,
-       bgpsec_sign_cmd,
-       "bgpsec sign (key|id)",
-       "bgpsec signing using key or id")
-{
-
-  u_char flag = 0;
-  struct bgp *bgp;
-  bgp = vty->index;
-
-  if (strncmp (argv[0], "i", 1) == 0)
-    flag = BGPSEC_SIGN_WITH_ID;
-  else if(strncmp(argv[0], "k", 1) == 0)
-    flag = BGPSEC_SIGN_WITH_KEY;
-  else
-    return CMD_WARNING;
-
-  bgp->bgpsec_sign_method_flag = flag;
-
-  //vty_out (vty, "%% bgpsec_sign_method:%08x %s", bgp->bgpsec_sign_method_flag,  VTY_NEWLINE);
-  return CMD_SUCCESS;
-}
-
-
-
 DEFUN (srx_connect,
        srx_connect_cmd,
        SRX_VTY_CMD_CONNECT,
@@ -10030,7 +10006,6 @@ bgp_vty_init (void)
   install_element (BGP_NODE, &srx_policy_prefer_valid_cmd);
   install_element (BGP_NODE, &no_srx_policy_prefer_valid_cmd);
   install_element (BGP_NODE, &bgpsec_ski_cmd);
-  install_element (BGP_NODE, &bgpsec_sign_cmd);
   install_element (BGP_NODE, &srx_send_extcommunity_cmd);
   install_element (BGP_NODE, &srx_send_extcommunity_ebgp_cmd);
   install_element (BGP_NODE, &no_srx_send_extcommunity_cmd);
diff --git a/quaggasrx/bgpd/bgpd.c b/quaggasrx/bgpd/bgpd.c
index ddca162..a69f3f8 100644
--- a/quaggasrx/bgpd/bgpd.c
+++ b/quaggasrx/bgpd/bgpd.c
@@ -917,7 +917,11 @@ int srx_extcommunity_set (struct bgp *bgp, uint8_t subcode, const char* cmd)
   // Modify EBGP flag only if command is given!
   if(strlen(cmd) > 0)
   {
-    if (strncmp("inc", cmd, 3) == 0)
+    if (strncmp("end", cmd, 3) == 0)
+    {
+      SET_FLAG(bgp->srx_ecommunity_flags, SRX_BGP_FLAG_ECOMMUNITY_END);
+    }
+    else if (strncmp("inc", cmd, 3) == 0)
     { // In case the command starts with inc then set the flag for include eBGP
       SET_FLAG(bgp->srx_ecommunity_flags, SRX_BGP_FLAG_ECOMMUNITY_EBGP);
     }
diff --git a/quaggasrx/bgpd/bgpd.h b/quaggasrx/bgpd/bgpd.h
index 0bebe2f..407c6cc 100644
--- a/quaggasrx/bgpd/bgpd.h
+++ b/quaggasrx/bgpd/bgpd.h
@@ -223,7 +223,7 @@ Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
                               " validation result transmission\n" \
                              "The sub code of the extended community.\n"
 
-#define SRX_VTY_CMD_EXT_CSTR_EBGP SRX_VTY_CMD_EXT_CSTR " (include_ebgp|only_ibgp)"
+#define SRX_VTY_CMD_EXT_CSTR_EBGP SRX_VTY_CMD_EXT_CSTR " (include_ebgp|only_ibgp|end)"
 #define SRX_VTY_HLP_EXT_CSTR_EBGP SRX_VTY_HLP_EXT_CSTR \
                                   "Include eBGP peers (optional)\n" \
                                   "Only iBGP peers - also used to turn off eBGP peers\n"
@@ -446,14 +446,10 @@ struct bgp
   /* bgpsec ski value */
   char* bgpsec_ski;
 
-  /* bgpsec signing method */
-  u_char bgpsec_sign_method_flag;
-#define BGPSEC_SIGN_WITH_KEY        (1 << 0)
-#define BGPSEC_SIGN_WITH_ID         (1 << 1)
-
   /** Contains the information if extended community is used and the subcode*/
 #define SRX_BGP_FLAG_ECOMMUNITY      (1 << 0)
 #define SRX_BGP_FLAG_ECOMMUNITY_EBGP (1 << 1)
+#define SRX_BGP_FLAG_ECOMMUNITY_END  (1 << 2)
   u_int8_t srx_ecommunity_flags;
   u_int8_t srx_ecommunity_subcode;
 #endif /* USE_SRX */
