--- ./bgpd/bgpd.c	2013-02-01 11:55:27.000000000 -0500
+++ ./bgpd/bgpd.c	2017-07-05 12:04:09.000000000 -0400
@@ -62,6 +62,24 @@ Software Foundation, Inc., 59 Temple Pla
 #include "bgpd/bgp_snmp.h"
 #endif /* HAVE_SNMP */
 
+#ifdef USE_SRX
+#include "bgpd/bgp_info_hash.h"
+#include "bgpd/bgp_validate.h"
+
+
+// Forward Declaration
+bool handleSRxValidationResult (SRxUpdateID updateID, uint32_t localID,
+                                ValidationResultType valType,
+                                uint8_t roaResult, uint8_t bgpsecResult,
+                                void* bgpRouter);
+void handleSRxSignatures(SRxUpdateID updateID, BGPSecCallbackData* data,
+                                       void* bgpRouter);
+void handleSRxSynchRequest(void* bgpRouter);
+void handleSRxMessages(SRxProxyCommCode mainCode, int subCode, void* userPtr);
+void srx_set_default(struct bgp *bgp);
+int respawnReceivePacket(struct thread *t);
+#endif /* USE_SRX */
+
 /* BGP process wide configuration.  */
 static struct bgp_master bgp_master;
 
@@ -156,6 +174,73 @@ bgp_config_check (struct bgp *bgp, int c
   return CHECK_FLAG (bgp->config, config);
 }
 
+#ifdef USE_SRX
+/**
+ * Sets all flags specified in flags in bgp->srx_config.
+ *
+ * @param bgp The bgp instance
+ * @param flags the flags to be set
+ */
+static void srx_config_set (struct bgp *bgp, int flags)
+{
+  SET_FLAG (bgp->srx_config, flags);
+}
+
+/**
+ * Removes all flags specified in flags from bgp->srx_config.
+ *
+ * @param bgp The bgp instance
+ * @param flags the flags to be unset
+ */
+static void srx_config_unset (struct bgp *bgp, int flags)
+{
+  UNSET_FLAG (bgp->srx_config, flags);
+}
+
+/**
+ * Checks for the existance of all flags specified in flags. The check is
+ * performed on bgp->srx_config.
+ *
+ * @param bgp The bgp instance
+ * @param flags the flags to be checked for
+ */
+int srx_config_check (struct bgp *bgp, uint16_t flags)
+{
+  return (bgp->srx_config & flags) == flags;
+}
+
+/**
+ * Set the proxy ID only if no connection to the srx server is established.
+ *
+ * @param bgp The bgp instance
+ * @param proxyID the proxy id to be set (in host representation)
+ *
+ * @return CMD_SUCCESS if successful, otherwise CMD_WARNING
+ *
+ * @since 0.3.0
+ */
+int srx_set_proxyID(struct bgp* bgp, uint32_t proxyID)
+{
+  int retVal = CMD_SUCCESS;
+  if (!isConnected(bgp->srxProxy))
+  {
+    bgp->srx_proxyID = proxyID;
+    if (bgp->srxProxy != NULL)
+    {
+      // Proxy is already generated but not active yet, assign the proxy ID
+      bgp->srxProxy->proxyID = bgp->srx_proxyID;
+    }
+  }
+  else
+  {
+    retVal = CMD_WARNING;
+  }
+
+  return retVal;
+}
+
+#endif /* USE_SRX */
+
 /* Set BGP router identifier. */
 int
 bgp_router_id_set (struct bgp *bgp, struct in_addr *id)
@@ -182,6 +267,12 @@ bgp_router_id_set (struct bgp *bgp, stru
                           BGP_NOTIFY_CEASE_CONFIG_CHANGE);
        }
     }
+#ifdef USE_SRX
+  if (bgp->srx_proxyID == 0)
+  {
+    srx_set_proxyID(bgp, ntohl(bgp->router_id.s_addr));
+  }
+#endif /* USE_SRX */
   return 0;
 }
 
@@ -509,6 +600,360 @@ bgp_default_local_preference_unset (stru
   return 0;
 }
 
+#ifdef USE_SRX
+
+/**
+ * This function performs the call to connect to srx-server. It can be called
+ * from two function, (a) bgp_srx_set where the server data is set and a
+ * connection is requested or from
+ *
+ * @param bgp Pointer to the bgp instance
+ *
+ * @return 0 if connected, otherwise 1
+ */
+int srx_connect_proxy(struct bgp *bgp)
+{
+  int  clientFD  = -1;
+  bool connected = false;
+
+  // Continue only if this connect was called outside of the initial
+  // configuration. otherwise the g_rq is not initialized yet, if in
+  // configuration, set a flag to connect once g_rq is established.
+  if (g_rq != NULL)
+  {
+    // The last parameter (true) stands for external socket control
+    connected = connectToSRx (bgp->srxProxy, bgp->srx_host, bgp->srx_port,
+                              bgp->srx_handshakeTimeout, true);
+    if (connected)
+    {
+      g_rq->proxy = bgp->srxProxy;
+      clientFD = getInternalSocketFD(bgp->srxProxy, true);
+
+      g_rq->t_read = thread_add_read (bm->master, respawnReceivePacket,
+                                      g_rq, clientFD);
+      bgp->srx_proxyID = bgp->srxProxy->proxyID;
+      zlog_info ("Connect to SRx server %s:%d", bgp->srx_host, bgp->srx_port);
+
+      if ( CHECK_FLAG(bgp->srx_config, SRX_CONFIG_EVAL_DISTR))
+      {
+        zlog_info ("\033[92m""Enabled Distributed Evaluation on SRx server""\033[0m" );
+      }
+    }
+    else
+    {
+      zlog_err ("Could not connect to SRx server at %s:%d, check if server is "
+                "running", bgp->srx_host, bgp->srx_port);
+    }
+  }
+
+  return connected ? 0 : 1;
+}
+
+/**
+ * Store the SRx server settings for this BGP router. This method will
+ * connected to the given router only if so requested and not connected already.
+ *
+ * @param bgp The bgp router instance
+ * @param vty The vty instance
+ * @param host The host name or address of the SRx server
+ * @param port The port number of the SRx server
+ * @param connect indicates if a connection should be performed.
+ *
+ * @return either CMD_WARNING or CMD_SUCCESS
+ */
+int bgp_srx_set(struct bgp *bgp, struct vty *vty,
+                const char *host, int port, bool doConnect)
+{
+  int  prev_set, same_host = 0; //, same_port = 0;
+
+  prev_set = bgp_config_check (bgp, BGP_CONFIG_SRX);
+  zlog_debug(" bgp previous config_already_set checking %d \n", prev_set);
+
+  if (isConnected(bgp->srxProxy))
+  {
+    vty_out (vty, "%% Already connected to SRx-server. Disconnect first!%s",
+                  VTY_NEWLINE);
+    return CMD_WARNING;
+  }
+
+  if (prev_set)
+  {
+    same_host = (strcmp (bgp->srx_host, host) == 0);
+    //same_port = (bgp->srx_port == port);
+
+    if (!same_host)
+    {
+      XFREE (MTYPE_SRX_HOST, bgp->srx_host);
+    }
+  }
+
+  bgp_config_set (bgp, BGP_CONFIG_SRX);
+  if (!same_host)
+  {
+    bgp->srx_host = XSTRDUP (MTYPE_SRX_HOST, host);
+  }
+  bgp->srx_port = port;
+
+  if (bgp->srxProxy != NULL)
+  {
+    char proxyIDstr[20];
+    char pconfIDstr[20];
+    memset(proxyIDstr, '\0', 20);
+    memset(pconfIDstr, '\0', 20);
+    sprintf(proxyIDstr, "%u.%u.%u.%u",
+               (bgp->srxProxy->proxyID >> 24) & 0xFF,
+               (bgp->srxProxy->proxyID >> 16) & 0xFF,
+               (bgp->srxProxy->proxyID >>  8) & 0xFF,
+                bgp->srxProxy->proxyID & 0xFF);
+    sprintf(pconfIDstr, "%u.%u.%u.%u",
+               (bgp->srx_proxyID >> 24) & 0xFF,
+               (bgp->srx_proxyID >> 16) & 0xFF,
+               (bgp->srx_proxyID >>  8) & 0xFF,
+                bgp->srx_proxyID & 0xFF);
+
+    zlog_debug(" current srx_proxy_id: %s (%u) ", proxyIDstr,
+               bgp->srxProxy->proxyID);
+
+    zlog_debug(" Proxy instantiated with proxy id %s (%u) and configured "
+               "with proxy id %s (%u)\n",proxyIDstr, bgp->srxProxy->proxyID,
+               pconfIDstr, bgp->srx_proxyID);
+
+    // Only connect if requested.
+    if (doConnect)
+    {
+      // Code moved into _bgp_srx_connect as result of BZ301
+      if (srx_connect_proxy(bgp) == 1)
+      {
+        // it did not connect because we are still in configuration state and
+        // the necessary framework is not configured yet. It will be done then.
+        // See bgp_route.c::initUnSocket
+        flagDoConnectSrx = bgp;
+      }
+    }
+  }
+
+  return CMD_SUCCESS;
+}
+
+/**
+ * disconnect from srx server
+ *
+ * @param bgp the bgp struct
+ * @param server the server the bgp struct is connected to
+ *
+ * @return 0 successful, -1 unsuccessful
+ */
+int bgp_srx_unset (struct bgp *bgp)
+{
+  int retVal = 0;
+
+  if (bgp_config_check (bgp, BGP_CONFIG_SRX))
+  {
+    bgp_config_unset (bgp, BGP_CONFIG_SRX);
+    XFREE (MTYPE_SRX_HOST, bgp->srx_host);
+
+    if(g_rq->t_read)
+    {
+      zlog_debug ("%s thread cancel", __FUNCTION__);
+      thread_cancel(g_rq->t_read);
+    }
+
+    disconnectFromSRx (bgp->srxProxy, bgp->srx_keepWindow);
+  }
+  else
+  {
+    zlog_info("BGP session is not connected to an SRx server!");
+    retVal = -1;
+  }
+
+  return retVal;
+}
+
+/**
+ * Set or unset the srx result processing.
+ *
+ * @param bgp the bgo router instance.
+ * @param mode 0 == disable, otherwise the prefix-origin or BGPSEC processing,
+ * @return CMD_SUCCESS
+ */
+int bgp_srx_evaluation (struct bgp *bgp, int mode)
+{
+  switch (mode)
+  {
+    case 0:
+      srx_config_unset (bgp, SRX_CONFIG_EVAL_DISTR);
+      break;
+    case SRX_CONFIG_EVAL_DISTR:
+      srx_config_set   (bgp, SRX_CONFIG_EVAL_DISTR);
+      break;
+    case SRX_CONFIG_EVALUATE:
+    case SRX_CONFIG_EVAL_PATH: // We don't do path alone
+      srx_config_unset (bgp, SRX_CONFIG_EVAL_DISTR);
+      srx_config_set   (bgp, SRX_CONFIG_EVALUATE);
+      break;
+    case SRX_CONFIG_EVAL_ORIGIN:
+      srx_config_unset (bgp, SRX_CONFIG_EVAL_DISTR);
+      srx_config_set   (bgp, SRX_CONFIG_EVAL_ORIGIN);
+      break;
+    default:
+      zlog_err("Invalid srx evaluation flag %u passed, ignore it!", mode);
+      break;
+  }
+  return CMD_SUCCESS;
+}
+
+/**
+ * Enable or disable the srx validation result
+ *
+ * @param bgp The bgp router instance
+ * @param enable enable or disable the additional information output
+ * @return CMD_SUCCESS
+ */
+int bgp_srx_display (struct bgp *bgp, int enable)
+{
+  if (enable)
+  {
+    srx_config_set (bgp, SRX_CONFIG_DISPLAY_INFO);
+  }
+  else
+  {
+    srx_config_unset (bgp, SRX_CONFIG_DISPLAY_INFO);
+  }
+
+  return CMD_SUCCESS;
+}
+
+/**
+ * Set the default result for origin validation and path validation.
+ *
+ * @param bgp The bgp router instance
+ * @param type The type of result, origin validation or path validation
+ * @param def_value The default value or the validation.
+ * @return CMD_SUCCESS
+ */
+int bgp_srx_conf_default_result(struct bgp *bgp, int type, int def_value)
+{
+  switch (type)
+  {
+    case SRX_VTY_PARAM_ORIGIN_VALUE:
+      bgp->srx_default_roaVal = def_value;
+      break;
+    case SRX_VTY_PARAM_PATH_VALUE:
+      bgp->srx_default_bgpsecVal = def_value;
+      break;
+    default:
+      zlog_err("Invalid default validation result type [%d]!", type);
+  }
+  return CMD_SUCCESS;
+}
+
+/**
+ * Set the manipulation value for the local preference and enables the policy
+ * for the given validation result
+ *
+ * @param bgp the bgp router instance
+ * @param index the validation result (valid, notfound, invalid)
+ * @param relative is this value relative or absolute
+ * @param value the value itself. (negative = subtract, positive = add)
+ * @return CMD_SUCCESS
+ */
+int srx_val_local_preference_set (struct bgp *bgp, int index, int relative,
+                              uint32_t value)
+{
+  bgp->srx_val_local_pref[index].is_set = 1;
+  bgp->srx_val_local_pref[index].relative = relative;
+  bgp->srx_val_local_pref[index].value = value;
+  return CMD_SUCCESS;
+}
+
+/**
+ * Reset the local pref manipulation value and disables this policy for the
+ * given validation result.
+ *
+ * @param bgp the bgp router instance
+ * @param index the validation result (valid, notfound, invalid)
+ * @return CMD_SUCCESS
+ */
+int srx_val_local_preference_unset (struct bgp *bgp, int index)
+{
+  bgp->srx_val_local_pref[index].is_set = 0;
+  bgp->srx_val_local_pref[index].relative = 1;
+  bgp->srx_val_local_pref[index].value = 0;
+  return CMD_SUCCESS;
+}
+
+/**
+ * Set the given flag.
+ *
+ * @param bgp the bgp router instance
+ * @param policy the policy flag to be set
+ * @return CMD_SUCCESS
+ */
+int srx_val_policy_set (struct bgp *bgp, uint16_t policy)
+{
+  SET_FLAG (bgp->srx_val_policy, policy);
+  return CMD_SUCCESS;
+}
+
+/**
+ * Reset the give flag.
+ *
+ * @param bgp the bgp router instance.
+ * @param opt the flag to be set
+ * @return CMD_SUCCESS
+ */
+int srx_val_policy_unset (struct bgp *bgp, uint16_t policy)
+{
+  UNSET_FLAG (bgp->srx_val_policy, policy);
+  return CMD_SUCCESS;
+}
+
+/**
+ * Activate the extended community string for validation result transfer. This
+ * method allows to set the transfer not only for iBGP but also for eBGP
+ *
+ * @param bgp the bgp router instance
+ * @param subcode the subcode value used in the extended community string
+ * @param cmd The command include_ebgp, only_ibgp, or an empty string
+ * @return CMD_SUCCESS
+ */
+int srx_extcommunity_set (struct bgp *bgp, uint8_t subcode, const char* cmd)
+{
+  SET_FLAG(bgp->srx_ecommunity_flags, SRX_BGP_FLAG_ECOMMUNITY);
+
+  // Modify EBGP flag only if command is given!
+  if(strlen(cmd) > 0)
+  {
+    if (strncmp("inc", cmd, 3) == 0)
+    { // In case the command starts with inc then set the flag for include eBGP
+      SET_FLAG(bgp->srx_ecommunity_flags, SRX_BGP_FLAG_ECOMMUNITY_EBGP);
+    }
+    else
+    { // Otherwise remove the flag if set!!
+      UNSET_FLAG(bgp->srx_ecommunity_flags, SRX_BGP_FLAG_ECOMMUNITY_EBGP);
+    }
+  }
+  bgp->srx_ecommunity_subcode = subcode;
+
+  return CMD_SUCCESS;
+}
+
+/**
+ * Deactivate the extended community string.
+ *
+ * @param bgp the router instance
+ * @return CMD_SUCCESS
+ */
+int srx_extcommunity_unset (struct bgp *bgp)
+{
+  UNSET_FLAG(bgp->srx_ecommunity_flags, SRX_BGP_FLAG_ECOMMUNITY);
+  UNSET_FLAG(bgp->srx_ecommunity_flags, SRX_BGP_FLAG_ECOMMUNITY_EBGP);
+  bgp->srx_ecommunity_subcode = 0;
+  return CMD_SUCCESS;
+}
+
+#endif /* USE_SRX */
+
 /* If peer is RSERVER_CLIENT in at least one address family and is not member
     of a peer_group for that family, return 1.
     Used to check wether the peer is included in list bgp->rsclient. */
@@ -1929,6 +2374,250 @@ peer_group_unbind (struct bgp *bgp, stru
   return 0;
 }
 
+#ifdef USE_SRX
+
+static void srxLockUpdate(struct bgp_info* info)
+{
+  // TODO LOCK MUTEX OR WHATEVER
+}
+
+static void srxUnLockUpdate(struct bgp_info* info)
+{
+  // TODO UNLOCK MUTEX OR WHATEVER
+}
+
+/**
+ * This method receives communication inform of codes from the SRX API. These
+ * communications can be errors or other codes that are of importance for
+ * Quagga to know.
+ *
+ * @param mainCode the main code for this communication.
+ * @param subCodeThe sub code of the communication.
+ *
+ * @param userPtr an instance of the BGP thread.
+ */
+void handleSRxMessages(SRxProxyCommCode mainCode, int subCode, void* userPtr)
+{
+  //TODO:  update method threadControlCall to use subcodes...
+  threadControlCall((int)mainCode);
+}
+
+/**
+ * Called by proxy once notifications are received. Will either update the
+ * validation state or in case the update is not known, respond with a delete to
+ * the srx server.
+ */
+bool handleSRxValidationResult (SRxUpdateID updateID, uint32_t localID,
+                                ValidationResultType valType,
+                                uint8_t roaResult, uint8_t bgpsecResult,
+                                void* bgpRouter)
+{
+  struct bgp_info* info;
+  struct bgp*      bgp   = (struct bgp*)bgpRouter;
+
+  bool retVal = false;
+
+  if (localID != 0) // update & requestToken substitution
+  {
+    info = bgp_info_fetch(bgp->info_lid_hash, localID);
+    if (info)
+    {
+      // register again with new value(update id)
+      info->updateID = updateID;
+      bgp_info_register (bgp->info_uid_hash, info, updateID);
+      // unregister
+      bgp_info_unregister (bgp->info_lid_hash, localID);
+      info->localID  = 0;
+
+      // @TODO: We will get here the first time we hear back from srx-server.
+      // This is the moment where we will call the local validation. It allows
+      // us to have lazy evaluation. We need connectivity to srx-server for it
+      // to work though.
+      //
+      // Once the srx-server sends real bgpsec validation results, we have to
+      // find another place where to put it in if we want to continue local
+      // validation.
+      //
+      // Maybe local validation could be performed instead of the verify call
+      // in case no srx-server is available.
+
+      //------ To be deleted later on-----------
+      if ( !CHECK_FLAG(bgp->srx_config, SRX_CONFIG_EVAL_DISTR))
+      {
+      if (bgp->srxCAPI != NULL && info->attr->bgpsec_validationData != NULL)
+      {
+        // Now CAPI validation result and the SRx Validation result are different
+        // values. We need to adjust them.
+        int valResult = bgp->srxCAPI->validate(info->attr->bgpsec_validationData);
+        bgpsecResult = valResult == API_VALRESULT_VALID ? SRx_RESULT_VALID
+                                                        : SRx_RESULT_INVALID;
+
+        if (bgpsecResult == SRx_RESULT_INVALID)
+        {
+          if ((info->attr->bgpsec_validationData->status & API_STATUS_ERROR_MASK) > 0)
+          {
+            zlog_err("Update [0x%08X] validation returned invalid with an error: status=0x%X\n",
+                    updateID, info->attr->bgpsec_validationData->status);
+          }
+        }
+      }
+        valType |= VRT_BGPSEC;
+      }
+
+      bgp_info_set_validation_result (info, valType, roaResult, bgpsecResult);
+      retVal = true;
+    }
+  }
+  else // it is an update
+  {
+    // Retrieve the Update by using the update ID.
+    info = bgp_info_fetch(bgp->info_uid_hash, updateID);
+    if (info)
+    {
+      // Set the Update validation result values
+      bgp_info_set_validation_result (info, valType, roaResult, bgpsecResult);
+      retVal = true;
+    }
+  }
+
+  if (!retVal)
+  {
+    zlog_warn("update [0x%08X] is not known, send a delete to the server!",
+               updateID);
+    deleteUpdate(bgp->srxProxy, bgp->srx_keepWindow, updateID);
+  }
+
+
+  return retVal;
+}
+
+/* Called by proxy once notifications are received. */
+void handleSRxSignatures(SRxUpdateID updateID, BGPSecCallbackData* data,
+                                void* bgpRouter)
+{
+  // @NOTE: At this moment we will only sign within quagga and NOT using
+  //        srx-server for that. We might re-visit this decission at a later
+  //        point.
+  zlog_info ("*** Received SRx Signatures for update [0x%08X]! ***\n",
+             updateID);
+  // TODO: Add the signature to the update that was/will be send out.
+}
+
+/**
+ * Send a validation request for each update in the given table.
+ *
+ * @param bgp
+ * @param table
+ */
+static void _handleSRxSynchRequest_processTable(struct bgp* bgp,
+                                                struct bgp_table* table)
+{
+  struct bgp_info *binfo;
+  struct bgp_node *bnode;
+
+  SRxDefaultResult defResult;
+
+  /* Start processing of routes. */
+  for (bnode = bgp_table_top(table); bnode; bnode = bgp_route_next(bnode))
+  {
+    if (bnode->info != NULL)
+    {
+      binfo  = (struct bgp_info*)bnode->info;
+      srxLockUpdate(binfo);
+      defResult.resSourceROA    = SRxRS_ROUTER;
+      defResult.resSourceBGPSEC = SRxRS_ROUTER;
+      defResult.result.roaResult    = binfo->val_res_ROA;
+      defResult.result.bgpsecResult = binfo->val_res_BGPSEC;
+      verify_update (bgp, binfo, &defResult, false);
+      srxUnLockUpdate(binfo);
+    }
+  }
+}
+
+
+/**
+ * Called by proxy once a synchronization request is received. The request will
+ * only be served as long as SRx is connected to the router, regardless of
+ * the SRx evaluation setting.
+ *
+ * @param bgpRouter A pointer to the bgp router instance that received this
+ *        request
+ */
+void handleSRxSynchRequest(void* bgpRouter)
+{
+  zlog_info ("*** Received SRx Synchronization Request! ***\n");
+
+  struct bgp* bgp = (struct bgp*)bgpRouter;
+  if (bgp == NULL)
+  {
+    zlog_err("*** SRx did not provide configured BGP session for "
+             "synchronization request");
+    return;
+  }
+
+  _handleSRxSynchRequest_processTable(bgp, bgp->rib[AFI_IP][SAFI_MULTICAST]);
+  _handleSRxSynchRequest_processTable(bgp, bgp->rib[AFI_IP][SAFI_UNICAST]);
+}
+
+/**
+ * Is called by bgp_create and initialized the srx default settings in the
+ * bgp router.
+ *
+ * this method creates the info hash, the scxProxy, and the following settings:
+ * srx_proxyID, srx_keepWindow, srx_handshakeTimeout
+ * and the following policies:
+ * ignore-undefined
+ *
+ * @param bgp the bgp router instance.
+ */
+void srx_set_default(struct bgp *bgp)
+{
+  // TODO OB Update the default setting
+  if(!bgp->info_uid_hash)
+  {
+    bgp->info_uid_hash      = bgp_info_hash_init();
+    bgp->info_lid_hash      = bgp_info_hash_init();
+  }
+  srx_set_proxyID(bgp, ntohl(bgp->router_id.s_addr));
+  //bgp->srx_proxyID          = bgp->router_id.s_addr;
+  bgp->srx_keepWindow       = SRX_KEEP_WINDOW;
+  bgp->srx_handshakeTimeout = SRX_HANDHAKE_TIMEOUT;
+
+  // Can be turned off using config file
+  bgp->srx_val_policy        = SRX_VAL_POLICY_IGNORE_UNDEFINED;
+
+  // Turn on only prefix origin validation and srx info display. This default
+  // setting might be changed into both ROA as well as path
+  bgp->srx_config            =   SRX_CONFIG_EVAL_ORIGIN
+                               | SRX_CONFIG_DISPLAY_INFO;
+
+  // Set the default result values.
+  bgp->srx_default_roaVal    = SRx_RESULT_UNDEFINED;
+  bgp->srx_default_bgpsecVal = SRx_RESULT_UNDEFINED;
+
+
+  bgp->srxProxy = createSRxProxy(handleSRxValidationResult, handleSRxSignatures,
+                                 handleSRxSynchRequest, handleSRxMessages,
+                                 bgp->srx_proxyID, bgp->as, bgp);
+
+  // @TODO: REvisit this portion.
+  // The following line should be replaced by the commented code. The CAPI is
+  // tightly connected to this bgp instance.
+  bgp->srxCAPI  = getSrxCAPI();
+//  bgp->scaAPI         = XMALLOC(MTYPE_SRX_SCA_API, sizeof(SRxCryptoAPI));
+//  memset(bgp->scaAPI, 0, sizeof(SRxCryptoAPI));
+//  sca_status_t sca_status = API_STATUS_OK;
+//  if(srxCryptoInit(bgp->scaAPI, &sca_status) == API_FAILURE);
+//  {
+//    zlog_err("[BGPSEC] SRxCryptoAPI not initialized (0x%X)!\n", sca_status);
+//    XFREE(MTYPE_SRX_SCA_API, bgp->scaAPI);
+//    bgp->scaAPI = NULL;
+//  }
+
+  memset(bgp->srx_bgpsec_key, 0, sizeof (BGPSecKey));
+}
+#endif /* USE_SRX */
+
 /* BGP instance creation by `router bgp' commands. */
 static struct bgp *
 bgp_create (as_t *as, const char *name)
@@ -1974,6 +2663,10 @@ bgp_create (as_t *as, const char *name)
   if (name)
     bgp->name = strdup (name);
 
+#ifdef USE_SRX
+  srx_set_default(bgp);
+#endif /* USE_SRX */
+
   return bgp;
 }
 
@@ -2163,6 +2856,25 @@ bgp_free (struct bgp *bgp)
 	if (bgp->rib[afi][safi])
           bgp_table_finish (&bgp->rib[afi][safi]);
       }
+
+#ifdef USE_SRX
+  bgp_info_hash_finish (&bgp->info_uid_hash);
+  bgp_info_hash_finish (&bgp->info_lid_hash);
+  if (bgp->srxProxy)
+  {
+    releaseSRxProxy (bgp->srxProxy);
+  }
+  int kIdx = 0;
+  for (; kIdx < SRX_MAX_PRIVKEYS; kIdx++)
+  {
+    if (bgp->srx_bgpsec_key[kIdx].keyLength > 0)
+    {
+      free(bgp->srx_bgpsec_key[kIdx].keyData);
+    }
+  }
+  memset(bgp->srx_bgpsec_key, 0, sizeof(BGPSecKey) * SRX_MAX_PRIVKEYS);
+#endif /* USE_SRX */
+
   XFREE (MTYPE_BGP, bgp);
 }
 
@@ -2317,6 +3029,17 @@ static const struct peer_flag_action pee
     { PEER_FLAG_STRICT_CAP_MATCH,         0, peer_change_none },
     { PEER_FLAG_DYNAMIC_CAPABILITY,       0, peer_change_reset },
     { PEER_FLAG_DISABLE_CONNECTED_CHECK,  0, peer_change_reset },
+#ifdef USE_SRX
+// @TODO: I think this has to be peer_change_reset. For now I will keep it
+//        but definetely need to get back and verify
+    { PEER_FLAG_BGPSEC_CAPABILITY_SEND,   0, peer_change_none },
+    { PEER_FLAG_BGPSEC_CAPABILITY_RECV,   0, peer_change_none },
+    { PEER_FLAG_BGPSEC_MPE_IPV4,          0, peer_change_none },
+    { PEER_FLAG_BGPSEC_MIGRATE,           0, peer_change_none },
+    { PEER_FLAG_BGPSEC_ROUTE_SERVER,      0, peer_change_none },
+    { PEER_FLAG_EXTENDED_MESSAGE_SUPPORT, 0, peer_change_none },
+    { PEER_FLAG_EXTENDED_MESSAGE_LIBERAL, 0, peer_change_none },
+#endif
     { 0, 0, 0 }
   };
 
@@ -4900,6 +5623,29 @@ bgp_config_write_peer (struct vty *vty, 
 	    ! CHECK_FLAG (g_peer->flags, PEER_FLAG_DONT_CAPABILITY))
 	vty_out (vty, " neighbor %s dont-capability-negotiate%s", addr,
 		 VTY_NEWLINE);
+#ifdef USE_SRX
+      /* bgpsec capability */
+      if (CHECK_FLAG (peer->flags, PEER_FLAG_BGPSEC_CAPABILITY_SEND) &&
+        CHECK_FLAG (peer->flags, PEER_FLAG_BGPSEC_CAPABILITY_RECV))
+        vty_out (vty, " neighbor %s bgpsec both%s", addr, VTY_NEWLINE);
+      else if (CHECK_FLAG (peer->flags, PEER_FLAG_BGPSEC_CAPABILITY_SEND))
+        vty_out (vty, " neighbor %s bgpsec snd %s", addr, VTY_NEWLINE);
+      else if (CHECK_FLAG (peer->flags, PEER_FLAG_BGPSEC_CAPABILITY_RECV))
+	      vty_out (vty, " neighbor %s bgpsec rec %s", addr, VTY_NEWLINE);
+
+      /* Extended message capability liberal processing*/
+      if (CHECK_FLAG (peer->flags, PEER_FLAG_EXTENDED_MESSAGE_LIBERAL))
+      {
+        vty_out (vty, " neighbor %s capability extended liberal%s", addr,
+                 VTY_NEWLINE);
+      } 
+      else if (CHECK_FLAG (peer->flags, PEER_FLAG_EXTENDED_MESSAGE_SUPPORT))
+      { /* Extended message capability*/
+        vty_out (vty, " neighbor %s capability extended%s", addr,
+                 VTY_NEWLINE);
+      }
+
+#endif /* USE_SRX */
 
       /* override capability negotiation. */
       if (CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))
@@ -5164,6 +5910,177 @@ bgp_config_write_family (struct vty *vty
   return write;
 }
 
+#ifdef USE_SRX
+static int srx_config_write_configuration (struct vty *vty, struct bgp *bgp)
+{
+  static const char *INDEX_STR[3] =
+  {
+    "valid",
+    "notfound",
+    "invalid"
+  };
+
+  int noElements = 3; // Number of elements in the above INDEX_STR
+  int index;
+
+  // SRx proxy values
+  vty_out (vty, "%s ! SRx Basic Configuration Settings%s", VTY_NEWLINE, VTY_NEWLINE);
+  vty_out (vty, " srx set-proxy-id %u.%u.%u.%u%s",
+           (bgp->srx_proxyID >> 24) & 0xFF, (bgp->srx_proxyID >> 16) & 0xFF,
+           (bgp->srx_proxyID >> 8) & 0xFF, bgp->srx_proxyID & 0xFF,
+           VTY_NEWLINE);
+
+  // SRx server address
+  if (bgp->srx_host != NULL)
+  {
+    vty_out (vty, " %s %s %d%s", SRX_VTY_CMD_SET_SERVER_SHORT,
+                  bgp->srx_host, bgp->srx_port, VTY_NEWLINE);
+    // Connect is done at the end!!!
+  }
+
+  // KEEP WINDOW
+  vty_out (vty, " %s %d%s", SRX_VTY_CMD_KEEPWINDOW_SHORT,
+                bgp->srx_keepWindow,  VTY_NEWLINE);
+
+  // EVALUATION MODE
+  if (srx_config_check(bgp, SRX_CONFIG_EVAL_PATH))
+  { // if this is set the ROA flag is set too -> BGPSEC
+    if (srx_config_check(bgp, SRX_CONFIG_EVAL_DISTR))
+    {
+      vty_out (vty, " srx evaluation %s distributed%s", SRX_VTY_EVAL_BGPSEC, 
+                    VTY_NEWLINE);
+    }
+    else
+    {
+      vty_out (vty, " srx evaluation %s%s", SRX_VTY_EVAL_BGPSEC, VTY_NEWLINE);
+    }
+  }
+  else if (srx_config_check(bgp, SRX_CONFIG_EVAL_ORIGIN))
+  {
+    vty_out (vty, " srx evaluation %s%s", SRX_VTY_EVAL_ORIGIN_ONLY,
+                                          VTY_NEWLINE);
+  }
+  else
+  {
+    vty_out (vty, " no srx evaluation%s", VTY_NEWLINE);
+  }
+
+  if (CHECK_FLAG(bgp->srx_ecommunity_flags, SRX_BGP_FLAG_ECOMMUNITY))
+  {
+    if (CHECK_FLAG(bgp->srx_ecommunity_flags, SRX_BGP_FLAG_ECOMMUNITY_EBGP))
+    {
+      vty_out (vty, " srx extcommunity %d include_ebgp%s",
+                      bgp->srx_ecommunity_subcode, VTY_NEWLINE);
+    }
+    else
+    {
+      vty_out (vty, " srx extcommunity %d only_ibgp%s",
+                      bgp->srx_ecommunity_subcode, VTY_NEWLINE);
+    }
+  }
+  else
+  {
+      vty_out (vty, " no srx extcommunity%s", VTY_NEWLINE);
+  }
+
+  // ENABLE / DISABLE DISPLAY
+  vty_out (vty, " %s%s%s",
+           srx_config_check(bgp, SRX_CONFIG_DISPLAY_INFO) ? "" : "no ",
+           SRX_VTY_CMD_DISPLAY, VTY_NEWLINE);
+
+  // DEFAULT EVALUATION VALUES
+  vty_out (vty, "%s ! SRx Evaluation Configuration Settings%s", VTY_NEWLINE, VTY_NEWLINE);
+
+  // The following 6 vty_out statements include \r because the constant value
+  // provides already the \n
+  // srx set-origin-value
+  switch (bgp->srx_default_roaVal)
+  {
+    case SRx_RESULT_VALID:
+      vty_out (vty, " %s", SRX_VTY_CMD_CONF_DEF_ROA_RES_VALID );
+      break;
+    case SRx_RESULT_NOTFOUND:
+      vty_out (vty, " %s", SRX_VTY_CMD_CONF_DEF_ROA_RES_NOTFOUND );
+      break;
+    case SRx_RESULT_INVALID:
+      vty_out (vty, " %s", SRX_VTY_CMD_CONF_DEF_ROA_RES_INVALID );
+      break;
+    case SRx_RESULT_UNDEFINED:
+    default:
+      vty_out (vty, " %s", SRX_VTY_CMD_CONF_DEF_ROA_RES_UNDEFINED );
+  }
+  // don't use VTY_NEWLINE because a \n is already added. \r might be missing.
+  vty_out (vty, "%s", (vty->type == VTY_TERM) ? "\r" : "");
+
+  // srx set-path-value
+  switch (bgp->srx_default_bgpsecVal)
+  {
+    case SRx_RESULT_VALID:
+      vty_out (vty, " %s", SRX_VTY_CMD_CONF_DEF_PATH_RES_VALID );
+      break;
+    case SRx_RESULT_INVALID:
+      vty_out (vty, " %s", SRX_VTY_CMD_CONF_DEF_PATH_RES_INVALID );
+      break;
+    case SRx_RESULT_UNDEFINED:
+    default:
+      vty_out (vty, " %s", SRX_VTY_CMD_CONF_DEF_PATH_RES_UNDEFINED );
+      break;
+  }
+  // don't use VTY_NEWLINE because a \n is already added. \r might be missing.
+  vty_out (vty, "%s", (vty->type == VTY_TERM) ? "\r" : "");
+
+  // VALIDATION POLICY LOCAL PREF
+  for (index = 0; index < noElements; index++)
+  {
+    if (bgp->srx_val_local_pref[index].is_set)
+    {
+    	vty_out (vty, " %s %s %u", SRX_VTY_CMD_POL_LOCP, INDEX_STR[index],
+                    bgp->srx_val_local_pref[index].value);
+
+      if (bgp->srx_val_local_pref[index].relative)
+      {
+        vty_out (vty, " %s", (bgp->srx_val_local_pref[index].relative == 1)
+                             ? "add" : "subtract");
+      }
+
+      vty_out (vty, "%s", VTY_NEWLINE);
+    }
+  }
+
+  // VALIDATION POLICY PREFER VALID
+  if (CHECK_FLAG (bgp->srx_val_policy, SRX_VAL_POLICY_PREFER_VALID))
+  {
+    vty_out (vty, " %s%s", SRX_VTY_CMD_POL_PREFV, VTY_NEWLINE);
+  }
+
+  // VALIDATION POLICY IGNORE ...
+  if (CHECK_FLAG (bgp->srx_val_policy, SRX_VAL_POLICY_IGNORE_NOTFOUND))
+  {
+    if (srx_config_check(bgp, SRX_CONFIG_EVAL_PATH)) // BGPSec Processing
+    {
+      vty_out (vty, " ! The following policy only applies to \""
+                    " srx evaluation %s\" %s!",
+               SRX_VTY_EVAL_ORIGIN_ONLY,VTY_NEWLINE);
+    }
+    vty_out (vty, " %s%s", SRX_VTY_CMD_POL_IGNORE_NOTFOUND, VTY_NEWLINE);
+  }
+  if (CHECK_FLAG (bgp->srx_val_policy, SRX_VAL_POLICY_IGNORE_INVALID))
+  {
+    vty_out (vty, " %s%s", SRX_VTY_CMD_POL_IGNORE_INVALID, VTY_NEWLINE);
+  }
+
+  // CONNECT TO SRX - The server settings are set above
+  if (bgp_config_check(bgp, BGP_CONFIG_SRX))
+  {
+    // CONNECT TO SERVER
+    vty_out (vty, "%s ! Connect to SRx-server%s", VTY_NEWLINE, VTY_NEWLINE);
+    vty_out (vty, " %s%s", SRX_VTY_CMD_CONNECT_SHORT, VTY_NEWLINE);
+  }
+
+  return 0;
+}
+#endif /* USE_SRX */
+
 int
 bgp_config_write (struct vty *vty)
 {
@@ -5216,6 +6133,31 @@ bgp_config_write (struct vty *vty)
       if (CHECK_FLAG (bgp->config, BGP_CONFIG_ROUTER_ID))
 	vty_out (vty, " bgp router-id %s%s", inet_ntoa (bgp->router_id), 
 		 VTY_NEWLINE);
+#ifdef USE_SRX
+      /* bgpsec ski value */
+      // Now cycle through the private keys
+      int kIdx = 0;
+      int bIdx = 0;
+      for (; kIdx < SRX_MAX_PRIVKEYS; kIdx++)
+      {
+        char skiStr[SKI_HEX_LENGTH+1];
+        char* cPtr = skiStr;
+        memset(skiStr, 0, SKI_HEX_LENGTH+1);
+        for (bIdx = 0; bIdx < SKI_LENGTH; bIdx++)
+        {
+          cPtr += sprintf(cPtr, "%02X", bgp->srx_bgpsec_key[kIdx].ski[bIdx]);
+        }
+        if (kIdx == 0)
+        {
+          vty_out (vty, "! The following form is deprecated.%s", VTY_NEWLINE);
+          vty_out (vty, "! bgpsec ski %s%s", skiStr, VTY_NEWLINE);
+        }
+        // BZ1055 fixed syntax of command. ...ski1 to ...ski 1
+        vty_out (vty, " srx bgpsec ski %u %s%s", kIdx, skiStr, VTY_NEWLINE);
+      }
+      vty_out (vty, " srx bgpsec active-ski %u%s", bgp->srx_bgpsec_active_key,
+               VTY_NEWLINE);
+#endif /* USE_SRX */
 
       /* BGP log-neighbor-changes. */
       if (bgp_flag_check (bgp, BGP_FLAG_LOG_NEIGHBOR_CHANGES))
@@ -5353,6 +6295,11 @@ bgp_config_write (struct vty *vty)
       /* IPv6 multicast configuration.  */
       write += bgp_config_write_family (vty, bgp, AFI_IP6, SAFI_MULTICAST);
 
+      /* SRx Settings */
+      #ifdef USE_SRX
+      srx_config_write_configuration (vty, bgp);
+      #endif /* USE_SRX */
+
       write++;
     }
   return write;
@@ -5390,6 +6337,9 @@ bgp_init (void)
   bgp_address_init ();
   bgp_scan_init ();
   bgp_mplsvpn_init ();
+#ifdef USE_SRX
+  bgp_all_info_hashes_init ();
+#endif /* USE_SRX */
 
   /* Access list initialize. */
   access_list_init ();
--- ./bgpd/bgp_main.c	2013-01-26 21:25:34.000000000 -0500
+++ ./bgpd/bgp_main.c	2017-06-26 15:53:49.000000000 -0400
@@ -456,7 +456,11 @@ main (int argc, char **argv)
   vty_serv_sock (vty_addr, vty_port, BGP_VTYSH_PATH);
 
   /* Print banner. */
+#ifdef USE_SRX
+  zlog_notice ("BGPd (+SRx) %s starting: vty@%d, bgp@%s:%d", QUAGGA_VERSION,
+#else /* USE_SRX */
   zlog_notice ("BGPd %s starting: vty@%d, bgp@%s:%d", QUAGGA_VERSION,
+#endif /* USE_SRX */
 	       vty_port, 
 	       (bm->address ? bm->address : "<all>"),
 	       bm->port);
--- ./bgpd/bgp_routemap.c	2013-01-26 21:25:34.000000000 -0500
+++ ./bgpd/bgp_routemap.c	2017-06-26 15:53:49.000000000 -0400
@@ -1660,6 +1660,89 @@ struct route_map_rule_cmd route_set_ecom
   route_set_ecommunity_soo_free,
 };
 
+#ifdef USE_SRX
+/* `set extcommunity opaque COMMUNITY for BGPSEC ' */
+
+/* For community set mechanism. */
+static route_map_result_t
+route_set_ecommunity_bgpsec (void *rule, struct prefix *prefix,
+                            route_map_object_t type, void *object)
+{
+  struct ecommunity *ecom;
+  struct ecommunity *new_ecom;
+  struct ecommunity *old_ecom;
+  struct bgp_info *bgp_info;
+
+  if (type == RMAP_BGP)
+  {
+    ecom = rule;
+    bgp_info = object;
+
+    if (! ecom)
+      return RMAP_OKAY;
+
+    /* We assume additive for Extended Community. */
+    old_ecom = (bgp_attr_extra_get (bgp_info->attr))->ecommunity;
+
+    if (old_ecom)
+      new_ecom = ecommunity_merge (ecommunity_dup (old_ecom), ecom);
+    else
+      new_ecom = ecommunity_dup (ecom);
+
+    /* TODO: modify ecomm value according to bgp_info */
+    zlog_debug(" bgp_info->val_res_ROA:%d ", bgp_info->val_res_ROA);
+    zlog_debug(" ecom_value: %08x ", *new_ecom->val);
+
+    bgp_info->attr->extra->ecommunity = ecommunity_intern (new_ecom);
+
+    if (old_ecom)
+      ecommunity_unintern (&old_ecom);
+
+    bgp_info->attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES);
+    zlog_debug(" interned ecom_addr:%p ", bgp_info->attr->extra->ecommunity);
+    zlog_debug(" flag:%08x ", bgp_info->attr->flag);
+
+  }
+
+  return RMAP_OKAY;
+}
+
+/* Compile function for set community. */
+static void *
+route_set_ecommunity_bgpsec_compile (const char *arg)
+{
+  struct ecommunity *ecom;
+  unsigned int uiValid;
+
+  uiValid = atoi(arg);
+
+  if (uiValid < 0 || uiValid > ECOMMUNITY_BGPSEC_INVALID)
+    return NULL;
+
+  ecom = ecommunity_bgpsec_str2com (ECOMMUNITY_BGPSEC_SUB, uiValid);
+  if (! ecom)
+    return NULL;
+  return ecommunity_intern (ecom);
+}
+
+/* Free function for set community. */
+static void
+route_set_ecommunity_bgpsec_free (void *rule)
+{
+  struct ecommunity *ecom = rule;
+  ecommunity_unintern (&ecom);
+}
+
+/* Set community rule structure. */
+struct route_map_rule_cmd route_set_ecommunity_bgpsec_cmd =
+{
+  "extcommunity bgpsec",
+  route_set_ecommunity_bgpsec,
+  route_set_ecommunity_bgpsec_compile,
+  route_set_ecommunity_bgpsec_free,
+};
+#endif
+
 /* `set origin ORIGIN' */
 
 /* For origin set. */
@@ -3422,6 +3505,37 @@ ALIAS (no_set_ecommunity_soo,
        "Site-of-Origin extended community\n"
        "VPN extended community\n")
 
+#ifdef USE_SRX
+DEFUN (set_ecommunity_bgpsec,
+       set_ecommunity_bgpsec_cmd,
+       "set extcommunity bgpsec ValidationState",
+       SET_STR
+       "BGP extended community attribute\n"
+       "BGPSEC extended community\n"
+       "validation status value\n")
+{
+  int ret;
+  char *str;
+
+  str = argv_concat (argv, argc, 0);
+  ret = bgp_route_set_add (vty, vty->index, "extcommunity bgpsec", str);
+  XFREE (MTYPE_TMP, str);
+
+  return ret;
+}
+
+DEFUN (no_set_ecommunity_bgpsec,
+       no_set_ecommunity_bgpsec_cmd,
+       "no set extcommunity bgpsec",
+       NO_STR
+       SET_STR
+       "BGP extended community attribute\n"
+       "BGPSEC extended community\n")
+{
+  return bgp_route_set_delete (vty, vty->index, "extcommunity bgpsec", NULL);
+}
+#endif
+
 DEFUN (set_origin,
        set_origin_cmd,
        "set origin (egp|igp|incomplete)",
@@ -3872,6 +3986,9 @@ bgp_route_map_init (void)
   route_map_install_set (&route_set_originator_id_cmd);
   route_map_install_set (&route_set_ecommunity_rt_cmd);
   route_map_install_set (&route_set_ecommunity_soo_cmd);
+#ifdef USE_SRX
+  route_map_install_set (&route_set_ecommunity_bgpsec_cmd);
+#endif
 
   install_element (RMAP_NODE, &match_peer_cmd);
   install_element (RMAP_NODE, &match_peer_local_cmd);
@@ -3959,6 +4076,10 @@ bgp_route_map_init (void)
   install_element (RMAP_NODE, &no_set_ecommunity_rt_val_cmd);
   install_element (RMAP_NODE, &set_ecommunity_soo_cmd);
   install_element (RMAP_NODE, &no_set_ecommunity_soo_cmd);
+#ifdef USE_SRX
+  install_element (RMAP_NODE, &set_ecommunity_bgpsec_cmd);
+  install_element (RMAP_NODE, &no_set_ecommunity_bgpsec_cmd);
+#endif
   install_element (RMAP_NODE, &no_set_ecommunity_soo_val_cmd);
   install_element (RMAP_NODE, &set_vpnv4_nexthop_cmd);
   install_element (RMAP_NODE, &no_set_vpnv4_nexthop_cmd);
--- ./bgpd/bgp_route.h	2013-01-26 21:25:34.000000000 -0500
+++ ./bgpd/bgp_route.h	2017-06-26 15:53:49.000000000 -0400
@@ -22,6 +22,10 @@ Software Foundation, Inc., 59 Temple Pla
 #define _QUAGGA_BGP_ROUTE_H
 
 #include "bgp_table.h"
+#ifdef USE_SRX
+#include "bgp_info_hash.h"
+#include <srx/srx_api.h>
+#endif /* USE_SRX */
 
 /* Ancillary information to struct bgp_info, 
  * used for uncommonly used data (aggregation, MPLS, etc.)
@@ -82,6 +86,9 @@ struct bgp_info
 #define BGP_INFO_COUNTED	(1 << 10)
 #define BGP_INFO_MULTIPATH      (1 << 11)
 #define BGP_INFO_MULTIPATH_CHG  (1 << 12)
+#ifdef USE_SRX
+#define BGP_INFO_IGNORE         (1 << 13)
+#endif /* USE_SRX */
 
   /* BGP route type.  This can be static, RIP, OSPF, BGP etc.  */
   u_char type;
@@ -93,6 +100,16 @@ struct bgp_info
 #define BGP_ROUTE_STATIC       1
 #define BGP_ROUTE_AGGREGATE    2
 #define BGP_ROUTE_REDISTRIBUTE 3 
+
+#ifdef USE_SRX
+  struct bgp_node        *node;
+  //The info hash that holds the update.
+  struct bgp_info_hash   *info_hash;
+  SRxUpdateID            updateID;
+  uint32_t               localID;
+  SRxValidationResultVal val_res_ROA;
+  SRxValidationResultVal val_res_BGPSEC;
+#endif /* USE_SRX */
 };
 
 /* BGP static route configuration. */
@@ -124,9 +141,41 @@ struct bgp_static
   u_char tag[3];
 };
 
+#ifdef USE_SRX
+
+struct SRxThread
+{
+    int sock;
+    struct thread *t_read;
+    void* clconnectionHandler;
+    int clientFD;
+    int prevClientFD;
+    void* proxy;
+};
+
+// Global variable used to manage the SRx proxy socket - initialized in
+// bgp_route.c::initUnSocket and also modified in bgpd.c::srx_connect(...)
+struct SRxThread *g_rq;
+// helper to allow connection command to be set during configuration. This
+// variable is either NULL or the bgp instance. It only will be set to the
+// bgp instance when in configuration mode, not when configuration will be
+// altered from console. The only methods that alter this variable are
+// bgpd.c::bgp_srx_set and bgp_route.c::initUnSocket. The later on is the only
+// function reading this value.sfinitUnSocket
+void* flagDoConnectSrx;
+
+/* Flags which indicate a route is unusable in some form */
+#define BGP_INFO_UNUSEABLE \
+  (BGP_INFO_HISTORY|BGP_INFO_DAMPED|BGP_INFO_REMOVED|BGP_INFO_IGNORE)
+
+#else /* USE_SRX */
+
 /* Flags which indicate a route is unuseable in some form */
 #define BGP_INFO_UNUSEABLE \
   (BGP_INFO_HISTORY|BGP_INFO_DAMPED|BGP_INFO_REMOVED)
+
+#endif /* USE_SRX */
+
 /* Macro to check BGP information is alive or not.  Sadly,
  * not equivalent to just checking previous, because of the
  * sense of the additional VALID flag.
@@ -192,6 +241,26 @@ extern void bgp_info_delete (struct bgp_
 extern struct bgp_info_extra *bgp_info_extra_get (struct bgp_info *);
 extern void bgp_info_set_flag (struct bgp_node *, struct bgp_info *, u_int32_t);
 extern void bgp_info_unset_flag (struct bgp_node *, struct bgp_info *, u_int32_t);
+#ifdef USE_SRX
+extern int  bgp_info_set_ignore_flag(struct bgp_info *);
+extern void srx_bgp_requeue_update(struct bgp_info *);
+extern void srx_bgp_requeue_all(struct bgp *);
+extern void bgp_info_set_validation_result (struct bgp_info *,
+                                       ValidationResultType resType,
+                                       uint8_t roaResult, uint8_t bgpsecResult);
+extern void verify_update (struct bgp *bgp, struct bgp_info *info,
+                           SRxDefaultResult* defResult, bool doRegisterLocalID);
+extern int  srx_calc_validation_state(struct bgp *, struct bgp_info *);
+struct SRxThread* srx_thread_arg_new(void);
+int checkClientConnection(struct thread *t);
+int initUnSocket(struct thread *t);
+int checkSendQueue(struct thread *t);
+void threadControlCall(int type);
+extern void srx_set_default(struct bgp *bgp);
+int checkEcomSRxValid(struct attr* attr);
+uint32_t getNextLocalID(void);
+
+#endif /* USE_SRX */
 
 extern int bgp_nlri_sanity_check (struct peer *, int, u_char *, bgp_size_t);
 extern int bgp_nlri_parse (struct peer *, struct attr *, struct bgp_nlri *);
--- ./bgpd/bgp_attr.c	2013-02-01 11:55:27.000000000 -0500
+++ ./bgpd/bgp_attr.c	2017-06-26 15:53:49.000000000 -0400
@@ -38,6 +38,10 @@ Software Foundation, Inc., 59 Temple Pla
 #include "bgpd/bgp_debug.h"
 #include "bgpd/bgp_packet.h"
 #include "bgpd/bgp_ecommunity.h"
+//#ifdef USE_SRX
+#include "bgpd/bgp_validate.h"
+#include <srx/srxcryptoapi.h>
+//#endif
 
 /* Attribute strings for logging. */
 static const struct message attr_str [] = 
@@ -52,7 +56,11 @@ static const struct message attr_str [] 
   { BGP_ATTR_COMMUNITIES,      "COMMUNITY" }, 
   { BGP_ATTR_ORIGINATOR_ID,    "ORIGINATOR_ID" },
   { BGP_ATTR_CLUSTER_LIST,     "CLUSTER_LIST" }, 
+#ifdef USE_SRX
+  { BGP_ATTR_BGPSEC,           "BGPSEC"},
+#else
   { BGP_ATTR_DPA,              "DPA" },
+#endif
   { BGP_ATTR_ADVERTISER,       "ADVERTISER"} ,
   { BGP_ATTR_RCID_PATH,        "RCID_PATH" },
   { BGP_ATTR_MP_REACH_NLRI,    "MP_REACH_NLRI" },
@@ -321,6 +329,8 @@ bgp_attr_dup (struct attr *new, struct a
   struct attr_extra *extra = new->extra;
 
   *new = *orig;
+
+
   /* if caller provided attr_extra space, use it in any case.
    *
    * This is neccesary even if orig->extra equals NULL, because otherwise
@@ -402,6 +412,10 @@ attrhash_key_make (void *p)
 #endif /* HAVE_IPV6 */
     }
 
+#ifdef USE_SRX
+  MIX(attr->bgpsecPathAttr);
+#endif /* USE_SRX */
+
   return key;
 }
 
@@ -417,6 +431,9 @@ attrhash_cmp (const void *p1, const void
       && attr1->aspath == attr2->aspath
       && attr1->community == attr2->community
       && attr1->med == attr2->med
+#ifdef USE_SRX
+      && (bgpsec_path_attr_cmp (attr1->bgpsecPathAttr, attr2->bgpsecPathAttr))
+#endif
       && attr1->local_pref == attr2->local_pref)
     {
       const struct attr_extra *ae1 = attr1->extra;
@@ -664,6 +681,7 @@ bgp_attr_unintern_sub (struct attr *attr
       if (attr->extra->transit)
         transit_unintern (attr->extra->transit);
     }
+
 }
 
 /* Free bgp attribute and aspath. */
@@ -1724,6 +1742,251 @@ bgp_attr_unknown (struct bgp_attr_parser
   return BGP_ATTR_PARSE_PROCEED;
 }
 
+#ifdef USE_SRX
+
+/**
+ * This function generates the quagga internal as path attribute out of the
+ * given BgpsecPathAttr structure.
+ *
+ * @param attr the attribute.
+ * @param peer the peer for this attribute.
+
+ * @return the aspath or NULL
+ */
+static struct aspath * srx_convert_to_aspath(struct attr* attr, struct peer* peer)
+{
+  // @NOTE: The conversion can be easily done using the wired bgpsec
+  // path attribute. But it works, that's what counts for now.
+
+  // @TODO: Somehow I would like to use BgpsecPathAttr as parameter but the
+  // compiler complains it can't find it even though it is in one of the include
+  // files. There might be some circular dependencies in the includes that is
+  // playing a trick here. For now I will use the attr structure but hopefully
+  // this can be resolved soon.
+
+  // This code was initially part of bgp_attr_bgpsec and out-sourced here
+  // for clarity and re-usability.
+  struct aspath* retVal = NULL;
+
+  struct PathSegment *ps = attr->bgpsecPathAttr->pathSegments;
+  struct PathSegment *tmpPs = ps;
+  size_t pcntTot = 0, pcnt=0;
+
+  /* calcuation of total pCount and aspath */
+  while(tmpPs)
+  {
+    pcntTot += tmpPs->pCount;
+    tmpPs = tmpPs->next;
+  }
+
+  // *4(AS octet length), +2(attr type 1 octet & attr length 1 octet)
+  size_t streamLen = MAX( ((attr->bgpsecPathAttr->securePathLen -2) /6)*4 +2, \
+                            pcntTot *4 +2);
+  struct stream *tmpStream = stream_new(streamLen);
+  u_short iter = (streamLen -2) /4;
+
+  stream_putc(tmpStream, BGP_ATTR_AS_PATH); // type
+  stream_putc(tmpStream, iter); // length
+
+  while(ps && iter--)
+  {
+    pcnt = ps->pCount;
+    while(pcnt--)
+    {
+      stream_putl(tmpStream, ps->as);
+    }
+    ps = ps->next;
+  }
+
+  if (BGP_DEBUG(as4, AS4_SEGMENT))
+  {
+    zlog_debug("[AS4SEG] dump the maden stream for aspath parse ");
+    unsigned int i;
+    for(i=0; i< streamLen; i++)
+    {
+      printf("%02x ", tmpStream->data[i]);
+      if( (i+1) %16==0)  printf("\n");
+    }
+    printf(" -- from [%s] \n", __FUNCTION__);
+  }
+
+  /* call aspath_parse() here with the manipulated parameters */
+  retVal = aspath_parse (tmpStream, streamLen,
+                         CHECK_FLAG (peer->cap, PEER_CAP_AS4_RCV));
+
+  stream_free(tmpStream);
+
+  return retVal;
+}
+
+/**
+ * Create an instance of the SC_Prefix or NULL if incomplete
+ * @param mp_update The prefix - If NULL or incomplete no prefix will be
+ *                  generated.
+ * @return Teh prefix or NULL if incomplete.
+ */
+static SCA_Prefix* bgpsec_create_valdata_nlri(struct bgp_nlri* mp_update)
+{
+  SCA_Prefix* scaPrefix = NULL;
+  if (mp_update && mp_update->nlri)
+  {
+    scaPrefix = malloc(sizeof(SCA_Prefix));
+    memset(scaPrefix, 0, sizeof(SCA_Prefix));
+    // Keep the data in network format
+    scaPrefix->afi    = htons(mp_update->afi);
+    scaPrefix->safi   = mp_update->safi;
+    // The length field is the first byte in the nlri data (prefix length)
+    scaPrefix->length = (u_int8_t)*mp_update->nlri;
+    if (scaPrefix->length > 0)
+    {
+      u_int8_t* ptr = (u_int8_t*)mp_update->nlri;
+      ptr++;
+      memcpy(scaPrefix->addr.ip, ptr, (mp_update->length-1));
+    }
+  }
+
+  return scaPrefix;
+}
+
+/**
+ * Parse the bgpsec path from the given attributes and verifies its structural
+ * correctness. Also generate the appropriate AS4_PATH. in case the BGPSEC
+ * path is malformed, BGP_ATTR_PARSE_ERROR will be thrown. Otherwise the as path
+ * will be generated and BGP_ATTR_PARSE_PROCEED will be returned.
+ *
+ *
+ * @param args The BGP attributes that MUST contain the BGPSEC path
+ *
+ * @return BGP_ATTR_PARSE_PROCEED or BGP_ATTR_PARSE_ERROR.
+ */
+/* BGP bgpsec attribute treatment. */
+static bgp_attr_parse_ret_t bgp_attr_bgpsec(struct bgp_attr_parser_args *args)
+{
+  // @TODO: Change the internal mallocs to quagga maintained XMALLOC
+
+  // already flag, type and length byte were read by the previous function
+  struct peer *const peer = args->peer;
+  struct attr *const attr = args->attr;
+  const bgp_size_t length = args->length;
+
+  // Removed the afi flag, it comes already encoded in mp_update
+
+  if (attr->aspath)
+  {
+    // Malformed Update
+    zlog_err(/*peer->log,*/ "[BGPSEC] Path Update MUST NOT contain AS_PATH!!");
+    return BGP_ATTR_PARSE_WITHDRAW;
+  }
+
+  if (BGP_DEBUG (bgpsec, BGPSEC_DETAIL))
+  {
+    zlog_debug("[BGPSEC] startp:%p length:%d total:%d", \
+        args->startp, args->length, args->total);
+  }
+
+  /* bgpsec pdu parsing */
+  // This is just temporarily until everything is adapted.
+  if (attr->bgpsec_validationData == NULL)
+  {
+    attr->bgpsec_validationData = malloc(sizeof(SCA_BGPSecValidationData));
+    memset(attr->bgpsec_validationData, 0, sizeof(SCA_BGPSecValidationData));
+  }
+  else
+  {
+    printf("ERROR: Why is this not null - can this happen??\n");
+    if (attr->bgpsec_validationData->bgpsec_path_attr != NULL)
+    {
+      free(attr->bgpsec_validationData->bgpsec_path_attr);
+    }
+    if (attr->bgpsec_validationData->nlri != NULL)
+    {
+      free(attr->bgpsec_validationData->nlri);
+    }
+    if (attr->bgpsec_validationData->hashMessage != NULL)
+    {
+      int idx;
+      for (idx = 0; idx < 2; idx++)
+      {
+        if (attr->bgpsec_validationData->hashMessage[idx] != NULL)
+        {
+          freeSCA_HashMessage(attr->bgpsec_validationData->hashMessage[idx]);
+          attr->bgpsec_validationData->hashMessage[idx] = NULL;
+        }
+      }
+    }
+  }
+
+  // @NOTE: Prepare the validation data object that will be passed into the
+  // validation algorithm. It also contains the bgpsec path attribute.
+  // For the next revision of the code it can completely replace the
+  // BgpsecPathAttribute data structure.
+  SCA_BGPSecValidationData* valdata = attr->bgpsec_validationData;
+  u_int8_t* ptr = NULL;
+  memset(valdata, 0, sizeof(SCA_BGPSecValidationData));
+  valdata->myAS   = htonl(peer->local_as);
+  valdata->status = API_STATUS_OK;
+  // The attribute valdata->nlri will be set later. We don't know if the
+  // prefix information is parsed yet.
+  valdata->bgpsec_path_attr = malloc(args->total);
+  memset(valdata->bgpsec_path_attr, 0,args->total);
+  SCA_BGP_PathAttribute* bsPa = (SCA_BGP_PathAttribute*)valdata->bgpsec_path_attr;
+  bsPa->flags      = args->flags;
+  bsPa->type_code  = args->type;
+  if ((args->flags & BGP_UPD_A_FLAGS_EXT_LENGTH) > 0)
+  {
+    SCA_BGPSEC_ExtPathAttribute* bsEPa = (SCA_BGPSEC_ExtPathAttribute*)bsPa;
+    bsEPa->attrLength = htons(args->length);
+    // Now Copy the rest into it
+    ptr = valdata->bgpsec_path_attr + 4;
+ }
+  else
+  {
+    SCA_BGPSEC_NormPathAttribute* bsNPa = (SCA_BGPSEC_NormPathAttribute*)bsPa;
+    bsNPa->attrLength = args->length;
+    // Now Copy the rest into it
+    ptr = valdata->bgpsec_path_attr + 3;
+  }
+  stream_get(ptr, peer->ibuf, length);
+
+  // Create a fresh stream for the BgpsecPathAttr generation.
+  struct stream* str = stream_new(length);
+  stream_put(str, ptr, length);
+
+  ptr = NULL;
+
+  attr->bgpsecPathAttr = bgpsec_parse(attr, peer, str, length);
+
+  if (attr->bgpsecPathAttr == NULL)
+  {
+    // We encounteres a parsing error, remove all data.
+    zlog_err(/*peer->log,*/ "BGPSEC Path Update MUST NOT contain AS_PATH!!");
+    if(valdata->nlri)
+    {
+      memset (valdata->nlri, 0, sizeof(SCA_Prefix));
+      free(valdata->nlri);
+    }
+    memset (valdata->bgpsec_path_attr, 0 , args->total);
+    free(valdata->bgpsec_path_attr);
+    memset (valdata, 0, sizeof(SCA_BGPSecValidationData));
+    valdata = NULL;
+    attr->bgpsecPathAttr = NULL;
+
+    return BGP_ATTR_PARSE_WITHDRAW;
+  }
+
+  // Generate the BGP4 AS_PATH
+  attr->aspath = srx_convert_to_aspath(attr, peer);
+  /* Add the aspath attribute flag. */
+  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_AS_PATH);
+
+  // set bgpsec Attribute flag
+  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_BGPSEC);
+
+  return BGP_ATTR_PARSE_PROCEED;
+}
+
+#endif /* USE_SRX */
+
 /* Read attribute of update packet.  This function is called from
    bgp_update_receive() in bgp_packet.c.  */
 bgp_attr_parse_ret_t
@@ -1906,11 +2169,55 @@ bgp_attr_parse (struct peer *peer, struc
 	case BGP_ATTR_EXT_COMMUNITIES:
 	  ret = bgp_attr_ext_communities (&attr_args);
 	  break;
+#ifdef USE_SRX
+      case BGP_ATTR_BGPSEC:
+        ret = bgp_attr_bgpsec(&attr_args);
+        if (ret == BGP_ATTR_PARSE_ERROR)
+        {
+          // @NOTE: We return the correct value from the bgp_attrt_bgpsec
+          //        method. There might be errors we cannot recover from, so
+          //        not all errors can be treated a BGP_STTR_PARSE_WITHDRAW.
+          // ret = BGP_ATTR_PARSE_WITHDRAW; // Treat it as Withdraw (section 5.2)
+          zlog (peer->log, LOG_WARNING, "BGPSEC Update Malformed!!");
+        }
+        break;
+#endif
 	default:
 	  ret = bgp_attr_unknown (&attr_args);
 	  break;
 	}
       
+#ifdef USE_SRX
+    // Check if we reached the end of the stream. If so, we can add the prefix
+    // information in case bgpsec_validationData was generated which means
+    // we do process a bgpsec path attribute at this point.
+    if (BGP_INPUT_PNT (peer) >= endp)
+    {
+      // Now we should have seen the prefix, if we are doing bgpsec, add the prefix
+      // to the update
+
+      // Now where all attributes are read, check if we got some prefixes as well
+      // if we do BGPSEC.
+      if (attr_args.attr->bgpsec_validationData != NULL)
+      {
+        // We are parsing a BGPSEC attribute
+        SCA_Prefix* nlri = bgpsec_create_valdata_nlri(mp_update);
+        if (nlri == NULL)
+        {
+          zlog_err("[BGPSEC] BGPSEC_PATH does not seem to have prefixes stored.");
+          bgp_notify_send (peer,
+           BGP_NOTIFY_UPDATE_ERR,
+           BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR);
+          ret = BGP_ATTR_PARSE_ERROR;
+        }
+        else
+        {
+          attr_args.attr->bgpsec_validationData->nlri = nlri;
+        }
+      }
+    }
+#endif // USE_SRXs
+
       /* If hard error occured immediately return to the caller. */
       if (ret == BGP_ATTR_PARSE_ERROR)
         {
@@ -1997,6 +2304,7 @@ bgp_attr_parse (struct peer *peer, struc
        * do any trouble
        */
     }
+
   /*
    * The "rest" of the code does nothing with as4_aggregator.
    * there is no memory attached specifically which is not part
@@ -2057,12 +2365,32 @@ bgp_attr_check (struct peer *peer, struc
 int stream_put_prefix (struct stream *, struct prefix *);
 
 /* Make attribute packet. */
+#ifdef USE_SRX
+// This method is changed that much that it makes sense to copy the original
+// one and make an #ifdef USE_SRX ... #else .... #endif where the original
+// function is in the else portion.
+
+// One modification is adding the parameter useASpath which is an OUT only
+// parameter.
+bgp_size_t
+bgp_packet_attribute (struct bgp *bgp, struct peer *peer,
+		      struct stream *s, struct attr *attr, struct prefix *p,
+		      afi_t afi, safi_t safi, struct peer *from,
+		      struct prefix_rd *prd, u_char *tag, bool* useASpath)
+{
+  // Now we assume we will do BGPSEC and if not, this variable will be modified
+  // on time to switch operation to BGP4
+  *useASpath = false;
+
+#else // USE_SRX
 bgp_size_t
 bgp_packet_attribute (struct bgp *bgp, struct peer *peer,
 		      struct stream *s, struct attr *attr, struct prefix *p,
 		      afi_t afi, safi_t safi, struct peer *from,
 		      struct prefix_rd *prd, u_char *tag)
 {
+#endif // USE_SRX
+
   size_t cp;
   size_t aspath_sizep;
   struct aspath *aspath;
@@ -2122,6 +2450,73 @@ bgp_packet_attribute (struct bgp *bgp, s
   else
     aspath = attr->aspath;
 
+#ifdef USE_SRX
+  if (!*useASpath)
+  {
+    // use AS path if we did not receive this path as bgpsec path and
+    // we have an as path stored. In this case we will have it received
+    // vie eBGP as AS_PATH
+    *useASpath = (aspath->str_len > 0) && (attr->bgpsecPathAttr == NULL);
+  }
+
+ /* if and only if, the peer's recv capability set and this node's send capability set,
+  * BGPSec Update message can be sent to the peer
+  *
+  * Added the case prefix aggregation is chosen, only generate a BGP4 AS_PATH
+  */
+  if (!*useASpath
+      && (   (   !CHECK_FLAG (peer->flags, PEER_FLAG_BGPSEC_CAPABILITY_SEND)
+              || !CHECK_FLAG (peer->cap, PEER_CAP_BGPSEC_ADV)
+             )
+          || ( from && from->as && from->as != peer->as
+               && (   !CHECK_FLAG (from->flags, PEER_FLAG_BGPSEC_CAPABILITY_RECV)
+                   || !CHECK_FLAG (from->cap, PEER_CAP_BGPSEC_ADV_SEND)
+                  )
+             )
+          // No Aggregation allowed in BGPSEC - 4.1
+          || (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_AGGREGATOR))
+          || (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE))
+         )
+     )
+  {
+    // We determined that for this peer no bgpsec path can be made.
+    *useASpath = true;
+  }
+
+  u_int8_t pCount = 0;
+  u_int8_t flags  = 0;
+  SCA_Signature* signature = NULL;
+
+  if (!(*useASpath))
+  {
+    // First, if this is an ebgp session, try to sign. If the signature fails out
+    // of whatever reason, we need to proceed using BGP4 and not BGPSEC. This
+    // has implications on the generation of IPv4 MP_NLRI vs. NEXT_HOP. etc.
+    // It makes all a lot easier if we know that signing works beforehand.
+    // First check if we do bgpsec:
+    if ((peer->sort == BGP_PEER_EBGP) || (peer->sort == BGP_PEER_CONFED))
+    {
+      // @TODO: set the confed flag here
+      flags  = peer->sort == BGP_PEER_CONFED ? 0x80 : 0;
+      pCount = (CHECK_FLAG (peer->flags, PEER_FLAG_BGPSEC_MIGRATE))
+               ? 0
+               : peer->sort == BGP_PEER_CONFED ? 0 : 1;
+      signature = signBGPSecPathAttr(bgp, peer, p, attr, pCount, flags);
+
+      // Now if we were unable to generate a signature, fall back to the BGP4
+      // AS_PATH
+      *useASpath = signature == NULL;
+    }
+    else if (peer->sort == BGP_PEER_IBGP || peer->sort == BGP_PEER_INTERNAL)
+    {
+      // Switch back to AS_PATH, we deal with an origination.
+      *useASpath = attr->bgpsecPathAttr == NULL;
+    }
+  }
+
+  if (*useASpath)
+  {
+#endif
   /* If peer is not AS4 capable, then:
    * - send the created AS_PATH out as AS4_PATH (optional, transitive),
    *   but ensure that no AS_CONFED_SEQUENCE and AS_CONFED_SET path segment
@@ -2131,11 +2526,13 @@ bgp_packet_attribute (struct bgp *bgp, s
    *   all ASnums > 65535 to BGP_AS_TRANS
    */
 
+#ifndef USE_SRX
   stream_putc (s, BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_EXTLEN);
   stream_putc (s, BGP_ATTR_AS_PATH);
   aspath_sizep = stream_get_endp (s);
   stream_putw (s, 0);
   stream_putw_at (s, aspath_sizep, aspath_put (s, aspath, use32bit));
+#endif // USE_SRX
   
   /* OLD session may need NEW_AS_PATH sent, if there are 4-byte ASNs 
    * in the path
@@ -2159,6 +2556,9 @@ bgp_packet_attribute (struct bgp *bgp, s
       else
 	stream_put_ipv4 (s, attr->nexthop.s_addr);
     }
+#ifdef USE_SRX
+  }
+#endif // USE_SRX
 
   /* MED attribute. */
   if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC))
@@ -2187,6 +2587,11 @@ bgp_packet_attribute (struct bgp *bgp, s
       stream_putc (s, 0);
     }
 
+#ifdef USE_SRX
+  // Its already checked, if the aggregator is set, no BGPSEC path will be
+  // generated.
+#endif
+
   /* Aggregator. */
   if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_AGGREGATOR))
     {
@@ -2284,6 +2689,50 @@ bgp_packet_attribute (struct bgp *bgp, s
 	}
     }
 
+#ifdef USE_SRX
+  // Now take care of the MP_NLRI for IPv4 which is required
+  // for BGPSEC
+  if (!(*useASpath))
+  {
+    // @TODO: Actually we can remove the PEER_FLAG_BGPSEC_MPE_IPV4 because
+    //        since it is required since DRAFT 14.
+    //        Come back later and remove this flag.
+    if ( CHECK_FLAG (peer->flags, PEER_FLAG_BGPSEC_MPE_IPV4)
+        && (peer->sort != BGP_PEER_IBGP) && (safi == SAFI_UNICAST))
+    {
+      // Create the temporary stream. We actually now already the maximum length
+      // of this attribute.
+      int attrSize = 13 + ((p->prefixlen + 7) / 8);
+      /* IPv4 MP format   */
+
+      // Shouldn't the prefix be in AF_INET format? What if it is in a different
+      // format, we just don't write it??
+      if (p->family == AF_INET)
+      {
+        assert (attr->extra);
+
+        stream_putc (s, BGP_ATTR_FLAG_OPTIONAL);
+        stream_putc (s, BGP_ATTR_MP_REACH_NLRI);
+
+        // We know the size of this attribtue
+        stream_putc (s, (attrSize - 3)); // 3 bytes for the attr. header
+
+        stream_putw (s, AFI_IP);	/* AFI */
+        stream_putc (s, safi);	/* SAFI */
+
+        stream_putc (s, 4); // nexthop length
+        stream_put (s, &attr->nexthop, 4);
+
+        /* SNPA */
+        stream_putc (s, 0);
+
+        /* Prefix write. */
+        stream_put_prefix (s, p);
+      }
+    }
+  }
+#endif
+
 #ifdef HAVE_IPV6
   /* If p is IPv6 address put it into attribute. */
   if (p->family == AF_INET6)
@@ -2411,8 +2860,17 @@ bgp_packet_attribute (struct bgp *bgp, s
 	      pnt = attre->ecommunity->val + (i * 8);
 	      tbit = *pnt;
 
+#ifdef USE_SRX
+        if ((!CHECK_FLAG (peer->bgp->srx_ecommunity_flags,
+                          SRX_BGP_FLAG_ECOMMUNITY_EBGP))
+            && (CHECK_FLAG (tbit, ECOMMUNITY_FLAG_NON_TRANSITIVE)))
+        {
+          continue;
+        }
+#else
 	      if (CHECK_FLAG (tbit, ECOMMUNITY_FLAG_NON_TRANSITIVE))
 		continue;
+#endif
 
 	      ecom_tr_size++;
 	    }
@@ -2436,16 +2894,27 @@ bgp_packet_attribute (struct bgp *bgp, s
 		{
 		  pnt = attre->ecommunity->val + (i * 8);
 		  tbit = *pnt;
-
+#ifdef USE_SRX
+          // Make sure we also include the srx extended community flag
+          if (!CHECK_FLAG (peer->bgp->srx_ecommunity_flags,
+                           SRX_BGP_FLAG_ECOMMUNITY_EBGP)
+              && (CHECK_FLAG (tbit, ECOMMUNITY_FLAG_NON_TRANSITIVE)))
+          {
+            continue;
+          }
+#else
 		  if (CHECK_FLAG (tbit, ECOMMUNITY_FLAG_NON_TRANSITIVE))
 		    continue;
-
+#endif
 		  stream_put (s, pnt, 8);
 		}
 	    }
 	}
     }
 
+#ifdef USE_SRX
+  // send_as4_path only can be 1 if useASpath is true
+#endif
   if ( send_as4_path )
     {
       /* If the peer is NOT As4 capable, AND */
@@ -2469,6 +2938,10 @@ bgp_packet_attribute (struct bgp *bgp, s
       stream_putw_at (s, aspath_sizep, aspath_put (s, aspath, 1));
     }
 
+#ifdef USE_SRX
+  struct aspath* aspath_bgpsec = NULL;
+  aspath_bgpsec = aspath_dup(aspath);
+#endif
   if (aspath != attr->aspath)
     aspath_free (aspath);
 
@@ -2487,6 +2960,92 @@ bgp_packet_attribute (struct bgp *bgp, s
       stream_put_ipv4 (s, attr->extra->aggregator_addr.s_addr);
     }
   
+#ifdef USE_SRX
+  if (!(*useASpath))
+  {
+    // Now store the bgpsec path
+    //
+    // We end up here in two situations:
+    // (a) the peer is EBGP
+    // (b) the peer is IBGP but the path was received through an EBGP session
+    //     and we just forward the received bgpsec path.
+    // In case the peer is IBGP and the path was originated internally we use
+    // BGP4 AS_PATH
+    SCA_BGPSecValidationData* valData = attr->bgpsec_validationData;
+    bool stored = false;
+    if (valData != NULL)
+    {
+      // See if we con forward -> only if received bgpsec and peer is ibgp
+      if ((valData->bgpsec_path_attr != NULL) && (peer->sort == BGP_PEER_IBGP))
+      {
+        // forward the received attribute
+        SCA_BGP_PathAttribute* pa =
+                              (SCA_BGP_PathAttribute*)valData->bgpsec_path_attr;
+        u_int16_t len = 0;
+        if (pa->flags & BGP_UPD_A_FLAGS_EXT_LENGTH > 0)
+        {
+          len = ntohs(((SCA_BGPSEC_ExtPathAttribute*)pa)->attrLength);
+        }
+        else
+        {
+          len = ((SCA_BGPSEC_NormPathAttribute*)pa)->attrLength;
+        }
+        // Forward the received BGPSEC Path attribute
+        stream_write(s, valData->bgpsec_path_attr, len);
+        stored = true;
+      }
+    }
+
+    if (!stored)
+    {
+      // At this point we only allow one signature.
+      SCA_Signature* signatures[1] = {signature};
+      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_EXTLEN); /* attr_flag */
+      stream_putc (s, BGP_ATTR_BGPSEC); /* attr_type: draft-ietf-sidr-bgpsec-protocol - 0x0b */
+      aspath_sizep = stream_get_endp (s);
+      // prestore the length field. It will be modified later on
+      stream_putw (s, 0); /* 0 size will be modified later */
+      int attrLen = constructBGPSecPathAttribute(bgp, peer, aspath_bgpsec,
+                                                 p, s, attr, flags, pCount,
+                                                 signatures, 1);
+      stream_putw_at (s, aspath_sizep, attrLen);
+    }
+  }
+  else
+  {
+    // Construct a good old AS_PATH attribute
+#endif // USE_SRX
+    stream_putc (s, BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_EXTLEN);
+    stream_putc (s, BGP_ATTR_AS_PATH);
+    aspath_sizep = stream_get_endp (s);
+    stream_putw (s, 0);
+#ifdef USE_SRX
+    stream_putw_at (s, aspath_sizep, aspath_put (s, aspath_bgpsec, use32bit));
+#else
+    stream_putw_at (s, aspath_sizep, aspath_put (s, aspath, use32bit));
+#endif
+
+#ifdef USE_SRX
+  }
+
+  /* release aspath pointer used for bgpsec */
+  if (aspath_bgpsec)
+  {
+    aspath_free (aspath_bgpsec);
+  }
+  if (signature != NULL)
+  {
+    if (bgp->srxCAPI->freeSignature(signature) == API_FAILURE)
+    {
+      free(signature->sigBuff);
+      signature->sigBuff = NULL;
+      free(signature);
+    }
+    signature = NULL;
+  }
+
+#endif /* USE_SRX */
+
   /* Unknown transit attribute. */
   if (attr->extra && attr->extra->transit)
     stream_put (s, attr->extra->transit->val, attr->extra->transit->length);
@@ -2551,6 +3110,9 @@ bgp_attr_init (void)
   ecommunity_init ();
   cluster_init ();
   transit_init ();
+#ifdef USE_SRX
+  bgpsec_path_attr_init();
+#endif
 }
 
 void
@@ -2562,6 +3124,9 @@ bgp_attr_finish (void)
   ecommunity_finish ();
   cluster_finish ();
   transit_finish ();
+#ifdef USE_SRX
+  bgpsec_path_attr_finish ();
+#endif
 }
 
 /* Make attribute packet. */
--- ./bgpd/bgp_debug.c	2013-01-26 21:25:34.000000000 -0500
+++ ./bgpd/bgp_debug.c	2017-06-26 15:53:49.000000000 -0400
@@ -45,6 +45,9 @@ unsigned long conf_bgp_debug_keepalive;
 unsigned long conf_bgp_debug_update;
 unsigned long conf_bgp_debug_normal;
 unsigned long conf_bgp_debug_zebra;
+#ifdef USE_SRX
+unsigned long conf_bgp_debug_bgpsec;
+#endif
 
 unsigned long term_bgp_debug_as4;
 unsigned long term_bgp_debug_fsm;
@@ -55,6 +58,9 @@ unsigned long term_bgp_debug_keepalive;
 unsigned long term_bgp_debug_update;
 unsigned long term_bgp_debug_normal;
 unsigned long term_bgp_debug_zebra;
+#ifdef USE_SRX
+unsigned long term_bgp_debug_bgpsec;
+#endif
 
 /* messages for BGP-4 status */
 const struct message bgp_status_msg[] = 
@@ -744,11 +750,147 @@ DEFUN (no_debug_bgp_all,
   TERM_DEBUG_OFF (fsm, FSM);
   TERM_DEBUG_OFF (filter, FILTER);
   TERM_DEBUG_OFF (zebra, ZEBRA);
+#ifdef USE_SRX
+  TERM_DEBUG_OFF (bgpsec, BGPSEC_DETAIL);
+  TERM_DEBUG_OFF (bgpsec, BGPSEC_IN);
+  TERM_DEBUG_OFF (bgpsec, BGPSEC_OUT);
+#endif
   vty_out (vty, "All possible debugging has been turned off%s", VTY_NEWLINE);
       
   return CMD_SUCCESS;
 }
 
+#ifdef USE_SRX
+DEFUN (debug_bgp_bgpsec,
+       debug_bgp_bgpsec_cmd,
+       "debug bgp bgpsec",
+       DEBUG_STR
+       BGP_STR
+       "BGPSEC actions\n"
+       "BGPSEC debugging info handling\n")
+{
+  if (vty->node == CONFIG_NODE)
+  {
+    DEBUG_ON (bgpsec, BGPSEC_DETAIL);
+    DEBUG_ON (bgpsec, BGPSEC_IN);
+    DEBUG_ON (bgpsec, BGPSEC_OUT);
+  }
+  else
+  {
+    TERM_DEBUG_ON (bgpsec, BGPSEC_DETAIL);
+    TERM_DEBUG_ON (bgpsec, BGPSEC_IN);
+    TERM_DEBUG_ON (bgpsec, BGPSEC_OUT);
+    vty_out (vty, "BGP bgpsec debugging is on%s", VTY_NEWLINE);
+  }
+  return CMD_SUCCESS;
+}
+
+DEFUN (debug_bgp_bgpsec_direct,
+       debug_bgp_bgpsec_direct_cmd,
+       "debug bgp bgpsec (in|out)",
+       DEBUG_STR
+       BGP_STR
+       "BGPSEC actions\n"
+       "Inbound actions\n"
+       "Outbound actions\n")
+{
+  if (vty->node == CONFIG_NODE)
+    {
+      if (strncmp ("i", argv[0], 1) == 0)
+	{
+	  DEBUG_OFF (bgpsec, BGPSEC_OUT);
+	  DEBUG_ON (bgpsec, BGPSEC_IN);
+	}
+      else
+	{
+	  DEBUG_OFF (bgpsec, BGPSEC_IN);
+	  DEBUG_ON (bgpsec, BGPSEC_OUT);
+	}
+    }
+  else
+    {
+      if (strncmp ("i", argv[0], 1) == 0)
+	{
+	  TERM_DEBUG_OFF (bgpsec, BGPSEC_OUT);
+	  TERM_DEBUG_ON (bgpsec, BGPSEC_IN);
+	  vty_out (vty, "BGP bgpsec  debugging is on (inbound)%s", VTY_NEWLINE);
+	}
+      else
+	{
+	  TERM_DEBUG_OFF (bgpsec, BGPSEC_IN);
+	  TERM_DEBUG_ON (bgpsec, BGPSEC_OUT);
+	  vty_out (vty, "BGP bgpsec debugging is on (outbound)%s", VTY_NEWLINE);
+	}
+    }
+  return CMD_SUCCESS;
+}
+
+DEFUN (debug_bgp_bgpsec_detail,
+       debug_bgp_bgpsec_detail_cmd,
+       "debug bgp bgpsec detail",
+       DEBUG_STR
+       BGP_STR
+       "BGPSEC detailed actions\n"
+       "BGPSEC debugging info detailed handling\n")
+{
+  if (vty->node == CONFIG_NODE)
+  {
+    DEBUG_ON (bgpsec, BGPSEC_DETAIL);
+  }
+  else
+  {
+    TERM_DEBUG_ON (bgpsec, BGPSEC_DETAIL);
+    vty_out (vty, "BGP bgpsec detailed debugging is on%s", VTY_NEWLINE);
+  }
+  return CMD_SUCCESS;
+}
+
+DEFUN (no_debug_bgp_bgpsec_detail,
+       no_debug_bgp_bgpsec_detail_cmd,
+       "no debug bgp bgpsec detail",
+       NO_STR
+       DEBUG_STR
+       BGP_STR
+       "BGPSEC messages\n")
+{
+  if (vty->node == CONFIG_NODE)
+  {
+    DEBUG_OFF (bgpsec, BGPSEC_DETAIL);
+  }
+  else
+  {
+    TERM_DEBUG_OFF (bgpsec, BGPSEC_DETAIL);
+    vty_out (vty, "BGP bgpsec detailed debugging is off%s", VTY_NEWLINE);
+  }
+  return CMD_SUCCESS;
+}
+
+DEFUN (no_debug_bgp_bgpsec,
+       no_debug_bgp_bgpsec_cmd,
+       "no debug bgp bgpsec",
+       NO_STR
+       DEBUG_STR
+       BGP_STR
+       "BGPSEC messages\n")
+{
+  if (vty->node == CONFIG_NODE)
+  {
+    DEBUG_OFF (bgpsec, BGPSEC_DETAIL);
+    DEBUG_OFF (bgpsec, BGPSEC_IN);
+    DEBUG_OFF (bgpsec, BGPSEC_OUT);
+  }
+  else
+  {
+    TERM_DEBUG_OFF (bgpsec, BGPSEC_DETAIL);
+    TERM_DEBUG_OFF (bgpsec, BGPSEC_IN);
+    TERM_DEBUG_OFF (bgpsec, BGPSEC_OUT);
+    vty_out (vty, "BGP bgpsec debugging is off%s", VTY_NEWLINE);
+  }
+  return CMD_SUCCESS;
+}
+#endif /* USE_SRX */
+
+
 ALIAS (no_debug_bgp_all,
        undebug_bgp_all_cmd,
        "undebug all bgp",
@@ -787,6 +929,22 @@ DEFUN (show_debugging_bgp,
     vty_out (vty, "  BGP as4 debugging is on%s", VTY_NEWLINE);
   if (BGP_DEBUG (as4, AS4_SEGMENT))
     vty_out (vty, "  BGP as4 aspath segment debugging is on%s", VTY_NEWLINE);
+#ifdef USE_SRX
+  if (BGP_DEBUG (bgpsec, BGPSEC_DETAIL) && (BGP_DEBUG (bgpsec, BGPSEC_IN)) && (BGP_DEBUG (bgpsec, BGPSEC_OUT)))
+  {
+    vty_out (vty, "  BGP bgpsec debugging is all on %s", VTY_NEWLINE);
+    goto BGPSEC_display_done;
+  }
+  if (BGP_DEBUG (bgpsec, BGPSEC_IN))
+    vty_out (vty, "  BGP bgpsec debugging is on (inbound)%s", VTY_NEWLINE);
+
+  if (BGP_DEBUG (bgpsec, BGPSEC_OUT))
+    vty_out (vty, "  BGP bgpsec debugging is on (outbound)%s", VTY_NEWLINE);
+
+  if (BGP_DEBUG (bgpsec, BGPSEC_DETAIL))
+      vty_out (vty, "  BGP bgpsec debugging is on (detail)%s", VTY_NEWLINE);
+BGPSEC_display_done:
+#endif
   vty_out (vty, "%s", VTY_NEWLINE);
   return CMD_SUCCESS;
 }
@@ -859,7 +1017,29 @@ bgp_config_write_debug (struct vty *vty)
       vty_out (vty, "debug bgp zebra%s", VTY_NEWLINE);
       write++;
     }
-
+#ifdef USE_SRX
+  if (CONF_BGP_DEBUG (bgpsec, BGPSEC_DETAIL) && CONF_BGP_DEBUG (bgpsec, BGPSEC_IN)
+      && CONF_BGP_DEBUG (bgpsec, BGPSEC_OUT))
+    {
+      vty_out (vty, "debug bgp bgpsec%s", VTY_NEWLINE);
+      write++;
+    }
+  else if (CONF_BGP_DEBUG (bgpsec, BGPSEC_IN))
+    {
+      vty_out (vty, "debug bgp bgpsec in%s", VTY_NEWLINE);
+      write++;
+    }
+  else if (CONF_BGP_DEBUG (bgpsec, BGPSEC_OUT))
+    {
+      vty_out (vty, "debug bgp bgpsec out%s", VTY_NEWLINE);
+      write++;
+    }
+  else if (CONF_BGP_DEBUG (bgpsec, BGPSEC_DETAIL))
+  {
+    vty_out (vty, "debug bgp bgpsec detail%s", VTY_NEWLINE);
+    write++;
+  }
+#endif
   return write;
 }
 
@@ -929,4 +1109,20 @@ bgp_debug_init (void)
   install_element (CONFIG_NODE, &no_debug_bgp_zebra_cmd);
   install_element (ENABLE_NODE, &no_debug_bgp_all_cmd);
   install_element (ENABLE_NODE, &undebug_bgp_all_cmd);
+#ifdef USE_SRX
+  install_element (ENABLE_NODE, &debug_bgp_bgpsec_cmd);
+  install_element (CONFIG_NODE, &debug_bgp_bgpsec_cmd);
+
+  install_element (ENABLE_NODE, &no_debug_bgp_bgpsec_cmd);
+  install_element (CONFIG_NODE, &no_debug_bgp_bgpsec_cmd);
+
+  install_element (ENABLE_NODE, &debug_bgp_bgpsec_direct_cmd);
+  install_element (CONFIG_NODE, &debug_bgp_bgpsec_direct_cmd);
+
+  install_element (ENABLE_NODE, &debug_bgp_bgpsec_detail_cmd);
+  install_element (CONFIG_NODE, &debug_bgp_bgpsec_detail_cmd);
+
+  install_element (ENABLE_NODE, &no_debug_bgp_bgpsec_detail_cmd);
+  install_element (CONFIG_NODE, &no_debug_bgp_bgpsec_detail_cmd);
+#endif
 }
--- ./bgpd/bgp_route.c	2013-02-01 11:55:04.000000000 -0500
+++ ./bgpd/bgp_route.c	2017-06-26 16:00:28.000000000 -0400
@@ -56,10 +56,309 @@ Software Foundation, Inc., 59 Temple Pla
 #include "bgpd/bgp_vty.h"
 #include "bgpd/bgp_mpath.h"
 
+
+#ifdef USE_SRX
+#include <sys/un.h>
+#include "srx/srx_defs.h"
+#include "srx/srx_api.h"
+#include "bgpd/bgp_validate.h"
+#endif /* USE_SRX */
+
 /* Extern from bgp_dump.c */
 extern const char *bgp_origin_str[];
 extern const char *bgp_origin_long_str[];
 
+#ifdef USE_SRX
+#define NUM_MAX_RECONNECT   2
+#define RETRY_TIMER_SEC     10
+
+extern bool handleSRxValidationResult (SRxValidationResult* result,
+                                       void* bgpRouter);
+extern void handleSRxSignatures(SRxUpdateID* updateID, BGPSecData* data,
+                                void* bgpRouter);
+extern void handleSRxSynchRequest(void* bgpRouter);
+int respawnReceivePacket(struct thread *t);
+struct thread *g_current_read_thread;
+
+struct SRxThread* srx_thread_arg_new(void)
+{
+    struct SRxThread *rq;
+    rq = calloc(1, sizeof(struct SRxThread));
+
+    return rq;
+}
+
+int checkClientConnection(struct thread *t)
+{
+    zlog_debug (" %s called", __FUNCTION__);
+    struct thread *thr=NULL;
+    //bool succ;
+    struct SRxThread *rq;
+    bool reconnected = false;
+    static int siMaxReconnect = 0;
+
+    rq = (struct SRxThread *)THREAD_ARG(t);
+    rq->t_read = NULL;
+
+    // Get the bgp instance
+    struct bgp* bgp = bgp_get_default();
+    // Only the previous FD is needed, it contains the original FD that needs
+    // to be closed
+    int prevClientFD = getInternalSocketFD(bgp->srxProxy, false);
+    zlog_debug (" obtained previous fd:%d,  rq->clientFD:%d", prevClientFD,
+                rq->clientFD);
+
+    rq->prevClientFD = (rq->clientFD >0) ? rq->clientFD : prevClientFD ;
+
+    // Reconnect session. In this case it only closes the old connection on the
+    // application layer. The socket is not closed - we will do this later on
+    reconnected = reconnectWithSRx(bgp->srxProxy);
+
+    if(thr)
+    {
+      zlog_debug ("[%s] cancel the previous thread (fd:%d,%d)", __FUNCTION__,
+                  rq->clientFD, thr->u.fd);
+      thread_cancel(thr);
+    }
+
+    // Cancel old timer threads
+    if(reconnected)
+    {
+      zlog_debug (" close previous socket FD(%d)", rq->prevClientFD);
+      close(rq->prevClientFD);
+
+      // new fd
+      rq->clientFD = getInternalSocketFD(bgp->srxProxy, true);
+      rq->t_read = thr = thread_add_read (bm->master, respawnReceivePacket, rq,
+                                          rq->clientFD);
+      g_current_read_thread = thr;
+      zlog_debug ("[%s] call thread-add-read again for the new fd:%d",
+                  __FUNCTION__, rq->clientFD);
+      return 0;
+    }
+    else
+    {
+      // respawn in every 10 sec
+      thr = thread_add_timer (bm->master, checkClientConnection, rq,
+                              RETRY_TIMER_SEC ); // every 10 sec, try again
+    }
+
+    // TODO: if a certain amount times fail for reconnect, then clear off
+    //       client connection
+    siMaxReconnect++;
+    if(siMaxReconnect >= NUM_MAX_RECONNECT )
+    {
+      // Close the previous FD
+      if(rq->prevClientFD > 0)
+      {
+        zlog_debug (" close previous socket prevFD(%d)", rq->prevClientFD);
+        close(rq->prevClientFD);
+      }
+
+      bgp= bgp_get_default();
+      if (bgp == NULL)
+      {
+        return 0;
+      }
+
+      zlog_debug (" srx unset() bgp info hash finish() and releaseSRxProxy()");
+      bgp_srx_unset(bgp);
+      siMaxReconnect =0;
+      //bgp_info_hash_finish (&bgp->info_hash);
+      if (bgp->srxProxy)
+      {
+        releaseSRxProxy (bgp->srxProxy);
+      }
+      if(thr)
+      {
+        thread_cancel(thr);
+      }
+
+      // Close the previous thread FD
+      if(rq->clientFD > 0)
+      {
+        zlog_debug (" close previous socket rq->clientFD(%d)", rq->clientFD);
+        close(rq->clientFD);
+      }
+
+      zlog_debug (" srx set default again");
+      srx_set_default(bgp);
+    }
+
+    return 0;
+}
+
+int respawnReceivePacket(struct thread *t)
+{
+    //zlog_debug("respawnReceivePacket called");
+    struct SRxThread *rq;
+    bool bRetVal = true;
+    rq = (struct SRxThread *)THREAD_ARG(t);
+    int clientFD = THREAD_VAL(t);
+    rq->clientFD = clientFD;
+    rq->t_read = NULL;
+
+    struct thread *thr = NULL;
+
+    /* Receive srx server packets */
+    // TODO: function name changed
+    bRetVal =  processPackets(rq->proxy);
+
+    // connection error
+    if (!bRetVal)
+    {
+	if(g_current_read_thread)
+	{
+  	  thread_cancel(g_current_read_thread);
+	  zlog_debug ("[%s] read thread cancel ", __FUNCTION__);
+	}
+	rq->t_read = thread_add_timer (bm->master, checkClientConnection, rq,
+                                 RETRY_TIMER_SEC); // every 10 sec, try again
+
+	//
+	// TODO: after a certain amount time or try, clean up client connection
+	//
+    }
+    else
+    {
+      rq->t_read = thr = thread_add_read (bm->master, respawnReceivePacket, rq,
+                                          clientFD);
+      g_current_read_thread = thr;
+    }
+    return 0;
+}
+
+int initUnSocket(struct thread *t)
+{
+    struct sockaddr_un saddru_rv, saddru_rv_recv;
+    int     ufd, ufdRecv;
+    //socklen_t   len_saddr;
+    struct SRxThread *srx_rq = srx_thread_arg_new();
+    g_rq = srx_rq;
+    srx_rq->sock = -1;
+
+    /* init variables */
+    memset(&saddru_rv, 0x00, sizeof(struct sockaddr_un));
+    //len_saddr = sizeof(struct sockaddr_un);
+
+    /* setting socket address structure */
+    saddru_rv.sun_family = AF_UNIX;         /* AF_UNIX, PF_UNIX are same */
+    strncpy(&saddru_rv.sun_path[1], "srx", sizeof(saddru_rv.sun_path)-2);
+		/* Abstract name is "srx" followed by null bytes */
+		/* saddr.sun_path[0] has already set to 0 by memset() */
+
+    srx_rq->sock = ufd = socket(AF_UNIX, SOCK_DGRAM, IPPROTO_IP);
+    if (ufd == -1)
+    {
+      zlog_debug ("Fail: un_socket()");
+    }
+
+    if (bind(ufd, (struct sockaddr *)&saddru_rv, sizeof(saddru_rv)) == -1)
+    {
+      zlog_debug ("Fail: un_socket bind()");
+      exit(EXIT_FAILURE);
+    }
+
+
+    /* init Recv socket variables */
+    memset(&saddru_rv_recv, 0x00, sizeof(struct sockaddr_un));
+    saddru_rv_recv.sun_family = AF_UNIX;         /* AF_UNIX, PF_UNIX are same */
+    strncpy(&saddru_rv_recv.sun_path[1], "srxRecv",
+            sizeof(saddru_rv_recv.sun_path)-2);
+    ufdRecv = socket(AF_UNIX, SOCK_DGRAM, IPPROTO_IP);
+    if (ufdRecv == -1)
+    {
+      zlog_debug ("Fail: un_socket()");
+    }
+
+    if (bind(ufdRecv, (struct sockaddr *)&saddru_rv_recv,
+             sizeof(saddru_rv_recv)) == -1)
+    {
+      zlog_debug ("Fail: un_socket bind()");
+      exit(EXIT_FAILURE);
+    }
+
+    //zlog_debug (" ------ initUnSocket Event called by thread ");
+    //zlog_debug (" srx_rq: %p  and ufd: %d %s", srx_rq, srx_rq->sock, __func__);
+
+    //thread_add_read (bm->master, rq_recv, srx_rq, ufd);
+    //thread_add_read (bm->master, threadSRxRecv, srx_rq, ufdRecv);
+    //thread_execute(bm->master, initSRxRecvThread, NULL /* something arg */, 0);
+
+    if (flagDoConnectSrx != NULL)
+    {
+      zlog_debug("Request to connect to SRx server");
+      bool isConnected = srx_connect_proxy((struct bgp*)flagDoConnectSrx) == 0;
+      if (isConnected)
+      {
+        flagDoConnectSrx = NULL;
+      }
+      zlog_debug("Connection to SRx-server %s",
+                 (isConnected) ? "succeeded" : "failed");
+    }
+    return 0;
+}
+
+int checkSendQueue(struct thread *t)
+{
+    struct SRxThread *rq;
+    rq = (struct SRxThread *)THREAD_ARG(t);
+    if(rq) return 1;
+    return 0;
+
+}
+
+void threadControlCall(int type)
+{
+
+// TODO: KH use the SRxProxyError types
+    struct SRxThread *rq;
+
+    rq = g_rq;
+
+    if(type == COM_ERR_PROXY_UNKNOWN && rq->clientFD != 0)
+    {
+      // Never will happen because this error is never send!!!
+      FD_CLR (rq->clientFD, &bm->master->readfd);
+      zlog_debug (" FD_CLR called for avoiding select() error" );
+    }
+    else if(type == COM_ERR_PROXY_COULD_NOT_SEND)
+    {
+      if( FD_ISSET(rq->clientFD, &bm->master->readfd) )
+      {
+        FD_CLR (rq->clientFD, &bm->master->readfd);
+        zlog_debug (" FD_CLR called for avoiding select() error" );
+      }
+      return;
+    }
+    else if (type == COM_ERR_PROXY_UNKNOWN_UPDATE)
+    {
+      return;
+    }
+
+    // something went bad just give up....
+
+    if(g_current_read_thread)
+    {
+      zlog_debug ("%s thread cancel", __FUNCTION__);
+      thread_cancel(g_current_read_thread);
+      if(rq->clientFD > 0)
+      {
+        close(rq->clientFD);
+        rq->clientFD = -1;
+      }
+    }
+
+    if(   (type == COM_ERR_PROXY_CONNECTION_LOST)
+       || (type == COM_PROXY_DISCONNECT))
+    {
+      zlog_debug (" Disconnect or lost connection , respawn thread add timer" );
+      thread_add_timer (bm->master, checkClientConnection, rq, RETRY_TIMER_SEC);
+      // every 10 sec, respawn
+    }
+}
+#endif /* USE_SRX */
+
 static struct bgp_node *
 bgp_afi_node_get (struct bgp_table *table, afi_t afi, safi_t safi, struct prefix *p,
 		  struct prefix_rd *prd)
@@ -130,7 +429,20 @@ bgp_info_extra_get (struct bgp_info *ri)
 static struct bgp_info *
 bgp_info_new (void)
 {
+#ifdef USE_SRX
+  struct bgp_info *new = XCALLOC (MTYPE_BGP_ROUTE, sizeof (struct bgp_info));
+  if (new)
+  {
+    new->node = NULL;
+    new->info_hash = NULL;
+
+    new->updateID        = 0; // not specified yet
+    new->localID         = 0; // not specified yet
+  }
+  return new;
+#else /* USE_SRX */
   return XCALLOC (MTYPE_BGP_ROUTE, sizeof (struct bgp_info));
+#endif /* USE_SRX */
 }
 
 /* Free bgp route information. */
@@ -145,6 +457,25 @@ bgp_info_free (struct bgp_info *binfo)
 
   peer_unlock (binfo->peer); /* bgp_info peer reference */
 
+#ifdef USE_SRX /* USE_SRX */
+  if (binfo->info_hash)
+  {
+    // Determine if update id or local id is used
+    if (binfo->updateID != 0)
+    {
+      bgp_info_unregister (binfo->info_hash, binfo->updateID);
+    //zlog_debug("withdraw update [0x%08X] to SRx server!", binfo->updateID);
+      deleteUpdate(binfo->peer->bgp->srxProxy, binfo->peer->bgp->srx_keepWindow,
+                   binfo->updateID);
+    }
+    else
+    {
+      bgp_info_unregister (binfo->info_hash, binfo->localID);
+    }
+    binfo->info_hash = NULL;
+  }
+#endif /* USE_SRX */
+
   XFREE (MTYPE_BGP_ROUTE, binfo);
 }
 
@@ -195,6 +526,10 @@ bgp_info_add (struct bgp_node *rn, struc
     top->prev = ri;
   rn->info = ri;
   
+#ifdef USE_SRX
+  ri->node = rn;
+#endif /* USE_SRX */
+
   bgp_info_lock (ri);
   bgp_lock_node (rn);
   peer_lock (ri->peer); /* bgp_info peer reference */
@@ -305,6 +640,311 @@ bgp_info_unset_flag (struct bgp_node *rn
   bgp_pcount_adjust (rn, ri);
 }
 
+#ifdef USE_SRX
+/** This method sets or frees the ignore flag depending on the system
+ * configuration and the update validation state.
+ *
+ * @param info the bgp update information
+ *
+ * @return 0 if the ignore flag is not set.
+ *         1 if the ignore flag is set.
+ */
+int bgp_info_set_ignore_flag (struct bgp_info* info)
+{
+  int ignore;
+  struct bgp *bgp;
+  int valRes;
+
+  ignore = 0;
+  bgp = info->peer->bgp;
+  valRes = srx_calc_validation_state(bgp, info);
+
+  // check the setting ignore-invalid according to the result value
+  if (bgp->srx_config & SRX_CONFIG_EVALUATE)
+  {
+    switch (valRes)
+    {
+      case SRx_RESULT_INVALID:
+        if (bgp->srx_val_policy & SRX_VAL_POLICY_IGNORE_INVALID)
+        {
+          ignore = 1;
+        }
+        break;
+      case SRx_RESULT_NOTFOUND:
+        if (bgp->srx_val_policy & SRX_VAL_POLICY_IGNORE_NOTFOUND)
+        {
+          ignore = 1;
+        }
+        break;
+      case SRx_RESULT_UNDEFINED:
+        if (bgp->srx_val_policy & SRX_VAL_POLICY_IGNORE_UNDEFINED)
+        {
+          ignore = 1;
+        }
+      default:
+        break;
+    }
+  }
+  else
+  {
+    if (ignore)
+    {
+      zlog_debug ("Evaluation disabled do not set ignore flag for update "
+                  "[0x%08X]!", info->updateID);
+      ignore = 0;
+    }
+  }
+
+  /* Adjust 'ignore' flag */
+  // Is this flag an original Quagga flag? if so is it possible that we
+  // overwrite a set flag by un-setting it? Should we use
+  if (CHECK_FLAG (info->flags, BGP_INFO_IGNORE))
+  {
+    if (ignore == 0)
+    {
+     // zlog_debug ("Remove 'Ignore' flag for update [0x%08X]!",
+     //             info->updateID);
+      bgp_info_unset_flag (info->node, info, BGP_INFO_IGNORE);
+    }
+  }
+  else if (ignore == 1)
+  {
+    //zlog_debug ("Setting 'Ignore' flag for update [0x%08X]!",
+    //            info->updateID);
+    bgp_info_set_flag (info->node, info, BGP_INFO_IGNORE);
+  }
+
+  return ignore;
+}
+
+/**
+ * This method determines the outcome of the validation result. Depending on the
+ * evaluation mode (no srx evaluation, srx evaluation bgpsec, or
+ * srx evaluation origin_only the result of this method might change.
+ *
+ * Possible results:
+ *   no srx evaluation:          SRx_RESULT_DONOTUSE
+ *
+ *   srx evaluation bgpsec:      SRx_RESULT_VALID, SRx_RESULT_INVALID,
+ *                               SRx_RESULT_UNDEFINED
+ *                               (valid requires path and origin validation to
+ *                               be valid, otherwise invalid!)
+ *
+ *   srx evaluation origin_only: SRx_RESULT_VALID, SRx_RESULT_NOTFOUND,
+ *                               SRx_RESULT_INVALID, SRx_RESULT_UNDEFINED
+ *
+ * Result table for bgpsec:
+ *
+ *   PATH | v | i | ? |
+ * ORIGIN |   |   |   |
+ * -------+---+---+---|
+ *  v     | v | i | ? |
+ * -------+---+---+---|
+ *  n     | i | i | i |
+ * -------+---+---+---|
+ *  i     | i | i | i |
+ * -------+---+---+---+
+ *  ?     | ? | i | ? |
+ * -------+---+---+---+
+ *
+ * @param bgp
+ * @param info
+ *
+ * @return SRx_RESULT_VALID, SRx_RESULT_INVALID, or SRx_RESULT_UNDEFINED
+ */
+int srx_calc_validation_state(struct bgp *bgp, struct bgp_info *info)
+{
+  int result;
+
+  result = SRx_RESULT_DONOTUSE;
+
+  if (srx_config_check(bgp, SRX_CONFIG_EVAL_PATH))
+  { // BGPSEC validation is selected!
+    switch (info->val_res_ROA)
+    {
+      case SRx_RESULT_VALID:
+        result = info->val_res_BGPSEC;
+        break;
+      case SRx_RESULT_NOTFOUND:
+      case SRx_RESULT_INVALID:
+        result = SRx_RESULT_INVALID;
+        break;
+      case SRx_RESULT_UNDEFINED:
+        result = info->val_res_BGPSEC == SRx_RESULT_INVALID
+                 ? SRx_RESULT_INVALID
+                 : SRx_RESULT_UNDEFINED;
+        break;
+      default:
+        zlog_err("BGPSEC validation calculation reports invalid ROA state. "
+                 "Sepcify result as UNDEFINED!");
+        result = info->val_res_BGPSEC == SRx_RESULT_UNDEFINED;
+
+    }
+  }
+  else if (srx_config_check(bgp, SRX_CONFIG_EVAL_ORIGIN))
+  { // Prefix origin validation only!
+    result = info->val_res_ROA;
+  }
+
+  return result;
+}
+
+/**
+ * Add the given update back into the process queue.
+ *
+ * @param info the BGP update.
+ */
+void srx_bgp_requeue_update(struct bgp_info *info)
+{
+  struct bgp_table *table;
+  table = (struct bgp_table *)info->node->table->info;
+
+  bgp_process (info->peer->bgp, info->node, table->afi, table->safi);
+}
+
+/**
+ * Requeue all updates associated with this router. this method is used for the
+ * terminal command "srx apply-policy"
+ *
+ * @param The bgp router
+ */
+void srx_bgp_requeue_all(struct bgp *bgp)
+{
+  struct bgp_table* table;
+  struct bgp_node *bnode;
+
+  if (bgp != NULL)
+  {
+    table = bgp->rib[AFI_IP][SAFI_MULTICAST];
+    for (bnode = bgp_table_top(table); bnode; bnode = bgp_route_next(bnode))
+    {
+      if (bnode->info != NULL)
+      {
+        srx_bgp_requeue_update(bnode->info);
+      }
+    }
+
+    table = bgp->rib[AFI_IP][SAFI_UNICAST];
+    for (bnode = bgp_table_top(table); bnode; bnode = bgp_route_next(bnode))
+    {
+      if (bnode->info != NULL)
+      {
+        srx_bgp_requeue_update(bnode->info);
+      }
+    }
+  }
+}
+
+
+/**
+ * @brief Check for bpg attribute whether it contains extra community values from peer
+ *
+ * @param attr
+ *
+ * @return Success or Failure
+ */
+int checkEcomSRxValid(struct attr* attr)
+{
+  int ret;
+
+  if (!attr->extra)
+    return -1;
+
+  struct attr_extra *attre = attr->extra;
+
+  if (!attre->ecommunity)
+    return -1;
+
+  struct ecommunity *ecom = attre->ecommunity;
+
+  if(!ecom->str || !ecom->val)
+    return -1;
+
+  if (BGP_DEBUG (update, UPDATE_IN))
+  {
+    zlog_debug("extended community: %s ", ecom->str );
+    zlog_debug("val: (type)0x%x, (ValidStatus)0x%x ", ecom->val[0], ecom->val[7]);
+  }
+
+  switch (ecom->val[7])
+  {
+    case ECOMMUNITY_BGPSEC_VALID:       // 0
+      if (BGP_DEBUG (update, UPDATE_IN))
+        zlog_debug(" QuaggaSRx Received \"SRx Ecommunity value VALID\" from peer ");
+      ret = ECOMMUNITY_BGPSEC_VALID;
+      break;
+    case ECOMMUNITY_BGPSEC_NOT_FOUND:   // 1
+      ret = ECOMMUNITY_BGPSEC_NOT_FOUND;
+      break;
+    case ECOMMUNITY_BGPSEC_INVALID:     // 2
+      ret = ECOMMUNITY_BGPSEC_INVALID;
+      break;
+    case 0xAB:      // test value
+      ret = ECOMMUNITY_BGPSEC_UNDEFINED;// 3 undefined
+      break;
+    default:        // unknown value
+      ret = -1;
+      break;
+  }
+
+  return ret;
+}
+
+/**
+ * Modifies the BGP update information according to the SRX settings.
+ * This will be done using the bgp_info data structure.
+ * This method is called by the SRx callback to update the validation result.
+ *
+ * In case if one result ROA / BGPSEC is UNDEFINED the update will by default be
+ * ignored.
+ *
+ * Also the update will only be put back into the queue if the ignore state
+ * changed or the validation result changed.
+ */
+void bgp_info_set_validation_result (struct bgp_info *info,
+                                     ValidationResultType resType,
+                                     uint8_t roaResult, uint8_t bgpsecResult)
+{
+  /* An internal error occurred */
+  if ((resType & SRX_FLAG_ROA_AND_BGPSEC) == 0)
+  {
+    zlog_debug ("No SRx result provided! - Update [0x%08X]", info->updateID);
+  }
+  else
+  {
+    struct bgp *bgp   = info->peer->bgp;
+    int requeue       = 0;
+
+    // First store the current status
+    uint8_t oldResult = srx_calc_validation_state(bgp, info);
+    uint8_t oldIgnore = CHECK_FLAG (info->flags, BGP_INFO_IGNORE) ? 1 : 0;
+
+    // Now store the new results.
+    if ((resType & SRX_FLAG_ROA) == SRX_FLAG_ROA)
+    {
+      info->val_res_ROA = roaResult;
+    }
+    if ((resType & SRX_FLAG_BGPSEC) == SRX_FLAG_BGPSEC)
+    {
+      info->val_res_BGPSEC = bgpsecResult;
+    }
+
+    // Check if it is fully valid and if not decide if the update has to be
+    // ignored
+    bool ignoreChanged = bgp_info_set_ignore_flag(info) != oldIgnore;
+    bool resultChanged = oldResult != srx_calc_validation_state(bgp, info);
+
+    // Only re-queue if the ignore state changed or if the result changed.
+    requeue = ignoreChanged || resultChanged;
+
+    if (requeue)
+    {
+      srx_bgp_requeue_update(info);
+    }
+  }
+}
+#endif /* USE_SRX */
+
 /* Get MED value.  If MED value is missing and "bgp bestpath
    missing-as-worst" is specified, treat it as the worst value. */
 static u_int32_t
@@ -321,6 +961,62 @@ bgp_med_value (struct attr *attr, struct
     }
 }
 
+#ifdef USE_SRX
+
+/**
+ * This method caclulated the new local pref.
+ *
+ * @param prefPol The local preference policy for the given result value.
+ * @param locPref The current local pref that needs to be modified.
+ *
+ * @return The modified local preference (0 in case of an underflow).
+ */
+static u_int32_t srx_loc_prev_value(struct bgp* bgp, u_int32_t locPref,
+                                    int valResult)
+{
+  struct srx_local_pref* prefPolicy;
+  bool isSet;
+
+  switch (valResult)
+  {
+    case SRx_RESULT_VALID:
+      prefPolicy = &bgp->srx_val_local_pref[VAL_LOCPRF_VALID];
+      isSet = prefPolicy->is_set > 0;
+      break;
+    case SRx_RESULT_NOTFOUND:
+      prefPolicy = &bgp->srx_val_local_pref[SRx_RESULT_NOTFOUND];
+      isSet = prefPolicy->is_set > 0;
+      break;
+    case SRx_RESULT_INVALID:
+      prefPolicy = &bgp->srx_val_local_pref[VAL_LOCPRF_INVALID];
+      isSet = prefPolicy->is_set > 0;
+      break;
+    default:
+      prefPolicy = NULL;
+      isSet = false;
+  }
+
+  if (isSet)
+  {
+    if (prefPolicy->relative == 0)
+    {
+      locPref = prefPolicy->value;
+    }
+    else if (prefPolicy->relative == -1)
+    {
+      locPref = (locPref > prefPolicy->value) ? (locPref - prefPolicy->value)
+                                              : 0; // underflow
+    }
+    else
+    {
+      locPref += prefPolicy->value;
+    }
+  }
+
+  return locPref;
+}
+#endif /* USE_SRX */
+
 /* Compare two bgp route entity.  br is preferable then return 1. */
 static int
 bgp_info_cmp (struct bgp *bgp, struct bgp_info *new, struct bgp_info *exist,
@@ -344,6 +1040,12 @@ bgp_info_cmp (struct bgp *bgp, struct bg
   int internal_as_route;
   int confed_as_route;
   int ret;
+#ifdef USE_SRX
+  int use_evaluation =    srx_config_check(bgp, SRX_CONFIG_EVAL_ORIGIN)
+                       || srx_config_check(bgp, SRX_CONFIG_EVAL_PATH);
+  int new_result = 0;
+  int exist_result = 0;
+#endif /* USE_SRX */
 
   *paths_eq = 0;
 
@@ -353,6 +1055,25 @@ bgp_info_cmp (struct bgp *bgp, struct bg
   if (exist == NULL)
     return 1;
 
+#ifdef USE_SRX
+  if (use_evaluation)
+  {
+    /* 0.25 stop if ignore flag is set*/
+    // In case an update was received and declared to be ignored it is put back
+    // into the queue but still will be processed here. This is the reason why
+    // we have to double check here to assure the ignore state.
+    if (CHECK_FLAG (new->flags, BGP_INFO_IGNORE))
+    {
+      zlog_debug("Ignore update [0x%08X] in decision process!", new->updateID);
+      return 0;
+    }
+
+    // Retrieve Result
+    exist_result = srx_calc_validation_state(bgp, exist);
+    new_result   = srx_calc_validation_state(bgp, new);
+  }
+#endif /* USE_SRX */
+
   newattr = new->attr;
   existattr = exist->attr;
   newattre = newattr->extra;
@@ -379,11 +1100,38 @@ bgp_info_cmp (struct bgp *bgp, struct bg
   if (existattr->flag & ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF))
     exist_pref = existattr->local_pref;
 
+#ifdef USE_SRX
+  if (use_evaluation)
+  {
+    /* Apply srx policy for local pref manipulation if applicable */
+    new_pref   = srx_loc_prev_value(bgp, new_pref, new_result);
+    exist_pref = srx_loc_prev_value(bgp, exist_pref, exist_result);
+  }
+#endif /* USE_SRX */
+
   if (new_pref > exist_pref)
     return 1;
   if (new_pref < exist_pref)
     return 0;
 
+#ifdef USE_SRX
+  if (use_evaluation && CHECK_FLAG (bgp->srx_val_policy,
+                                    SRX_VAL_POLICY_PREFER_VALID))
+  {
+    /* 2.5. Prefer valid > everything else*/
+
+    // Prefer VALID over Everything else!
+    if ((new_result == SRx_RESULT_VALID) && (exist_result != SRx_RESULT_VALID))
+    {
+      return 1;
+    }
+    if ((new_result != SRx_RESULT_VALID) && (exist_result == SRx_RESULT_VALID))
+    {
+      return 0;
+    }
+  }
+#endif /* USE_SRX */
+
   /* 3. Local route check. We prefer:
    *  - BGP_ROUTE_STATIC
    *  - BGP_ROUTE_AGGREGATE
@@ -2010,45 +2758,302 @@ bgp_update_rsclient (struct peer *rsclie
         inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
         p->prefixlen, rsclient->host, reason);
 
-  if (ri)
-    bgp_rib_remove (rn, ri, peer, afi, safi);
+  if (ri)
+    bgp_rib_remove (rn, ri, peer, afi, safi);
+
+  bgp_unlock_node (rn);
+
+  return;
+}
+
+static void
+bgp_withdraw_rsclient (struct peer *rsclient, afi_t afi, safi_t safi,
+      struct peer *peer, struct prefix *p, int type, int sub_type,
+      struct prefix_rd *prd, u_char *tag)
+{
+  struct bgp_node *rn;
+  struct bgp_info *ri;
+  char buf[SU_ADDRSTRLEN];
+
+  if (rsclient == peer)
+    return;
+
+  rn = bgp_afi_node_get (rsclient->rib[afi][safi], afi, safi, p, prd);
+
+  /* Lookup withdrawn route. */
+  for (ri = rn->info; ri; ri = ri->next)
+    if (ri->peer == peer && ri->type == type && ri->sub_type == sub_type)
+      break;
+
+  /* Withdraw specified route from routing table. */
+  if (ri && ! CHECK_FLAG (ri->flags, BGP_INFO_HISTORY))
+    bgp_rib_withdraw (rn, ri, peer, afi, safi);
+  else if (BGP_DEBUG (update, UPDATE_IN))
+    zlog (peer->log, LOG_DEBUG,
+          "%s Can't find the route %s/%d", peer->host,
+          inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
+          p->prefixlen);
+
+  /* Unlock bgp_node_get() lock. */
+  bgp_unlock_node (rn);
+}
+
+#ifdef USE_SRX
+static void prefix_to_IPPrefix (struct prefix* src, IPPrefix* dst)
+{
+  dst->length = src->prefixlen;
+
+#ifdef HAVE_IPV6
+  dst->ip.version = GET_VERSION_OF_AF (src->family);
+  memcpy (&dst->ip.addr, &src->u, 16);
+#else
+  dst->ip.version = 4;
+  dst->ip.addr.v4.u32 = src->u.prefix4.s_addr;
+#endif
+}
+
+/**
+ * This method is responsible for filling the bgpsec data array. Currently the
+ * data blob only contains the AS path.
+ *
+ * @param info The bgp update
+ * @param bgpsec The data object to be filled.
+ */
+static BGPSecData* srx_create_bgpsec_data (struct bgp *bgp, struct bgp_info* info)
+{
+  struct attr* attr = info->attr;
+  struct assegment* pathSeg;
+  BGPSecData* bgpsec = malloc(sizeof(BGPSecData));
+  memset(bgpsec, 0, sizeof(BGPSecData));
+
+  // Fill the BGP4 path information
+  if (attr->aspath != NULL)
+  {
+    int dataIdx = 0;
+    int segIdx  = 0;
+    // take the last element in each segment. At the end the origin is
+    // written in the oas value.
+    pathSeg = attr->aspath->segments;
+    int prevSize = 0;
+
+    while (pathSeg != NULL)
+    {
+      if (pathSeg->type == AS_SEQUENCE)
+      {
+        int size = pathSeg->length * 4;
+        bgpsec->numberHops = pathSeg->length;
+        // Prepare memory
+        if (bgpsec->asPath == NULL)
+        {
+          bgpsec->asPath = malloc(size);
+        }
+        else
+        {
+          bgpsec->asPath = realloc(bgpsec->asPath, size+prevSize);
+        }
+
+        // Fill array
+        for (segIdx = 0;segIdx < pathSeg->length; segIdx++)
+        {
+          bgpsec->asPath[dataIdx++] = htonl(pathSeg->as[segIdx]);
+        }
+        prevSize += size;
+      }
+      pathSeg = pathSeg->next;
+    }
+  }
+
+  // Now Fill the BGPSEC Path Attribtue if it exists
+  if (attr->bgpsec_validationData != NULL)
+  {
+    SCA_BGP_PathAttribute* pa = (SCA_BGP_PathAttribute*)attr->bgpsec_validationData->bgpsec_path_attr;
+    int size = (pa->flags & BGP_UPD_A_FLAGS_EXT_LENGTH) > 0
+               ? ntohs(((SCA_BGPSEC_ExtPathAttribute*)pa)->attrLength)
+               : ((SCA_BGPSEC_NormPathAttribute*)pa)->attrLength;
+    if ( CHECK_FLAG(bgp->srx_config, SRX_CONFIG_EVAL_DISTR))
+    {
+    size += 4; // add flag, type, attribute length itself
+    }
+    if (bgpsec->bgpsec_path_attr == NULL)
+    {
+      bgpsec->bgpsec_path_attr = malloc(size);
+    }
+    else
+    {
+      bgpsec->bgpsec_path_attr = realloc(bgpsec->bgpsec_path_attr, size);
+    }
+    bgpsec->attr_length = size;
+    if ( CHECK_FLAG(bgp->srx_config, SRX_CONFIG_EVAL_DISTR))
+    {
+    bgpsec->afi  = ((SCA_Prefix*)attr->bgpsec_validationData->nlri)->afi;
+    bgpsec->safi = ((SCA_Prefix*)attr->bgpsec_validationData->nlri)->safi;
+    bgpsec->local_as = info->peer->local_as;
+    }
+    memcpy(bgpsec->bgpsec_path_attr, attr->bgpsec_validationData->bgpsec_path_attr,
+          size);
+  }
+
+  return bgpsec;
+}
+
+/**
+ * Frees the memory allocated by the bgpsec object.
+ *
+ * @param bgpsec the object to be freed. Including the internal data structure.
+ */
+static void srx_free_bgpsec_data (BGPSecData* bgpsec)
+{
+  // First reset the inner data
+  if (bgpsec->asPath != NULL)
+  {
+    memset(bgpsec->asPath, 0, (bgpsec->numberHops * 4));
+    free(bgpsec->asPath);
+  }
+  if (bgpsec->bgpsec_path_attr != NULL)
+  {
+    memset(bgpsec->bgpsec_path_attr, 0, bgpsec->attr_length);
+    free (bgpsec->bgpsec_path_attr);
+  }
+  memset (bgpsec, 0, sizeof(BGPSecData));
+  free(bgpsec);
+}
+
+// Use 2^28 to allow a printout formating of "+%07X" for local Id's
+// instead of %08X during 'show ip bgp'
+#define MAX_VALUE_INT 0x0FFFFFFF /* 2^28 -1 */
+static unsigned long suiLocalID = 0;
+
+/**
+ * Generate the next local ID
+ *
+ * @return the next available local id
+ */
+uint32_t getNextLocalID(void)
+{
+  if (suiLocalID < MAX_VALUE_INT ) /* MAX_REQUEST_TOKEN */
+  {
+    suiLocalID++;
+  }
+  else
+  {
+    suiLocalID = 1; /*MIN_REQUEST_TOKEN */
+  }
+
+  return suiLocalID;
+}
+
+/**
+ * This method is called to start an update verification. If the update info
+ * contains an updateID different than zero "0" the local ID MUST be greater
+ * than zero and vice versa.
+ *
+ * By default the result values are set to the default value except the default
+ *
+ * @param bgp a pointer to the bgp configuration
+ * @param info pointer to the update information
+ * @param defResult The default result provided.
+ * @param doRegisterLocalID If set then register the local ID with the info hash
+ */
+void verify_update (struct bgp *bgp, struct bgp_info *info,
+                    SRxDefaultResult* defResult, bool doRegisterLocalID)
+{
+  /* the received extend community value handling */
+  if (CHECK_FLAG (bgp->srx_ecommunity_flags, SRX_BGP_FLAG_ECOMMUNITY))
+  {
+  int retValid = -1;
+  retValid = checkEcomSRxValid(info->attr);
+
+  if(retValid >= 0 && retValid <= 3)
+  {
+    if(retValid == ECOMMUNITY_BGPSEC_VALID)
+    {
+        defResult->result.roaResult = SRx_RESULT_VALID;
+        if (BGP_DEBUG (update, UPDATE_IN))
+          zlog_debug(" Ecommunity Value [VALID] ");
+    }
+    else if(retValid == ECOMMUNITY_BGPSEC_NOT_FOUND)
+    {
+        defResult->result.roaResult = SRx_RESULT_NOTFOUND;
+        if (BGP_DEBUG (update, UPDATE_IN))
+          zlog_debug(" Ecommunity Value [NOT FOUND] ");
+    }
+    else if(retValid == ECOMMUNITY_BGPSEC_INVALID)
+    {
+        defResult->result.roaResult = SRx_RESULT_INVALID;
+        if (BGP_DEBUG (update, UPDATE_IN))
+          zlog_debug(" Ecommunity Value [INVALID] ");
+    }
+    else if(retValid == ECOMMUNITY_BGPSEC_UNDEFINED) // UNDEFINED
+    {
+        defResult->result.roaResult = SRx_RESULT_UNDEFINED;
+        if (BGP_DEBUG (update, UPDATE_IN))
+          zlog_debug(" Ecommunity VALUE AB [Undefined]");
+      }
+    }
+  }
+
+  // first use the default result value as regular result value
+  if (defResult->result.roaResult != SRx_RESULT_DONOTUSE)
+  {
+    info->val_res_ROA = defResult->result.roaResult;
+  }
+  if (defResult->result.bgpsecResult != SRx_RESULT_DONOTUSE)
+  {
+    info->val_res_BGPSEC = defResult->result.bgpsecResult;
+  }
 
-  bgp_unlock_node (rn);
 
-  return;
+  // If this update has a local ID it might need to be registered. This will be
+  // the first
+  if (info->localID > 0 && doRegisterLocalID)
+  {
+    bgp_info_register (bgp->info_lid_hash, info, info->localID);
 }
 
-static void
-bgp_withdraw_rsclient (struct peer *rsclient, afi_t afi, safi_t safi,
-      struct peer *peer, struct prefix *p, int type, int sub_type,
-      struct prefix_rd *prd, u_char *tag)
+  // Now let proxy change it if necessary
+  // Also check if connectionHanlder->established (connHandler[1])
+  // bool type must not be zero
+  if (isConnected (bgp->srxProxy))
 {
-  struct bgp_node *rn;
-  struct bgp_info *ri;
-  char buf[SU_ADDRSTRLEN];
+    as_t oas;
 
-  if (rsclient == peer)
-    return;
+    // first determine that the update is not local
+    if (info->localID != 0 || info->updateID != 0)
+    {
+      // let SRx proxy initiate validation and get the update id */
+      oas = aspath_origin_as (info->attr->aspath);
 
-  rn = bgp_afi_node_get (rsclient->rib[afi][safi], afi, safi, p, prd);
+      // Prepare the prefix
+      IPPrefix* prefix = malloc(sizeof(IPPrefix));
+      prefix_to_IPPrefix (&info->node->p, prefix);
 
-  /* Lookup withdrawn route. */
-  for (ri = rn->info; ri; ri = ri->next)
-    if (ri->peer == peer && ri->type == type && ri->sub_type == sub_type)
-      break;
+      // Generate BGPSEC data currently no data at all, here is a good place
+      // to add at least the AS path
+      BGPSecData* bgpsec = srx_create_bgpsec_data(bgp, info);
 
-  /* Withdraw specified route from routing table. */
-  if (ri && ! CHECK_FLAG (ri->flags, BGP_INFO_HISTORY))
-    bgp_rib_withdraw (rn, ri, peer, afi, safi);
-  else if (BGP_DEBUG (update, UPDATE_IN))
-    zlog (peer->log, LOG_DEBUG,
-          "%s Can't find the route %s/%d", peer->host,
-          inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
-          p->prefixlen);
 
-  /* Unlock bgp_node_get() lock. */
-  bgp_unlock_node (rn);
+      bool usePathVal = false;
+      if ( CHECK_FLAG(bgp->srx_config, SRX_CONFIG_EVAL_DISTR))
+      {
+        usePathVal = true;
+      }
+
+      verifyUpdate(bgp->srxProxy, info->localID, true, usePathVal, defResult,
+                   prefix, oas, bgpsec);
+
+      srx_free_bgpsec_data(bgpsec);
+      free(prefix);
+    }
+  }
+  // @TODO: Here is the point where we could call validate if we do not have any
+  //        connection to the SRx server and we plan to do local validation.
+  //        If not, no path validation will be performed - period.
+  // else { DO PATH VALIDATION }
+
+  // Check if update has to be ignored!
+  bgp_info_set_ignore_flag(info);
 }
+#endif /* USE_SRX */
 
 static int
 bgp_update_main (struct peer *peer, struct prefix *p, struct attr *attr,
@@ -2207,6 +3212,13 @@ bgp_update_main (struct peer *peer, stru
 	    }
 
 	  bgp_unlock_node (rn);
+#ifdef USE_SRX
+          if (attr_new->bgpsecPathAttr && (attr_new->flag & ATTR_FLAG_BIT (BGP_ATTR_BGPSEC)) )
+          {
+            UNSET_FLAG(attr_new->flag, BGP_ATTR_BGPSEC);
+            bgpsec_path_free (attr_new->bgpsecPathAttr);
+          }
+#endif
 	  bgp_attr_unintern (&attr_new);
 
 	  return 0;
@@ -2256,6 +3268,31 @@ bgp_update_main (struct peer *peer, stru
       bgp_attr_unintern (&ri->attr);
       ri->attr = attr_new;
 
+#ifdef USE_SRX
+// See BZ324: The attributes of the update will be replaced. This means the
+// update itself will get a different update id. Here reset the validation
+// data to the default data.
+      if (ri->info_hash != NULL)
+      {
+        bgp_info_unregister(ri->info_hash, ri->localID != 0 ? ri->localID == 0
+                                                            : ri->updateID);
+        ri->info_hash = NULL;
+        // remove update from SRx-server in case it has already an update ID
+        if (ri->updateID > 0)
+        {
+          deleteUpdate(bgp->srxProxy, bgp->srx_keepWindow, ri->updateID);
+          ri->updateID = 0;
+        }
+        else
+        {
+          ri->localID  = 0;
+        }
+
+        ri->val_res_ROA    = bgp->srx_default_roaVal;
+        ri->val_res_BGPSEC = bgp->srx_default_bgpsecVal;
+      }
+#endif /* USE_SRX */
+
       /* Update MPLS tag.  */
       if (safi == SAFI_MPLS_VPN)
         memcpy ((bgp_info_extra_get (ri))->tag, tag, 3);
@@ -2292,6 +3329,26 @@ bgp_update_main (struct peer *peer, stru
       /* Process change. */
       bgp_aggregate_increment (bgp, p, ri, afi, safi);
 
+#ifdef USE_SRX
+      /* Verify but this time to an already existing update where the attributes
+       * were changed. BZ324 */
+      ri->localID = getNextLocalID();
+
+      // Here use the value of community String
+      SRxDefaultResult* defRes = malloc(sizeof(SRxDefaultResult));
+      // Here fill with community string value if possible, the use as source
+      // SRxRS_IGP or a source provided by community string.
+
+      // TODO: Use Community String value if available
+      defRes->resSourceROA        = SRxRS_ROUTER;
+      defRes->resSourceBGPSEC     = SRxRS_ROUTER;
+      defRes->result.roaResult    = bgp->srx_default_roaVal;
+      defRes->result.bgpsecResult = bgp->srx_default_bgpsecVal;
+
+      verify_update (bgp, ri, defRes, true);
+      free(defRes);
+#endif /* USE_SRX */
+
       bgp_process (bgp, rn, afi, safi);
       bgp_unlock_node (rn);
 
@@ -2315,6 +3372,21 @@ bgp_update_main (struct peer *peer, stru
   new->attr = attr_new;
   new->uptime = bgp_clock ();
 
+#ifdef USE_SRX
+  if (BGP_DEBUG (bgpsec, BGPSEC_DETAIL))
+  {
+    zlog_debug("[BGPSEC] ----[%s]: ATTRIBUTE: attr:%p aspath:%p (attr interned) bpgsec:%p",\
+        __FUNCTION__, attr_new, attr_new->aspath, attr_new->bgpsecPathAttr);
+    if(attr_new->aspath && attr_new->aspath->segments)
+    zlog_debug("[BGPSEC] [as_segment:%p] as_segment_length:%d aspath_refcnt: %ld",
+        attr_new->aspath->segments, attr_new->aspath->segments->length,
+        attr_new->aspath->refcnt);
+  }
+
+  if (BGP_DEBUG (bgpsec, BGPSEC_IN) && BGP_DEBUG (bgpsec, BGPSEC_DETAIL))
+    if(attr_new->bgpsecPathAttr)
+      print_signature(attr_new->bgpsecPathAttr);
+#endif
   /* Update MPLS tag. */
   if (safi == SAFI_MPLS_VPN)
     memcpy ((bgp_info_extra_get (new))->tag, tag, 3);
@@ -2341,6 +3413,27 @@ bgp_update_main (struct peer *peer, stru
   /* Register new BGP information. */
   bgp_info_add (rn, new);
   
+#ifdef USE_SRX
+  /* Verify */
+  new->localID = getNextLocalID();
+  new->val_res_ROA     = bgp->srx_default_roaVal;
+  new->val_res_BGPSEC  = bgp->srx_default_bgpsecVal;
+
+  // Here use the value of community String
+  SRxDefaultResult* defRes = malloc(sizeof(SRxDefaultResult));
+  // Here fill with community string value if possible, the use as source
+  // SRxRS_IGP or a source provided by community string.
+
+  // TODO: Use Community String value if available
+  defRes->resSourceROA        = SRxRS_ROUTER;
+  defRes->resSourceBGPSEC     = SRxRS_ROUTER;
+  defRes->result.roaResult    = bgp->srx_default_roaVal;
+  defRes->result.bgpsecResult = bgp->srx_default_bgpsecVal;
+
+  verify_update (bgp, new, defRes, true);
+  free(defRes);
+#endif /* USE_SRX */
+
   /* route_node_get lock */
   bgp_unlock_node (rn);
 
@@ -3480,7 +4573,9 @@ bgp_static_update_main (struct bgp *bgp,
       attr_new = bgp_attr_intern (&attr_tmp);
     }
   else
+  {
     attr_new = bgp_attr_intern (&attr);
+  }
 
   for (ri = rn->info; ri; ri = ri->next)
     if (ri->peer == bgp->peer_self && ri->type == ZEBRA_ROUTE_BGP
@@ -3760,7 +4855,6 @@ bgp_static_set (struct vty *vty, struct 
 
       if (need_update)
 	bgp_static_withdraw (bgp, &p, afi, safi);
-
       if (! bgp_static->backdoor)
 	bgp_static_update (bgp, &p, bgp_static, afi, safi);
     }
@@ -5604,6 +6698,154 @@ enum bgp_display_type
   normal_list,
 };
 
+#ifdef USE_SRX
+
+
+/**
+ * Print the validation result v,i,u,?, or - depending on the state.
+ *
+ * @param vty the output terminal
+ * @param state the validation state to be printed
+ */
+static void srx_validation_vty_short_out(struct vty *vty, int state)
+{
+  switch (state)
+  {
+    case SRx_RESULT_VALID:
+      vty_out (vty, "v");
+      break;
+    case SRx_RESULT_NOTFOUND:
+      vty_out (vty, "n");
+      break;
+    case SRx_RESULT_INVALID:
+      vty_out (vty, "i");
+      break;
+    case SRx_RESULT_UNDEFINED:
+      vty_out (vty, "?");
+      break;
+    default:
+      vty_out (vty, "-");
+  }
+}
+
+/**
+ * Print the additional SRx validation information to the screen
+ *
+ * @param vty the terminal
+ * @param binfo the update information.
+ */
+static void srx_route_vty_validation_out(struct vty *vty,
+                                         struct bgp_info *binfo)
+{
+  struct bgp *bgp;
+  bgp = binfo->peer->bgp;
+  int valState = SRx_RESULT_UNDEFINED;
+  int locPrefPol = -1;
+
+  if ((bgp->srx_config & SRX_CONFIG_DISPLAY_INFO) != 0)
+  {
+    // The Ident (update id)
+    if (binfo->updateID == 0)
+    {
+      if (binfo->localID != 0)
+      {
+        vty_out (vty, "+%07X ", binfo->localID);
+      }
+      else
+      {
+        vty_out (vty, "-------- ");
+      }
+    }
+    else
+    {
+      vty_out (vty, "%08X ", binfo->updateID);
+    }
+    // Calculate the total validation state
+    valState = srx_calc_validation_state(bgp, binfo);
+    // Print the total validation result depending on the validation mode
+    srx_validation_vty_short_out(vty, valState);
+    vty_out (vty, "(");
+    if ((bgp->srx_config & SRX_CONFIG_EVAL_ORIGIN) != 0)
+    {
+      // print the origin validation
+      srx_validation_vty_short_out(vty, binfo->val_res_ROA);
+    }
+    else
+    {
+      vty_out (vty, "-");
+    }
+    vty_out (vty, ",");
+    if ((bgp->srx_config & SRX_CONFIG_EVAL_PATH) != 0)
+    {
+      // print path validation.
+      srx_validation_vty_short_out(vty, binfo->val_res_BGPSEC);
+    }
+    else
+    {
+      vty_out (vty, "-");
+    }
+    vty_out (vty, ") ");
+
+    // Determine local pref policy
+    switch (valState)
+    {
+      case SRx_RESULT_VALID:
+        locPrefPol = VAL_LOCPRF_VALID;
+        break;
+      case SRx_RESULT_NOTFOUND:
+        locPrefPol = VAL_LOCPRF_NOTFOUND;
+        break;
+      case SRx_RESULT_INVALID:
+        locPrefPol = VAL_LOCPRF_INVALID;
+        break;
+      default:
+        locPrefPol = -1;
+    }
+    if (locPrefPol > -1)
+    {
+      if (bgp->srx_val_local_pref[locPrefPol].is_set)
+      {
+        switch (bgp->srx_val_local_pref[locPrefPol].relative)
+        {
+          case -1:
+            vty_out (vty, "-");
+            break;
+          case  1:
+            vty_out (vty, "+");
+            break;
+          default:
+            vty_out (vty, " ");
+        }
+        vty_out (vty, "%4d,", bgp->srx_val_local_pref[locPrefPol].value);
+      }
+      else
+      {
+        vty_out (vty, "      ");
+      }
+    }
+    else
+    {
+      vty_out (vty, "      ");
+    }
+    vty_out (vty, "   ");
+    if (CHECK_FLAG (binfo->flags, BGP_INFO_IGNORE))
+    {
+      vty_out (vty, "I");
+    }
+    else if ((bgp->srx_config & SRX_CONFIG_EVALUATE) == 0)
+    {
+      vty_out (vty, "D");
+    }
+    else
+    {
+      vty_out (vty, " ");
+    }
+    vty_out (vty, "   ");
+  }
+}
+
+#endif /* USE_SRX */
+
 /* Print the short form route status for a bgp_info */
 static void
 route_vty_short_status_out (struct vty *vty, struct bgp_info *binfo)
@@ -5635,6 +6877,10 @@ route_vty_short_status_out (struct vty *
       vty_out (vty, "i");
     else
       vty_out (vty, " "); 
+
+#ifdef USE_SRX
+  srx_route_vty_validation_out (vty, binfo);
+#endif /* USE_SRX */
 }
 
 /* called from terminal list command */
@@ -5687,10 +6933,68 @@ route_vty_out (struct vty *vty, struct p
       else
 	vty_out (vty, "          ");
 
+#ifdef USE_SRX
+      // Determine srx policy local pref
+      struct bgp* bgp = binfo->peer->bgp;
+      int srxResult = srx_calc_validation_state(bgp, binfo);
+      struct srx_local_pref* srxLocPref;
+      int srxDoLocPref;
+
+      if (bgp != NULL)
+      {
+        switch (srxResult)
+        {
+          case SRx_RESULT_VALID:
+            srxLocPref = &bgp->srx_val_local_pref[VAL_LOCPRF_VALID];
+            srxDoLocPref = 1; break;
+          case SRx_RESULT_NOTFOUND:
+            srxLocPref = &bgp->srx_val_local_pref[VAL_LOCPRF_NOTFOUND];
+            srxDoLocPref = 1; break;
+          case SRx_RESULT_INVALID:
+            srxLocPref = &bgp->srx_val_local_pref[VAL_LOCPRF_INVALID];
+            srxDoLocPref = 1; break;
+          default:
+            srxDoLocPref = 0;
+            srxLocPref = NULL;
+        }
+      }
+     else
+      {
+        srxDoLocPref = 0;
+        srxLocPref = NULL;
+      }
+#endif /* USE_SRX */
+
       if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF))
+#ifdef USE_SRX
+      {
+        if (srxDoLocPref)
+        {
+          vty_out (vty, "%7ua", srxLocPref->relative
+            ? attr->local_pref + srxLocPref->relative * srxLocPref->value
+            : srxLocPref->value);
+        }
+        else
+        {
 	vty_out (vty, "%7u", attr->local_pref);
+        }
+#else /* USE_SRX */
+	vty_out (vty, "%7u", attr->local_pref);
+#endif /* USE_SRX */
+
+#ifdef USE_SRX
+      }
+      else if (srxDoLocPref && srxLocPref->is_set)
+      {
+        vty_out (vty, "%7us", srxLocPref->value);
+      }
+#endif /* USE_SRX */
       else
+#ifdef USE_SRX
 	vty_out (vty, "       ");
+#else /* USE_SRX */
+	vty_out (vty, "       ");
+#endif /* USE_SRX */
 
       vty_out (vty, "%7u ", (attr->extra ? attr->extra->weight : 0));
     
@@ -5931,6 +7235,158 @@ flap_route_vty_out (struct vty *vty, str
   vty_out (vty, "%s", VTY_NEWLINE);
 }
 
+#ifdef USE_SRX
+
+/**
+ * Print the SRx validation details of the given route on the terminal.
+ *
+ * @param vty The terminal
+ * @param bgp The bgp router instance
+ * @param binfo The route information.
+ */
+static void srx_route_vty_out_detail(struct vty *vty, struct bgp *bgp,
+                                     struct bgp_info *binfo)
+{
+  static const char *INDEX_STR[4] =
+  {
+    "valid",
+    "notfound",
+    "invalid",
+    "undefined"       // might be removed again
+  };
+
+  vty_out (vty, "    SRx Information:%s", VTY_NEWLINE);
+  vty_out (vty, "      Update ID: 0x%08X%s", binfo->updateID, VTY_NEWLINE);
+  if (CHECK_FLAG(bgp->srx_config, SRX_CONFIG_EVAL_ORIGIN))
+  {
+    if (CHECK_FLAG (binfo->flags, BGP_INFO_IGNORE))
+    {
+      vty_out (vty, "      This update will be ignored!%s",VTY_NEWLINE);
+    }
+    if (aspath_count_hops (binfo->attr->aspath) == 0)
+    {
+      vty_out (vty, "      Internal update, no policy processing performed!!%s",
+               VTY_NEWLINE);
+    }
+    else
+    {
+      vty_out (vty, "      Validation:%s", VTY_NEWLINE);
+      vty_out (vty, "        prefix-origin: %s%s", INDEX_STR[binfo->val_res_ROA],
+                                             VTY_NEWLINE);
+      if (CHECK_FLAG(bgp->srx_config, SRX_CONFIG_EVAL_PATH))
+      {
+        vty_out (vty, "        path:   %s%s", INDEX_STR[binfo->val_res_BGPSEC],
+                                        VTY_NEWLINE);
+        vty_out (vty, "        bgpsec: %s  (combination of prefix-origin and "
+                      "path validation)%s",
+                      INDEX_STR[srx_calc_validation_state(bgp, binfo)],
+                      VTY_NEWLINE);
+      }
+      else
+      {
+        vty_out (vty, "        path:          processing disabled!%s",
+                      VTY_NEWLINE);
+      }
+    }
+
+    // Add BGPSEC information
+    vty_out (vty, "      PathType: ");
+    if (!binfo->attr->bgpsecPathAttr)
+    {
+      vty_out (vty, "AS-PATH%s", VTY_NEWLINE);
+    }
+    else
+    {
+      struct PathSegment* pathSegment;
+      struct SigBlock *sigBlock;
+      struct SigSegment *sigSegment1;
+      struct SigSegment *sigSegment2;
+
+      int blockCounter=0;
+      int segCounter=0;
+
+      pathSegment = binfo->attr->bgpsecPathAttr->pathSegments;
+      sigBlock    = binfo->attr->bgpsecPathAttr->sigBlocks;
+
+      // Determine the number of path segments by counting the number of
+      // path segments
+      while (pathSegment)
+      {
+        segCounter++;
+        pathSegment = pathSegment->next;
+      }
+
+       // Determine the number of signature blocks
+      sigBlock = binfo->attr->bgpsecPathAttr->sigBlocks;
+      blockCounter=0;
+      while (sigBlock)
+      {
+        blockCounter++;
+        sigBlock = sigBlock->next;
+      }
+
+      vty_out (vty, "BGPSEC-Path ( %d signature blocks, each with %d path "
+                     "segments)%s", blockCounter, segCounter, VTY_NEWLINE);
+
+      sigBlock    = binfo->attr->bgpsecPathAttr->sigBlocks;
+      pathSegment = binfo->attr->bgpsecPathAttr->pathSegments;
+      sigSegment1 = sigBlock->sigSegments;
+      sigSegment2 = (sigBlock->next) ? sigBlock->next->sigSegments : NULL;
+
+      // Now print information about each block and its segments:
+      while(sigBlock)
+      {
+        vty_out (vty, "        signature block #%d: algorithm suite id %d%s",
+                      blockCounter, sigBlock->algoSuiteId, VTY_NEWLINE);
+        sigBlock = sigBlock->next;
+      }
+
+      // Now walk through the path segments and display them incl. signatures
+      segCounter=0;
+      pathSegment = binfo->attr->bgpsecPathAttr->pathSegments;
+      while (pathSegment)
+      {
+        segCounter++;
+        vty_out (vty, "        path segment %d: as=%d; pcount=%d%s", segCounter,
+                      pathSegment->as, pathSegment->pCount, VTY_NEWLINE);
+        pathSegment = pathSegment->next;
+
+
+        int i;
+        if (sigSegment1)
+        {
+          vty_out (vty, "          signature segment [%d]: block 1, ski=",
+                        segCounter);
+          for (i=0; i < 20; i++)
+          {
+            vty_out (vty, "%02X", sigSegment1->ski[i]);
+          }
+          vty_out (vty, "%s", VTY_NEWLINE);
+          sigSegment1 = sigSegment1->next;
+        }
+
+        if (sigSegment2)
+        {
+          vty_out (vty, "          signature segment [%d]: block 2, ski=",
+                        segCounter);
+          for (i=0; i < 20; i++)
+          {
+            vty_out (vty, "%02X", sigSegment2->ski[i]);
+          }
+          vty_out (vty, "%s", VTY_NEWLINE);
+          sigSegment2 = sigSegment2->next;
+        }
+      }
+    }
+  }
+  else
+  {
+	  vty_out (vty, "      SRx evaluation is deactivated, validation results "
+                  "are ignored!%s", VTY_NEWLINE);
+  }
+}
+#endif /* USE_SRX */
+
 static void
 route_vty_out_detail (struct vty *vty, struct bgp *bgp, struct prefix *p, 
 		      struct bgp_info *binfo, afi_t afi, safi_t safi)
@@ -5975,6 +7431,14 @@ route_vty_out_detail (struct vty *vty, s
 	vty_out (vty, ", (suppressed due to dampening)");
       vty_out (vty, "%s", VTY_NEWLINE);
 	  
+#ifdef USE_SRX
+      /* Line1.5 display SRx information */
+  if (CHECK_FLAG(bgp->srx_config, SRX_CONFIG_DISPLAY_INFO))
+  {
+    srx_route_vty_out_detail(vty, bgp, binfo);
+  }
+#endif /* USE_SRX */
+
       /* Line2 display Next-hop, Neighbor, Router-id */
       if (p->family == AF_INET)
 	{
@@ -6112,6 +7576,14 @@ route_vty_out_detail (struct vty *vty, s
   vty_out (vty, "%s", VTY_NEWLINE);
 }  
 
+#ifdef USE_SRX
+#define BGP_SRX_SHOW_SCODE_HEADER "Validation:    v - valid, n - notfound, i - invalid, ? - undefined%s" \
+                                  "SRx Status:    I - route ignored, D - SRx evaluation deactivated%s" \
+                                  "SRxVal Format: validation result (origin validation, path validation)%s"
+//#define BGP_SRX_SHOW_HEADER       "   SRx Data      Network          Next Hop            Metric  LocPrf Weight Path%s"
+#define BGP_SRX_SHOW_HEADER       "   Ident    SRxVal SRxLP Status Network          Next Hop            Metric  LocPrf Weight Path%s"
+//                                    12345678 i(v,i) +1000   I
+#endif /* USE_SRX */
 #define BGP_SHOW_SCODE_HEADER "Status codes: s suppressed, d damped, h history, * valid, > best, i - internal,%s              r RIB-failure, S Stale, R Removed%s"
 #define BGP_SHOW_OCODE_HEADER "Origin codes: i - IGP, e - EGP, ? - incomplete%s%s"
 #define BGP_SHOW_HEADER "   Network          Next Hop            Metric LocPrf Weight Path%s"
@@ -6157,6 +7629,10 @@ bgp_show_table (struct vty *vty, struct 
   int display;
   unsigned long output_count;
 
+#ifdef USE_SRX
+  int displaySRX = 0;
+#endif /* USE_SRX */
+
   /* This is first entry point, so reset total line. */
   output_count = 0;
 
@@ -6316,6 +7792,18 @@ bgp_show_table (struct vty *vty, struct 
 	      {
 		vty_out (vty, "BGP table version is 0, local router ID is %s%s", inet_ntoa (*router_id), VTY_NEWLINE);
 		vty_out (vty, BGP_SHOW_SCODE_HEADER, VTY_NEWLINE, VTY_NEWLINE);
+#ifdef USE_SRX
+    if (CHECK_FLAG(ri->peer->bgp->srx_config, SRX_CONFIG_DISPLAY_INFO))
+    {
+      displaySRX = 1;
+      vty_out (vty, BGP_SRX_SHOW_SCODE_HEADER, VTY_NEWLINE, VTY_NEWLINE,
+                    VTY_NEWLINE);
+    }
+    else
+    {
+      displaySRX = 0;
+    }
+#endif /* USE_SRX */
 		vty_out (vty, BGP_SHOW_OCODE_HEADER, VTY_NEWLINE, VTY_NEWLINE);
 		if (type == bgp_show_type_dampend_paths
 		    || type == bgp_show_type_damp_neighbor)
@@ -6332,7 +7820,20 @@ bgp_show_table (struct vty *vty, struct 
 			 || type == bgp_show_type_flap_neighbor)
 		  vty_out (vty, BGP_SHOW_FLAP_HEADER, VTY_NEWLINE);
 		else
+#ifdef USE_SRX
+    {
+      if (displaySRX)
+      {
+        vty_out (vty, BGP_SRX_SHOW_HEADER, VTY_NEWLINE);
+      }
+      else
+      {
+  		  vty_out (vty, BGP_SHOW_HEADER, VTY_NEWLINE);
+      }
+    }
+#else /* USE_SRX */
 		  vty_out (vty, BGP_SHOW_HEADER, VTY_NEWLINE);
+#endif /* USE_SRX */
 		header = 0;
 	      }
 
@@ -9593,6 +11094,9 @@ enum bgp_pcounts
   PCOUNT_HISTORY,
   PCOUNT_STALE,
   PCOUNT_VALID,
+#ifdef USE_SRX
+  PCOUNT_IGNORE,
+#endif /* USE_SRX */
   PCOUNT_ALL,
   PCOUNT_COUNTED,
   PCOUNT_PFCNT, /* the figure we display to users */
@@ -9607,6 +11111,9 @@ static const char *pcount_strs[] =
   [PCOUNT_HISTORY] = "History",
   [PCOUNT_STALE]   = "Stale",
   [PCOUNT_VALID]   = "Valid",
+#ifdef USE_SRX
+  [PCOUNT_IGNORE]  = "Ignore",
+#endif /* USE_SRX */
   [PCOUNT_ALL]     = "All RIB",
   [PCOUNT_COUNTED] = "PfxCt counted",
   [PCOUNT_PFCNT]   = "Useable",
@@ -9655,6 +11162,12 @@ bgp_peer_count_walker (struct thread *t)
             pc->count[PCOUNT_STALE]++;
           if (CHECK_FLAG (ri->flags, BGP_INFO_VALID))
             pc->count[PCOUNT_VALID]++;
+          #ifdef USE_SRX
+          if (CHECK_FLAG (ri->flags, BGP_INFO_IGNORE))
+          {
+            pc->count[PCOUNT_IGNORE]++;
+          }
+          #endif /* USE_SRX */
           if (!CHECK_FLAG (ri->flags, BGP_INFO_UNUSEABLE))
             pc->count[PCOUNT_PFCNT]++;
           
@@ -13110,6 +14623,11 @@ bgp_route_init (void)
   install_element (BGP_IPV6_NODE, &ipv6_bgp_network_ttl_cmd);
   install_element (BGP_IPV6_NODE, &no_ipv6_bgp_network_ttl_cmd);
 #endif
+
+#ifdef USE_SRX
+  thread_add_event (bm->master, initUnSocket, NULL, 0);
+#endif /* USE_SRX */
+
 }
 
 void
--- ./bgpd/bgp_packet.c	2013-02-01 11:55:27.000000000 -0500
+++ ./bgpd/bgp_packet.c	2017-06-26 15:53:49.000000000 -0400
@@ -19,6 +19,9 @@ Software Foundation, Inc., 59 Temple Pla
 02111-1307, USA.  */
 
 #include <zebra.h>
+#ifdef USE_SRX
+#include <srx/srxcryptoapi.h>
+#endif
 
 #include "thread.h"
 #include "stream.h"
@@ -137,6 +140,59 @@ bgp_connect_check (struct peer *peer)
     }
 }
 
+#ifdef USE_SRX
+struct ecommunity* srxEcommunityChange(struct bgp *bgp, struct attr *attr, struct bgp_info *binfo)
+{
+  struct attr_extra *attre = attr->extra;
+  struct ecommunity *ecom=NULL, *ecom_orig=NULL;
+  unsigned int state;
+
+  switch(binfo->val_res_ROA)
+  {
+    case ECOMMUNITY_BGPSEC_VALID:
+      state = ECOMMUNITY_BGPSEC_VALID; break;
+    case ECOMMUNITY_BGPSEC_NOT_FOUND:
+      state = ECOMMUNITY_BGPSEC_NOT_FOUND; break;
+    case ECOMMUNITY_BGPSEC_INVALID:
+      state = ECOMMUNITY_BGPSEC_INVALID; break;
+    default:
+      state = ECOMMUNITY_BGPSEC_NOT_FOUND; break;
+  }
+
+  if(attre)
+  {
+    ecom = ecommunity_bgpsec_str2com (bgp->srx_ecommunity_subcode, state);
+    attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES);
+    ecom_orig = attre->ecommunity;
+    attre->ecommunity = ecom;
+  }
+  else
+    return NULL;
+
+  return ecom_orig;
+}
+
+int srxEcommunityRestore(struct attr *attr, struct ecommunity* ecom_orig)
+{
+  struct attr_extra *attre = attr->extra;
+  struct ecommunity *ecom=NULL;
+  int ret=0;
+
+  if(attre && attre->ecommunity && (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES)))
+  {
+    attr->flag &= ~(ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES));
+    ecom = attre->ecommunity;
+    attre->ecommunity = ecom_orig;
+    ret = 1;
+  }
+
+  if(ecom)
+    free(ecom);
+
+  return ret;
+}
+#endif
+
 /* Make BGP update packet.  */
 static struct stream *
 bgp_update_packet (struct peer *peer, afi_t afi, safi_t safi)
@@ -149,6 +205,17 @@ bgp_update_packet (struct peer *peer, af
   struct bgp_info *binfo = NULL;
   bgp_size_t total_attr_len = 0;
   unsigned long pos;
+#ifdef USE_SRX
+  u_char bFrag =0;
+
+  // By default we assume the update will be send out using BGPSEC. the
+  // function bgp_packer_attribute will do the final decision and return
+  // the final result back. For now we assume we do BGPSEC and NOT AS_PATH
+
+  /* This value stay here, otherwise it will affect BGPv4 packing which
+   * is to put prefixes into the stream */
+  bool useASpath = false;
+#endif
 
   s = peer->work;
   stream_reset (s);
@@ -163,6 +230,18 @@ bgp_update_packet (struct peer *peer, af
       if (adv->binfo)
         binfo = adv->binfo;
 
+#ifdef USE_SRX
+    if (!CHECK_FLAG(peer->cap, PEER_CAP_EXTENDED_MSG_SUPPORT)
+        && STREAM_REMAIN(s) > BGP_MAX_PACKET_SIZE)
+    {
+      size_t oldsize, newsize = BGP_MAX_PACKET_SIZE;
+      newsize = stream_resize (s, newsize);
+    }
+    if (BGP_DEBUG (bgpsec, BGPSEC_DETAIL))
+      zlog_debug("[BGPSEC] [%s] stream remain:%d prefix size: %d rn->p:%08x attr:%p ",
+                 __FUNCTION__, STREAM_REMAIN (s),  PSIZE (rn->p.prefixlen),
+                 rn->p.u.prefix4, adv->baa->attr);
+#endif
       /* When remaining space can't include NLRI and it's length.  */
       if (STREAM_REMAIN (s) <= BGP_NLRI_LENGTH + PSIZE (rn->p.prefixlen))
 	break;
@@ -187,13 +266,35 @@ bgp_update_packet (struct peer *peer, af
 	  stream_putw (s, 0);		
 	  pos = stream_get_endp (s);
 	  stream_putw (s, 0);
+#ifdef USE_SRX
+      struct ecommunity *ecom_orig;
+      if (CHECK_FLAG (peer->bgp->srx_ecommunity_flags,  SRX_BGP_FLAG_ECOMMUNITY))
+        ecom_orig = srxEcommunityChange(peer->bgp, adv->baa->attr, binfo);
+      total_attr_len = bgp_packet_attribute (NULL, peer, s,
+                                             adv->baa->attr,
+                                             &rn->p, afi, safi,
+                                             from, prd, tag, &useASpath);
+#else
 	  total_attr_len = bgp_packet_attribute (NULL, peer, s, 
 	                                         adv->baa->attr,
 	                                         &rn->p, afi, safi, 
 	                                         from, prd, tag);
+#endif
 	  stream_putw_at (s, pos, total_attr_len);
+#ifdef USE_SRX
+      if (CHECK_FLAG (peer->bgp->srx_ecommunity_flags,  SRX_BGP_FLAG_ECOMMUNITY))
+        bFrag = srxEcommunityRestore(adv->baa->attr, ecom_orig);
+#endif
 	}
 
+#ifdef USE_SRX
+    // @NOTE: The line below does not considder all IBGP situations. In some,
+    // we need to send the prefix (origin) in others we forward the received
+    // one. There we need to use the MP_NLRI.
+    // if ( !CHECK_FLAG (peer->flags, PEER_FLAG_BGPSEC_MPE_IPV4) )
+    if (useASpath)
+    // What this means is only use the prefix list if an as path was written.
+#endif
       if (afi == AFI_IP && safi == SAFI_UNICAST)
 	stream_put_prefix (s, &rn->p);
       
@@ -209,16 +310,106 @@ bgp_update_packet (struct peer *peer, af
 
       /* Synchnorize attribute.  */
       if (adj->attr)
+    {
 	bgp_attr_unintern (&adj->attr);
+    }
       else
 	peer->scount[afi][safi]++;
 
       adj->attr = bgp_attr_intern (adv->baa->attr);
 
+#ifdef USE_SRX
+    if (BGP_DEBUG (bgpsec, BGPSEC_DETAIL))
+      zlog_debug("[BGPSEC] [%s] (after intern) adj->attr:%p bgpsec attr:%p ",\
+          __FUNCTION__, adj->attr, adj->attr->bgpsecPathAttr );
+#endif
+
       adv = bgp_advertise_clean (peer, adj, afi, safi);
 
       if (! (afi == AFI_IP && safi == SAFI_UNICAST))
 	break;
+
+#ifdef USE_SRX
+    if ( CHECK_FLAG (peer->flags, PEER_FLAG_BGPSEC_MPE_IPV4) )
+      break;
+
+    struct peer *from = NULL;
+    u_char bDoNotFrag =0;
+    if (binfo)
+    {
+      from = binfo->peer;
+      if (from)
+      {
+        /* if and only if, the peer's recv capability set and this node's send capability set,
+         * BGPSec Update message can be sent to the peer */
+        if( (CHECK_FLAG (peer->flags, PEER_FLAG_BGPSEC_CAPABILITY_SEND) \
+              && CHECK_FLAG (peer->cap, PEER_CAP_BGPSEC_ADV)) )
+        {
+          /* debug */
+          if (BGP_DEBUG (bgpsec, BGPSEC_DETAIL))
+          {
+            zlog_debug("[BGPSEC] from:%p from->as:%d from->cap:%04x",
+                       from, from->as, from->cap);
+          }
+
+          /* in case, when the previous(from) node sends to the current node which is connected
+           * to the next node(peer), to determine whether to send BGPSec or BGPv4 */
+          if (from->as >0 && from->as != peer->as)
+          {
+            if (!CHECK_FLAG (from->cap, PEER_CAP_BGPSEC_ADV_SEND)
+                || !CHECK_FLAG (from->flags, PEER_FLAG_BGPSEC_CAPABILITY_RECV))
+            {
+              bDoNotFrag =1;   // fragmentation set
+            }
+          }
+        }
+      }
+    }
+
+    /*
+     * only if bgpsec enabled and the from-peer has joined the bgpsec
+     * or in case of sending ecommunity string to its peer
+     */
+    if (   (CHECK_FLAG (peer->flags, PEER_FLAG_BGPSEC_CAPABILITY_SEND)
+            && CHECK_FLAG (peer->cap, PEER_CAP_BGPSEC_ADV))
+        || ((CHECK_FLAG (peer->bgp->srx_ecommunity_flags, SRX_BGP_FLAG_ECOMMUNITY))
+            && bFrag && from))
+    {
+// @NOTE: This will be redone in the next run through.
+      if (bDoNotFrag)
+        goto donot_frag;
+
+      /* in case, received BGPv4 Update from the previous node of the previous peer or more preivou in turn.
+       * If 'aspath->segments' exists, it means 'attr' comes from the peer node
+       * If 'attr->bgpsecPathAttr' NOT exists, it means attr doesn't include BGPSec Update
+       * */
+// @NOTE: This will be redone in the next run through.
+      if (adj->attr->aspath && adj->attr->aspath->segments &&
+          adj->attr->aspath->segments->length > 0 && !adj->attr->bgpsecPathAttr)
+        goto donot_frag;
+
+      size_t cp = stream_get_getp(s);
+      stream_set_getp (s, BGP_MARKER_SIZE + 2);
+      u_char type = stream_getc (s);
+      stream_set_getp(s, cp); // rewind
+
+      /* BGP_UPDATE fragmentation */
+      if (type == BGP_MSG_UPDATE)
+      {
+        bgp_packet_set_size (s);
+        packet = stream_dup (s);
+        bgp_packet_add (peer, packet);
+        if (BGP_DEBUG (bgpsec, BGPSEC_DETAIL))
+          zlog_debug("*** Update Message Fragmentation ON (to peer:%d)*** ", peer->as);
+        BGP_WRITE_ON (peer->t_write, bgp_write, peer->fd);
+        stream_reset (s);
+        return packet;
+      }
+    }
+// @NOTE: This will be redone in the next run through.
+donot_frag:
+    bDoNotFrag = 0;
+#endif /* USE-SRX */
     }
 	 
   if (! stream_empty (s))
@@ -407,11 +598,20 @@ bgp_default_update_send (struct peer *pe
   /* Make place for total attribute length.  */
   pos = stream_get_endp (s);
   stream_putw (s, 0);
+#ifdef USE_SRX
+  bool fUsedAspath = false;
+  total_attr_len = bgp_packet_attribute (NULL, peer, s, attr, &p, afi, safi,
+                                         from, NULL, NULL, &fUsedAspath);
+#else
   total_attr_len = bgp_packet_attribute (NULL, peer, s, attr, &p, afi, safi, from, NULL, NULL);
+#endif
 
   /* Set Total Path Attribute Length. */
   stream_putw_at (s, pos, total_attr_len);
 
+#ifdef USE_SRX
+  if (fUsedAspath)
+#endif
   /* NLRI set. */
   if (p.family == AF_INET && safi == SAFI_UNICAST)
     stream_put_prefix (s, &p);
@@ -553,6 +753,7 @@ bgp_write_packet (struct peer *peer)
 		  }
 		else
 		  s = bgp_update_packet (peer, afi, safi);
+
 	      }
 
 	    if (s)
@@ -665,6 +866,14 @@ bgp_write (struct thread *thread)
 	  break;
 	case BGP_MSG_UPDATE:
 	  peer->update_out++;
+#ifdef USE_SRX
+          sockopt_cork (peer->fd, 0);
+          if (BGP_DEBUG (bgpsec, BGPSEC_DETAIL))
+            zlog_debug("[BGPSEC] update packet couter: %d", count);
+          //
+          // TODO: considering 'count' option if update  msg exceeds the bound
+          //
+#endif
 	  break;
 	case BGP_MSG_NOTIFY:
 	  peer->notify_out++;
@@ -705,6 +914,7 @@ bgp_write (struct thread *thread)
   return 0;
 }
 
+
 /* This is only for sending NOTIFICATION message to neighbor. */
 static int
 bgp_write_notify (struct peer *peer)
@@ -2482,9 +2692,43 @@ bgp_read (struct thread *thread)
 				     &type, 1);
 	  goto done;
 	}
+
+
+#ifdef USE_SRX
+      bgp_size_t size_policy;
+      if (CHECK_FLAG (peer->flags, PEER_FLAG_EXTENDED_MESSAGE_SUPPORT))
+      {
+        /* extended message support - strict policy */
+        if (CHECK_FLAG (peer->cap, PEER_CAP_EXTENDED_MSG_SUPPORT))
+        {
+          size_policy = BGP_MAX_PACKET_SIZE_EXTENDED;
+        }
+        else
+        {
+          /* extended message support - liberal policy */
+          if (CHECK_FLAG (peer->flags, PEER_FLAG_EXTENDED_MESSAGE_LIBERAL))
+          {
+            size_policy = BGP_MAX_PACKET_SIZE_EXTENDED;
+          }
+          else
+            size_policy = BGP_MAX_PACKET_SIZE;
+
+        }
+      }
+      else
+        size_policy = BGP_MAX_PACKET_SIZE;
+#endif
+
+
+
+
       /* Mimimum packet length check. */
       if ((size < BGP_HEADER_SIZE)
+#ifdef USE_SRX
+	  || (size > size_policy)
+#else
 	  || (size > BGP_MAX_PACKET_SIZE)
+#endif
 	  || (type == BGP_MSG_OPEN && size < BGP_MSG_OPEN_MIN_SIZE)
 	  || (type == BGP_MSG_UPDATE && size < BGP_MSG_UPDATE_MIN_SIZE)
 	  || (type == BGP_MSG_NOTIFY && size < BGP_MSG_NOTIFY_MIN_SIZE)
@@ -2566,3 +2810,20 @@ bgp_read (struct thread *thread)
     }
   return 0;
 }
+
+#ifdef USE_SRX
+int bgp_read2 (struct thread *thread)
+{
+
+  struct peer *peer;
+
+  /* Yes first of all get peer pointer. */
+  peer = THREAD_ARG (thread);
+  peer->t_read = NULL;
+
+
+    zlog_debug(" event read2 ---------\n");
+    BGP_READ_ON (peer->t_read, bgp_read2, peer->fd);
+    return 0;
+}
+#endif /* USE_SRX */
--- ./bgpd/bgp_debug.h	2012-11-08 11:41:48.000000000 -0500
+++ ./bgpd/bgp_debug.h	2017-06-26 15:53:49.000000000 -0400
@@ -77,6 +77,9 @@ extern unsigned long term_bgp_debug_keep
 extern unsigned long term_bgp_debug_update;
 extern unsigned long term_bgp_debug_normal;
 extern unsigned long term_bgp_debug_zebra;
+#ifdef USE_SRX
+extern unsigned long term_bgp_debug_bgpsec;
+#endif
 
 #define BGP_DEBUG_AS4                 0x01
 #define BGP_DEBUG_AS4_SEGMENT         0x02
@@ -90,6 +93,12 @@ extern unsigned long term_bgp_debug_zebr
 #define BGP_DEBUG_UPDATE_OUT          0x02
 #define BGP_DEBUG_NORMAL              0x01
 #define BGP_DEBUG_ZEBRA               0x01
+#ifdef USE_SRX
+#define BGP_DEBUG_BGPSEC_DETAIL       0x01
+#define BGP_DEBUG_BGPSEC              0x01 // alias of the bgpsec detail
+#define BGP_DEBUG_BGPSEC_IN           0x02
+#define BGP_DEBUG_BGPSEC_OUT          0x04
+#endif
 
 #define BGP_DEBUG_PACKET_SEND         0x01
 #define BGP_DEBUG_PACKET_SEND_DETAIL  0x02
--- ./bgpd/bgp_network.c	2013-01-26 21:25:34.000000000 -0500
+++ ./bgpd/bgp_network.c	2017-06-26 15:53:49.000000000 -0400
@@ -196,6 +196,23 @@ bgp_accept (struct thread *thread)
     peer->v_holdtime = peer1->v_holdtime;
     peer->v_keepalive = peer1->v_keepalive;
 
+#ifdef USE_SRX
+    if (CHECK_FLAG (peer1->flags, PEER_FLAG_EXTENDED_MESSAGE_SUPPORT))
+    {
+      if(stream_get_size (peer1->ibuf) > BGP_MAX_PACKET_SIZE)
+        stream_resize (peer->ibuf, BGP_MAX_PACKET_SIZE_EXTENDED);
+
+      if(CHECK_FLAG(peer1->cap, PEER_CAP_EXTENDED_MSG_SUPPORT)
+          && (stream_get_size (peer1->work) > BGP_MAX_PACKET_SIZE))
+        stream_resize (peer->work, BGP_MAX_PACKET_SIZE_EXTENDED);
+
+      if(!CHECK_FLAG(peer1->cap, PEER_CAP_EXTENDED_MSG_SUPPORT))
+        if (CHECK_FLAG (peer1->flags, PEER_FLAG_EXTENDED_MESSAGE_LIBERAL))
+          if(stream_get_size (peer1->ibuf) > BGP_MAX_PACKET_SIZE)
+            stream_resize (peer->ibuf, BGP_MAX_PACKET_SIZE_EXTENDED);
+    }
+#endif
+
     /* Make peer's address string. */
     sockunion2str (&su, buf, SU_ADDRSTRLEN);
     peer->host = XSTRDUP (MTYPE_BGP_PEER_HOST, buf);
--- ./bgpd/bgp_info_hash.h	1969-12-31 19:00:00.000000000 -0500
+++ ./bgpd/bgp_info_hash.h	2017-06-26 15:53:49.000000000 -0400
@@ -0,0 +1,69 @@
+/**
+ * This software was developed at the National Institute of Standards and
+ * Technology by employees of the Federal Government in the course of
+ * their official duties. Pursuant to title 17 Section 105 of the United
+ * States Code this software is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * NIST assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the software is used.
+ * 
+ * NIST ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS SOFTWARE.
+ * 
+ * This software might use libraries that are under GNU public license or
+ * other licenses. Please refer to the licenses of all libraries required 
+ * by this software.
+ *
+ * Various function to make debugging easier.
+ *
+ * @version 0.3.1.0
+ *
+ * Changelog:
+ * -----------------------------------------------------------------------------
+ * 0.3.1.0 - 2015/11/26 - oborchert
+ *            * Added Changelog
+ *            * Changed include of uthash.h from local to stock
+ */
+#include <zebra.h>
+
+#ifndef _QUAGGA_BGP_INFO_HASH_H
+#define _QUAGGA_BGP_INFO_HASH_H
+
+#ifdef USE_SRX
+
+#include <uthash.h>
+
+struct bgp_info_hash_item {
+  uint32_t        identifier;
+  struct bgp_info *info;
+  UT_hash_handle  hh;
+};
+
+struct bgp_info_hash {
+  struct bgp_info_hash_item *table;
+};
+
+
+/* Install VTY commands - call only once */
+extern void bgp_all_info_hashes_init (void);
+
+/* Create and destroy a info hash */
+extern struct bgp_info_hash* bgp_info_hash_init (void);
+extern void bgp_info_hash_finish (struct bgp_info_hash **);
+
+/* Access the hash */
+/* 1 = registered, 0 = known identifier, -1 = error */
+extern int bgp_info_register (struct bgp_info_hash *, struct bgp_info *,
+                              uint32_t);
+extern void bgp_info_unregister (struct bgp_info_hash *, uint32_t);
+extern struct bgp_info * bgp_info_fetch (struct bgp_info_hash *, uint32_t);
+
+#endif /* USE_SRX */
+
+#endif /* !_QUAGGA_BGP_INFO_HASH_H */
+
--- ./bgpd/bgp_validate.h	1969-12-31 19:00:00.000000000 -0500
+++ ./bgpd/bgp_validate.h	2017-06-26 15:53:49.000000000 -0400
@@ -0,0 +1,267 @@
+/**
+ * This software was developed at the National Institute of Standards and
+ * Technology by employees of the Federal Government in the course of
+ * their official duties. Pursuant to title 17 Section 105 of the United
+ * States Code this software is not subject to copyright protection and
+ * is in the public domain.
+ *
+ * NIST assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ *
+ * We would appreciate acknowledgment if the software is used.
+ *
+ * NIST ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS SOFTWARE.
+ *
+ * Provides functionality for BGPSEC path validation.
+ *
+ * @version 0.4.2.0
+ * 
+ * ChangeLog:
+ * -----------------------------------------------------------------------------
+ *   0.4.2.0 - 2016/06/14 - oborchert
+ *             * Added documentation to functions and modified the parameters
+ *               slightly.
+ *             * Added free_SCAHashMessage
+ *             * Renamed bgpsecPathAttribute to constructBGPSecPathAttribute to
+ *               be more self explanatory.
+ *   0.1.4.3 - 2015/10/09 - oborchert
+ *             * NIST Header applied.
+ *   0.1.0.0 - 2015 - kyehwanl
+ *             * File Generated.
+ */
+#ifndef _QUAGGA_BGP_VALIDATE_H
+#define _QUAGGA_BGP_VALIDATE_H
+
+#ifdef USE_SRX
+
+#define BGPSEC_SKI_LENGTH           20
+#define BGPSEC_ALGO_ID              1
+#define BGPSEC_ALGO_ID_LENGTH       1
+#define BGPSEC_MAX_SIG_LENGTH       128
+#define BGPSEC_AFI_LENGTH           1
+#define BGPSEC_MAX_INFO_ATTR_LENGTH 0
+
+
+#define BGPSEC_SUCCESS 0
+#define BGPSEC_FAILURE -1
+
+#define BGPSEC_ALGORITHM_SHA256_ECDSA_P_256 1
+#define BGPSEC_OPENSSL_ID_SHA256_ECDSA_P_256 NID_X9_62_prime256v1
+#define BGPSEC_DEFAULT_CURVE BGPSEC_ALGORITHM_SHA256_ECDSA_P_256
+
+
+#define BGPSEC_VERIFY_ERROR         -1
+#define BGPSEC_VERIFY_INVALID       0
+#define BGPSEC_VERIFY_SUCCESS       1
+
+#define BGPSEC_MAX_SIGBLOCK         2
+
+#define OCTET_SECURE_PATH_SEGMENT   6
+#define OCTET_SECURE_PATH_LEN       2
+#define OCTET_ALGORITHM_ID          1
+#define OCTET_SIG_BLOCK_LEN         2
+#define OCTET_SIGNATURE_LEN         2
+
+/* BGPSEC_PATH segment data in abstracted form, no limit is placed on length */
+struct PathSegment
+{
+  struct PathSegment    *next;
+  u_int32_t             as;
+  u_int8_t              pCount;
+  u_int8_t              flags;
+  unsigned long         refcnt;
+};
+
+struct SigSegment
+{
+  struct SigSegment     *next;
+  u_char                *ski;
+  u_int16_t             sigLen;
+  u_char                *signature;
+  unsigned long         refcnt;
+};
+
+struct SigBlock
+{
+  struct SigBlock       *next;
+  u_int16_t             sigBlockLen;
+  u_int8_t              algoSuiteId;
+  struct SigSegment     *sigSegments;
+  unsigned long         refcnt;
+};
+
+/* BGPSEC path may be include some BGPSEC Segments.  */
+struct BgpsecPathAttr
+{
+  size_t                securePathLen;
+
+  /* segment data */
+  struct PathSegment    *pathSegments;
+  struct SigBlock       *sigBlocks;
+
+  /* Reference count to this bgpsec path.  */
+  unsigned long         refcnt;
+};
+
+
+/* BGPSEC protocol pdu format structure */
+struct BgpsecPdu
+{
+  size_t      len_SecurePath;
+  u_int8_t    pCount;
+  u_int8_t    flags;
+  u_int32_t   asNum;
+  u_int16_t   len_SigBlock;
+  u_int8_t    algoSuiteId;
+  u_char      *ski;
+  u_int16_t   len_Sig;
+  u_char      *signature;
+};
+
+
+static inline void
+put_u32(void *p, u_int32_t x)
+{
+  x = htonl(x);
+  memcpy(p, &x, 4);
+}
+
+extern int bgpsecSignDataWithAsciiSKI();
+struct BgpsecPathAttr *bgpsec_path_intern (struct BgpsecPathAttr *bpa);
+void bgpsec_path_unintern (struct BgpsecPathAttr **pbpa);
+void bgpsec_path_free (struct BgpsecPathAttr *bpa);
+void bgpsec_path_attr_finish (void);
+void bgpsec_path_attr_init (void);
+/**
+ * Returns the pointer to the internal crypto api.
+ *  
+ * @return Returns the pointer to the internal crypto api
+ */
+SRxCryptoAPI* getSrxCAPI();
+int bgpsec_path_attr_cmp (const void *arg1, const void *arg2);
+unsigned int bgpsec_path_attr_key_make (void *p);
+/**
+ * This function duplicate the original attribute and its sub structures into a 
+ * new instance or generate a new empty one if requested. Freeing the memory
+ * of the original one does NOT affect the duplicate.
+ * 
+ * @param orig The original bgpsec path attribute (can be NULL)
+ * @param newIfNULL generate a new empty structure if the original one is NULL.
+ * 
+ * @return A copy of the given structure or a new one if the original is NULL 
+ *         and the attribute newIfNULL is set to true.
+ */
+struct BgpsecPathAttr * bgpsecDup(struct BgpsecPathAttr *orig, bool newIfNULL);
+
+void concatPathSegment(struct PathSegment * const , struct PathSegment * const);
+void concatSigSegment(struct SigSegment* const , struct SigSegment * const);
+void concatSigBlock(struct SigBlock* const , struct SigBlock * const);
+
+/**
+ * @brief bgpsecVerify library function caller from external calling,
+ * i.e., bgp_info_set_validation_result() at bgp_route.c
+ *
+ * @param peer The peer information
+ * @param attr The attribtue itself
+ * @param p The refix
+ * @param status The status information
+ *
+ * @return BGPSEC_VERIFY_ERROR, BGPSEC_VERIFY_INVALID, BGPSEC_VERIFY_SUCCESS
+ */
+extern int bgpsecVerifyCaller(struct peer *peer, struct attr *attr, 
+                              struct prefix p, sca_status_t* status);
+
+/**
+ * Construct the BGPSEC Path attribute. This includes signing the as path if it 
+ * is not signed already.
+ * This function writes the data into the stream.
+ * 
+ * @param bgp    The bgp session
+ * @param peer   The peer information
+ * @param aspath Pointer to the as path.
+ * @param p      The prefix
+ * @param s      The stream
+ * @param attr   The bgp attribute. 
+ *
+ * @return : total number of bgpsec Secure_Path + Signature_Block
+ *      TODO: new_bpa must be cleared, otherwise the memory leak
+ */
+int constructBGPSecPathAttribute(struct bgp *bgp, struct peer *peer, 
+                                 struct aspath *aspath, struct prefix* p,
+                                 struct stream *s, struct attr *attr,
+                                 u_int8_t flags, u_int8_t pCount,
+                                 SCA_Signature** signature, int numSignatures);
+
+int bgpsecSanityCheck(struct BgpsecPathAttr *);
+
+/**
+ * This function parses the byte stream and generates the internal
+ * bgpsecPathAttr structure. In case the handed update is malformed no
+ * bgpsecPathAttr is generated and the return value is NULL
+ *
+ * @param attr The attribute.
+ * @param peer The bgpsec session information
+ * @param s The stream containing the attribute information.
+ * @param length total length of bgpsec pdu including Secure_Path and Signature_Block
+ *
+ * @return The BgpsecPathAttr as pointer structure or NULL in case the BGPSEC
+ *         attribute is malformed. 
+ */
+struct BgpsecPathAttr* bgpsec_parse(struct attr *attr, struct peer *peer, 
+                                    struct stream* s, size_t length);
+
+/**
+ * This method does call the signing of the BGPSEC path attribute. This method
+ * assumes that the peer is NOT an iBGP peer.
+ * 
+ * @param bgp The bgp session.
+ * @param peer The peer to sign it too
+ * @param pfx The prefix to sign over (only for origin anouncements)
+ * @param attr The attribute containing the path information.
+ * @param pCount The pCount of this update
+ * @param flags the update flags.
+ * 
+ * @return The generated signature. If managed by the SrxCryptoAPI module
+ *         then it must be freed by the crypto module, otherwise it can be freed
+ *         using sca_freeSignature or manual using free etc.
+ * 
+ * @see srxcryptoapi.h:sca_freeSignature
+ */
+SCA_Signature* signBGPSecPathAttr(struct bgp* bgp, struct peer* peer, 
+                                  struct prefix* pfx, struct attr* attr, 
+                                  u_int8_t pCount, u_int8_t flags);
+
+/**
+ * This function is a wrapper for the corresponding CAPI function. This function
+ * is needed to allow the memory management performed by the CAPI itself.
+ * 
+ * @param message The hashInput to be freed.
+ * 
+ * @since 0.4.2.0
+ */
+void freeSCA_HashMessage(SCA_HashMessage* message);
+
+
+
+void test_print(struct BgpsecPdu , size_t *, char *, char* , size_t );
+void print_signature(struct BgpsecPathAttr *);
+unsigned char hex2bin_byte(char* );
+
+/* Macro Definition */
+#define GEN_SKI_ASCII(buf, ski, ski_len)        \
+do {                                        \
+  char* cp = buf;                           \
+  int i;                                    \
+  for(i=0; i<ski_len; i++) {                \
+    sprintf(cp, "%02X", (u_int8_t)ski[i]);  \
+    cp+=2;                                  \
+  }                                         \
+  buf[sizeof(buf)-1] = '\0';                \
+} while(0)
+
+
+#endif /* USE_SRX */
+#endif /* !_QUAGGA_BGP_VALIDATE_H */
--- ./bgpd/bgpd.h	2013-02-01 11:55:27.000000000 -0500
+++ ./bgpd/bgpd.h	2017-07-10 11:53:13.000000000 -0400
@@ -24,6 +24,319 @@ Software Foundation, Inc., 59 Temple Pla
 /* For union sockunion.  */
 #include "sockunion.h"
 
+#ifdef USE_SRX
+#include <srx/srx_api.h>
+#include <srx/srxcryptoapi.h>
+#include "bgp_info_hash.h"
+
+// @TODO: REMOVE THIS MACRO
+#define SRX_PRINT_HEX(DATA, DLEN)    \
+{                                    \
+  int sph_idx = 0;                   \
+  while (sph_idx < DLEN)             \
+  {                                  \
+    if (sph_idx % 16 == 0)           \
+    {                                \
+      printf ("\n");                 \
+    }                                \
+    else if (sph_idx % 8 == 0)       \
+    {                                \
+      printf (" ");                  \
+    }                                \
+    printf(" %02X", DATA[sph_idx]);  \
+    sph_idx++;                       \
+  }                                  \
+  printf ("\n");                     \
+}
+
+/** For now two
+ * different private keys seem to be enough.*/
+#define SRX_MAX_PRIVKEYS 2
+
+#define SRX_VTY_HLP_STR         "SRx configuration setting\n"
+
+#define SRX_VTY_EVAL_ORIGIN_ONLY "origin_only"
+#define SRX_VTY_EVAL_BGPSEC      "bgpsec"
+
+#define SRX_VTY_PARAM_CONNECT_SRV  0
+#define SRX_VTY_PARAM_CONNECT_PORT 1
+#define SRX_VTY_CMD_CONNECT_SHORT "srx connect"
+#define SRX_VTY_HLP_CONNECT_SHORT SRX_VTY_HLP_STR \
+                                  "Connect the router with SRx server\n"
+#define SRX_VTY_CMD_CONNECT   SRX_VTY_CMD_CONNECT_SHORT " .LINE <0-65535>"
+#define SRX_VTY_OUT_CONNECT   "srx connect %s %d%s"
+#define SRX_VTY_HLP_CONNECT   SRX_VTY_HLP_CONNECT_SHORT \
+                              "Specifies SRx server host name or IP address\n" \
+                              "Specifies SRx server port\n"
+
+#define SRX_VTY_CMD_DISCONNECT  "srx disconnect"
+#define SRX_VTY_HLP_DISCONNECT  SRX_VTY_HLP_STR \
+                                "Disconnect from the SRx server\n"
+
+#define SRX_VTY_CMD_DISPLAY     "srx display"
+#define SRX_VTY_OUT_DISPLAY     "srx diaplay%s"
+#define SRX_VTY_HLP_DISPLAY     SRX_VTY_HLP_STR \
+                                "Add SRx related output to the \"show\"" \
+                                " commands\n"
+#define SRX_VTY_HLP_DISPLAY_NO  SRX_VTY_HLP_STR \
+                                "Hide SRx related output from the \"show\"" \
+                                " commands\n"
+
+#define SRX_VTY_CMD_EVALUATE    "srx evaluation (" SRX_VTY_EVAL_ORIGIN_ONLY \
+                                                 "|" SRX_VTY_EVAL_BGPSEC ")"
+#define SRX_VTY_OUT_EVALUATE    "srx evaluation %s%s"
+#define SRX_VTY_HLP_EVALUATE    SRX_VTY_HLP_STR \
+                                "Activate the policy processing\n" \
+                                "Only perform prefix origin validation using " \
+                                  "ROAs\n" \
+                                "Perform both, prefix origin validation using" \
+                                  " ROA's and path validation\n"
+#define SRX_VTY_CMD_NO_EVALUATE "no srx evaluation"
+#define SRX_VTY_HLP_NO_EVALUATE  NO_STR SRX_VTY_HLP_STR \
+                                "Deactivate the policy processing.\n" \
+                                
+
+#define SRX_VTY_CMD_EVAL_WITHSRX "srx evaluation " SRX_VTY_EVAL_BGPSEC \
+                                 " distributed"
+#define SRX_VTY_OUT_EVAL_WITHSRX "srx evaluation " SRX_VTY_EVAL_BGPSEC \
+                                 " distributed%s"
+#define SRX_VTY_HLP_EVAL_WITHSRX SRX_VTY_HLP_STR \
+                                "Activate the policy processing\n" \
+                                "Perform both, prefix origin validation using" \
+                                  " ROA's and path validation\n" \
+                                "Perform path validation using srx-server.\n"
+
+#define SRX_VTY_CMD_KEEPWINDOW_SHORT "srx keep-window"
+#define SRX_VTY_CMD_KEEPWINDOW  SRX_VTY_CMD_KEEPWINDOW_SHORT " <0-65535>"
+#define SRX_VTY_HLP_KEEPWINDOW  SRX_VTY_HLP_STR \
+                                "Configure amount of time in seconds the SRx is" \
+                                " requested to hold information after it "\
+                                " is deleted!\n" \
+                                "Time in seconds \'0\' disables this feature!\n"
+
+//The short version is not a stand alone command, it is needed for a vtty output
+#define SRX_VTY_CMD_SET_SERVER_SHORT "srx set-server"
+#define SRX_VTY_CMD_SET_SERVER  SRX_VTY_CMD_SET_SERVER_SHORT " .LINE <0-65535>"
+#define SRX_VTY_HLP_SET_SERVER  SRX_VTY_HLP_STR \
+                                "Set the SRx server connection parameters\n"
+
+#define SRX_VTY_CMD_PROXYID "srx set-proxy-id A.B.C.D"
+#define SRX_VTY_HLP_PROXYID SRX_VTY_HLP_STR \
+                            "Configure the proxy id. This is the id used to " \
+                            "connect to the srx-server. By default the proxy " \
+                            "is the same as the BGP router id. The id is " \
+                            "specified a 4 byte unsigned integer specified " \
+                            "in IPv4 format.\n"
+
+#define SRX_VTY_CMD_SHOW_CONFIG "show srx-config"
+#define SRX_VTY_HLP_SHOW_CONFIG SHOW_STR "SRx-BGP Router configuration\n"
+
+// DEFAULT VALIDATION RESULT PARAMETER
+#define SRX_VTY_PARAM_ORIGIN_VALUE 0
+#define SRX_VTY_PARAM_PATH_VALUE   1
+
+#define SRX_VTY_PARAM_BGPSEC_MIN_ALGOID 1
+#define SRX_VTY_PARAM_BGPSEC_MAX_ALGOID 254
+
+// DEFAULT VALIDATION RESULT FOR ORIGIN VALIDATION
+#define SRX_VTY_CMD_CONF_DEF_ROA_RES_STR "srx set-origin-value "
+#define SRX_VTY_CMD_CONF_DEF_ROA_RES_VALID \
+                                 SRX_VTY_CMD_CONF_DEF_ROA_RES_STR "valid\n"
+#define SRX_VTY_CMD_CONF_DEF_ROA_RES_NOTFOUND \
+                                 SRX_VTY_CMD_CONF_DEF_ROA_RES_STR "notfound\n"
+#define SRX_VTY_CMD_CONF_DEF_ROA_RES_INVALID \
+                                 SRX_VTY_CMD_CONF_DEF_ROA_RES_STR "invalid\n"
+#define SRX_VTY_CMD_CONF_DEF_ROA_RES_UNDEFINED \
+                                 SRX_VTY_CMD_CONF_DEF_ROA_RES_STR "undefined\n"
+
+#define SRX_VTY_HLP_CONF_DEF_ROA_RES_STR SRX_VTY_HLP_STR \
+                                 "Configure the default result value for " \
+                                   "origin validation\n" \
+                                 "The route originations default validation " \
+                                   "value is "
+#define SRX_VTY_HLP_CONF_DEF_ROA_RES_VALID \
+                                 SRX_VTY_HLP_CONF_DEF_ROA_RES_STR  "valid\n"
+#define SRX_VTY_HLP_CONF_DEF_ROA_RES_NOTFOUND \
+                                 SRX_VTY_HLP_CONF_DEF_ROA_RES_STR  "notfound\n"
+#define SRX_VTY_HLP_CONF_DEF_ROA_RES_INVALID \
+                                 SRX_VTY_HLP_CONF_DEF_ROA_RES_STR  "invalid\n"
+#define SRX_VTY_HLP_CONF_DEF_ROA_RES_UNDEFINED \
+                                 SRX_VTY_HLP_CONF_DEF_ROA_RES_STR  "undefined\n"
+
+// DEFAULT VALIDATION RESULT FOR PATH VALIDATION
+#define SRX_VTY_CMD_CONF_DEF_PATH_RES_STR "srx set-path-value "
+#define SRX_VTY_CMD_CONF_DEF_PATH_RES_VALID \
+                                 SRX_VTY_CMD_CONF_DEF_PATH_RES_STR "valid\n"
+#define SRX_VTY_CMD_CONF_DEF_PATH_RES_INVALID \
+                                 SRX_VTY_CMD_CONF_DEF_PATH_RES_STR "invalid\n"
+#define SRX_VTY_CMD_CONF_DEF_PATH_RES_UNDEFINED \
+                                 SRX_VTY_CMD_CONF_DEF_PATH_RES_STR "undefined\n"
+
+#define SRX_VTY_HLP_CONF_DEF_PATH_RES_STR SRX_VTY_HLP_STR \
+                                 "Configure the default result value for " \
+                                   "path validation\n" \
+                                 "The route originations default validation " \
+                                   "value is "
+#define SRX_VTY_HLP_CONF_DEF_PATH_RES_VALID \
+                                 SRX_VTY_HLP_CONF_DEF_PATH_RES_STR "valid\n"
+#define SRX_VTY_HLP_CONF_DEF_PATH_RES_INVALID \
+                                 SRX_VTY_HLP_CONF_DEF_PATH_RES_STR "invalid\n"
+#define SRX_VTY_HLP_CONF_DEF_PATH_RES_UNDEFINED \
+                                 SRX_VTY_HLP_CONF_DEF_PATH_RES_STR "undefined\n"
+
+// APPLY POLICY CHANGE
+#define SRX_VTY_CMD_APPLY_POLICY "srx apply-policy"
+#define SRX_VTY_HLP_APPLY_POLICY SRX_VTY_HLP_STR \
+                                 "Apply SRx policy changes to all updates in" \
+                                 " the RIB.\n"
+
+// POLICY
+#define SRX_VTY_HLP_POLICY      "Evaluation policy command\n"
+#define SRX_VTY_HLP_ORIGIN_ONLY "(" SRX_VTY_EVAL_ORIGIN_ONLY ") "
+
+// POLICY IGNORE NOTFOUND / INVALID
+#define SRX_VTY_CMD_POL_IGNORE_NOTFOUND  "srx policy ignore-notfound"
+#define SRX_VTY_HLP_POL_IGNORE_NOTFOUND  SRX_VTY_HLP_STR SRX_VTY_HLP_POLICY \
+                                         SRX_VTY_HLP_ORIGIN_ONLY \
+                                         "Ignore updates with validation " \
+                                         "result = UNKNOWN.\n"
+
+#define SRX_VTY_CMD_POL_IGNORE_INVALID   "srx policy ignore-invalid"
+#define SRX_VTY_HLP_POL_IGNORE_INVALID   SRX_VTY_HLP_STR SRX_VTY_HLP_POLICY \
+                                         "Ignore updates with validation" \
+                                         " result = INVALID.\n"
+
+#define SRX_VTY_CMD_POL_IGNORE_UNDEFINED "srx policy ignore-undefined"
+#define SRX_VTY_HLP_POL_IGNORE_UNDEFINED SRX_VTY_HLP_STR SRX_VTY_HLP_POLICY \
+                                         "Ignore updates with no complete" \
+                                         " validation result available.\n"
+
+// POLICY LOCAL-PREF ADJUSTMENT
+#define SRX_VTY_HLP_POL_LOCP   "Manipulate local preference\n"
+#define SRX_VTY_HLP_POL_LOCP_V "Policy for validation result  = VALID\n"
+#define SRX_VTY_HLP_POL_LOCP_U SRX_VTY_HLP_ORIGIN_ONLY "Policy for " \
+                               "validation result = UNKNOWN\n"
+#define SRX_VTY_HLP_POL_LOCP_I "Policy for validation result = INVALID\n"
+
+#define SRX_VTY_HLP_POL_LOCP_A "To be added to the given local pref\n"
+#define SRX_VTY_HLP_POL_LOCP_S "To be subtracted from the given local pref\n"
+
+#define SRX_VTY_CMD_POL_LOCP      "srx policy local-preference"
+#define SRX_VTY_CMD_POL_LOCP_FIX  SRX_VTY_CMD_POL_LOCP \
+                                  " (valid|notfound|invalid) <0-4294967295>"
+#define SRX_VTY_HLP_POL_LOCP_FIX  SRX_VTY_HLP_STR SRX_VTY_HLP_POLICY \
+                                  SRX_VTY_HLP_POL_LOCP \
+                                  SRX_VTY_HLP_POL_LOCP_V \
+                                  SRX_VTY_HLP_POL_LOCP_U \
+                                  SRX_VTY_HLP_POL_LOCP_I \
+                                  "The local preference value.\n"
+
+#define SRX_VTY_CMD_POL_LOCP_VAR  SRX_VTY_CMD_POL_LOCP_FIX \
+                                  " (add|subtract)"
+#define SRX_VTY_HLP_POL_LOCP_VAR  SRX_VTY_HLP_POL_LOCP_FIX \
+                                  SRX_VTY_HLP_POL_LOCP_A \
+                                  SRX_VTY_HLP_POL_LOCP_S
+
+#define SRX_VTY_CMD_NO_POL_LOCP   "no " SRX_VTY_CMD_POL_LOCP \
+                                  " (valid|notfound|invalid)"
+#define SRX_VTY_HLP_NO_POL_LOCP   NO_STR SRX_VTY_HLP_STR SRX_VTY_HLP_POLICY \
+                                  SRX_VTY_HLP_POL_LOCP \
+                                  SRX_VTY_HLP_POL_LOCP_V \
+                                  SRX_VTY_HLP_POL_LOCP_U \
+                                  SRX_VTY_HLP_POL_LOCP_I \
+
+// POLICY PREFER-VALID
+#define SRX_VTY_CMD_POL_PREFV "srx policy prefer-valid"
+#define SRX_VTY_OUT_POL_PREFV SRX_VTY_CMD_POL_PREFV "%s"
+#define SRX_VTY_HLP_POL_PREFV SRX_VTY_HLP_STR SRX_VTY_HLP_POLICY \
+                              "Use the validation state as tie breaker" \
+                              " with valid > any other\n"
+
+// USE OF COMMUNITY STRING
+#define SRX_VTY_CMD_EXT_CSTR "srx extcommunity <0-255>"
+#define SRX_VTY_HLP_EXT_CSTR SRX_VTY_HLP_STR "Configure community string for" \
+                              " validation result transmission\n" \
+                             "The sub code of the extended community.\n"
+
+#define SRX_VTY_CMD_EXT_CSTR_EBGP SRX_VTY_CMD_EXT_CSTR " (include_ebgp|only_ibgp)"
+#define SRX_VTY_HLP_EXT_CSTR_EBGP SRX_VTY_HLP_EXT_CSTR \
+                                  "Include eBGP peers (optional)\n" \
+                                  "Only iBGP peers - also used to turn off eBGP peers\n"
+
+#define SRX_VTY_CMD_NO_EXT_CSTR "no srx extcommunity"
+#define SRX_VTY_HLP_NO_EXT_CSTR  NO_STR SRX_VTY_HLP_STR \
+                                "Deactivate the extended community validation" \
+                                 " result transfer.\n"
+
+// BGPSEC KEY MANAGEMENT
+#define SRX_VTY_HLP_BGPSEC "BGPSEC specific configuration\n"
+
+#define SRX_VTY_CMD_BGPSEC_SKI_PRNT "srx bgpsec ski (0|1) <1-254>"
+#define SRX_VTY_CMD_BGPSEC_SKI SRX_VTY_CMD_BGPSEC_SKI_PRNT " WORD"
+#define SRX_VTY_OUT_BGPSEC_SKI "srx bgpsec ski %u %s%s"
+#define SRX_VTY_HLP_BGPSEC_SKI SRX_VTY_HLP_STR SRX_VTY_HLP_BGPSEC \
+                              "Configures the SKI for the private key!\n" \
+                              "Set the algorithm ID of the key \n" \
+                              "The SKI, a 20 byte value as 40 byte HEX string of the SKI"
+
+#define SRX_VTY_CMD_BGPSEC_ACTIVE_SKI "srx bgpsec active (0|1)"
+#define SRX_VTY_OUT_BGPSEC_ACTIVE_SKI "srx bgpsec active %u%s"
+#define SRX_VTY_HLP_BGPSEC_ACTIVE_SKI SRX_VTY_HLP_STR SRX_VTY_HLP_BGPSEC \
+                                      "Configure which key is active"
+
+#define SRX_VTY_CMD_BGPSEC_REGISTER_P_KEYS "srx bgpsec register keys"
+#define SRX_VTY_HLP_BGPSEC_REGISTER_P_KEYS SRX_VTY_HLP_STR SRX_VTY_HLP_BGPSEC \
+                          "This command will attempt to register the current " \
+                          "keys. This migth be required if a previous " \
+                          "registration failed!\n"
+
+// DEPRECATED AND REMOVED KEY COMMANDS
+#define SRX_VTY_HLP_BGPSEC_DEP "Please use the replacement 'srx bgpsec ...'\n"
+#define SRX_VTY_CMD_BGPSEC_DEP_SKI_PRNT "bgpsec ski"
+#define SRX_VTY_CMD_BGPSEC_DEP_SKI SRX_VTY_CMD_BGPSEC_DEP_SKI_PRNT " WORD"
+#define SRX_VTY_HLP_BGPSEC_DEP_SKI SRX_VTY_HLP_BGPSEC_DEP \
+                                   "This command is deprecated! " \
+                                   "Use '" SRX_VTY_CMD_BGPSEC_SKI_PRNT \
+                                   " <ski>' instead!\n"
+
+#define SRX_VTY_CMD_BGPSEC_DEP_SIGN "bgpsec sign (key|id)"
+#define SRX_VTY_HLP_BGPSEC_DEP_SIGN SRX_VTY_HLP_BGPSEC_DEP \
+                                    "This command is removed!\n"
+
+// BGPSEC NEIGHBOR COMMANDS
+#define SRX_VTY_CMD_NEIGHBOR_BGPSEC NEIGHBOR_CMD2 "bgpsec "
+#define SRX_VTY_HLP_NEIGHBOR_BGPSEC NEIGHBOR_STR NEIGHBOR_ADDR_STR2 \
+                                    "Configure the bgpsec capability to the peer\n"
+
+#define SRX_VTY_CMD_NEIGHBOR_BGPSEC_MODE SRX_VTY_CMD_NEIGHBOR_BGPSEC \
+                                    "(snd|rec|both)"
+//                                    "(snd|rec|both|migrate|route-server)"
+#define SRX_VTY_HLP_NEIGHBOR_BGPSEC_MODE SRX_VTY_HLP_NEIGHBOR_BGPSEC \
+                                    "Send BGPSEC but receive BGP4 only\n" \
+                                    "Receive BGPSEC but send BGP4 only\n" \
+                                    "Send BGPSEC and receive BGPSEC\n"
+//                                    "Flag this peering session as a migration." \
+//                                    " This will cause the pCount set to be 0.\n" \
+//                                    "Flag that the peer is a route server and " \
+//                                    "this peer is allowed to set its pcount to zero.\n"
+
+#define SRX_VTY_CMD_NO_NEIGHBOR_BGPSEC_MODE NO_NEIGHBOR_CMD2 "bgpsec " \
+                                    "(snd|rec|both)"
+//                                    "(snd|rec|both|migrate|route-server)"
+#define SRX_VTY_HLP_NO_NEIGHBOR_BGPSEC_MODE NO_STR SRX_VTY_HLP_NEIGHBOR_BGPSEC \
+                                    "Send BGPSEC but receive BGP4 only\n" \
+                                    "Receive BGPSEC but send BGP4 only\n" \
+                                    "Send BGPSEC and receive BGPSEC\n"
+//                                    "Remove the migration flag. This will remove" \
+//                                      " the acceptance of received" \
+//                                      " pcount=0 values of this peer and pcount" \
+//                                      " will not be set while" \
+//                                      " sending updates to this peer.\n" \
+//                                    "Unflag that the peer as a route server and" \
+//                                    " receiving pcount equals zero is not allowed.\n"
+
+#endif /* USE_SRX */
+
 /* Typedef BGP specific types.  */
 typedef u_int32_t as_t;
 typedef u_int16_t as16_t; /* we may still encounter 16 Bit asnums */
@@ -62,6 +375,20 @@ struct bgp_master
 #define BGP_OPT_NO_LISTEN                (1 << 3)
 };
 
+#ifdef USE_SRX
+/** Data stored in this structure defines how the local pref has to be
+ * manipulated.
+ */
+struct srx_local_pref {
+  // Indicated if the local pref has to be manipulated.
+  int      is_set;
+  // If set then add or delete the given value from the the local pref.
+  int      relative;
+  // the local pref value
+  uint32_t value;
+};
+#endif /* USE_SRX */
+
 /* BGP instance structure.  */
 struct bgp 
 {
@@ -91,6 +418,19 @@ struct bgp 
 #define BGP_CONFIG_ROUTER_ID              (1 << 0)
 #define BGP_CONFIG_CLUSTER_ID             (1 << 1)
 #define BGP_CONFIG_CONFEDERATION          (1 << 2)
+#ifdef USE_SRX
+#define BGP_CONFIG_SRX                    (1 << 3)
+
+  /* SRX Configuration */
+  u_int16_t srx_config;
+#define SRX_CONFIG_EVAL_ORIGIN   (1 << 1)
+// Below must be set in combination with VALORIGIN
+#define SRX_CONFIG_EVAL_PATH     (1 << 2)
+#define SRX_CONFIG_EVALUATE      (SRX_CONFIG_EVAL_ORIGIN | SRX_CONFIG_EVAL_PATH)
+
+#define SRX_CONFIG_EVAL_DISTR    ((1 << 3) | SRX_CONFIG_EVALUATE)
+#define SRX_CONFIG_DISPLAY_INFO  (1 << 4)
+#endif /* USE_SRX */
 
   /* BGP router identifier.  */
   struct in_addr router_id;
@@ -169,6 +509,58 @@ struct bgp 
     u_int16_t maxpaths_ebgp;
     u_int16_t maxpaths_ibgp;
   } maxpaths[AFI_MAX][SAFI_MAX];
+
+#ifdef USE_SRX
+  /* Configuration */
+  // All the default configuration is set in the method srx_set_default
+
+  char *srx_host;
+  int  srx_port;
+#define SRX_HANDHAKE_TIMEOUT  30
+#define SRX_KEEP_WINDOW      900
+
+  // The timeout during the session establishment
+  int  srx_handshakeTimeout;
+  // Time in seconds the SRx server is requested to keep data after a delete
+  int  srx_keepWindow;
+  uint32_t srx_proxyID;
+  /** The local pref values for [0]valid, [1]notfound, and [2]invalid*/
+  struct srx_local_pref  srx_val_local_pref[3];
+#define VAL_LOCPRF_VALID     0
+#define VAL_LOCPRF_NOTFOUND   1
+#define VAL_LOCPRF_INVALID   2
+
+  /** Contains the bit coded policy setting*/
+  uint16_t srx_val_policy;
+#define SRX_VAL_POLICY_PREFER_VALID     (1 << 0)
+#define SRX_VAL_POLICY_IGNORE_NOTFOUND  (1 << 1)
+#define SRX_VAL_POLICY_IGNORE_INVALID   (1 << 2)
+#define SRX_VAL_POLICY_IGNORE_UNDEFINED (1 << 3)
+
+  uint16_t srx_default_roaVal;
+  uint16_t srx_default_bgpsecVal;
+
+  /* Instance variables */
+  SRxProxy* srxProxy;
+  /* The info hash for update id's */
+  struct bgp_info_hash* info_uid_hash;
+  /* The info hash for local id's */
+  struct bgp_info_hash* info_lid_hash;
+  /** The SRx CryptoAPI instance. Will be currently maintained as g_capi in
+   * bgp_validate.c */
+  SRxCryptoAPI* srxCAPI;
+
+  /* The bgpsec private key array. */
+  BGPSecKey srx_bgpsec_key[SRX_MAX_PRIVKEYS];
+  /** The key to be used, 0..SRX_MAX_PRIVKEYS-1.*/
+  u_int8_t  srx_bgpsec_active_key;
+
+  /** Contains the information if extended community is used and the subcode*/
+#define SRX_BGP_FLAG_ECOMMUNITY      (1 << 0)
+#define SRX_BGP_FLAG_ECOMMUNITY_EBGP (1 << 1)
+  u_int8_t srx_ecommunity_flags;
+  u_int8_t srx_ecommunity_subcode;
+#endif /* USE_SRX */
 };
 
 /* BGP peer-group support. */
@@ -359,6 +751,11 @@ struct peer
 #define PEER_CAP_RESTART_RCV                (1 << 6) /* restart received */
 #define PEER_CAP_AS4_ADV                    (1 << 7) /* as4 advertised */
 #define PEER_CAP_AS4_RCV                    (1 << 8) /* as4 received */
+#ifdef USE_SRX
+#define PEER_CAP_EXTENDED_MSG_SUPPORT       (1 << 13)/* extended message support*/
+#define PEER_CAP_BGPSEC_ADV_SEND            (1 << 14)/* bgpsec advertised send capability */
+#define PEER_CAP_BGPSEC_ADV                 (1 << 15)/* bgpsec advertised recv capability */
+#endif
 
   /* Capability flags (reset in bgp_stop) */
   u_int16_t af_cap[AFI_MAX][SAFI_MAX];
@@ -382,6 +779,17 @@ struct peer
 #define PEER_FLAG_DISABLE_CONNECTED_CHECK   (1 << 6) /* disable-connected-check */
 #define PEER_FLAG_LOCAL_AS_NO_PREPEND       (1 << 7) /* local-as no-prepend */
 #define PEER_FLAG_LOCAL_AS_REPLACE_AS       (1 << 8) /* local-as no-prepend replace-as */
+#ifdef USE_SRX
+#define PEER_FLAG_EXTENDED_MESSAGE_SUPPORT  (1 << 9) /* BGP-Extended Message Support */
+#define PEER_FLAG_BGPSEC_MPE_IPV4           (1 << 10) /* mp extension for ipv4 */
+// The next two flags allow pcount=0, both in receiving and migrate also in sending
+#define PEER_FLAG_BGPSEC_MIGRATE            (1 << 11) /* enable migration mode with this peer */
+#define PEER_FLAG_BGPSEC_ROUTE_SERVER       (1 << 12) /* the peer is a route server */
+#define PEER_FLAG_EXTENDED_MESSAGE_LIBERAL  (1 << 13) /* BGP-Extended Message Support liberal */
+#define PEER_FLAG_BGPSEC_CAPABILITY_RECV    (1 << 14)/* bgpsec capability - RECV */
+#define PEER_FLAG_BGPSEC_CAPABILITY_SEND    (1 << 15)/* bgpsec capability - SEND */
+#define PEER_FLAG_BGPSEC_CAPABILITY         (1 << 15)/* bgpsec capability - SEND */
+#endif
 
   /* NSF mode (graceful restart) */
   u_char nsf[AFI_MAX][SAFI_MAX];
@@ -515,6 +923,12 @@ struct peer
   /* ORF Prefix-list */
   struct prefix_list *orf_plist[AFI_MAX][SAFI_MAX];
 
+#ifdef USE_SRX
+  // Flag this peer to be migrated. In this case set the pCount to zero and
+  // also allow this peer to set its pCount to zero.
+  bool bgpsec_migrate;
+#endif
+
   /* Prefix count. */
   unsigned long pcount[AFI_MAX][SAFI_MAX];
 
@@ -594,6 +1008,9 @@ struct bgp_nlri
 #define BGP_MARKER_SIZE		                16
 #define BGP_HEADER_SIZE		                19
 #define BGP_MAX_PACKET_SIZE                   4096
+#ifdef USE_SRX
+#define BGP_MAX_PACKET_SIZE_EXTENDED         65535
+#endif
 
 /* BGP minimum message size.  */
 #define BGP_MSG_OPEN_MIN_SIZE                   (BGP_HEADER_SIZE + 10)
@@ -636,6 +1053,9 @@ struct bgp_nlri
 #define BGP_ATTR_AS4_PATH                       17
 #define BGP_ATTR_AS4_AGGREGATOR                 18
 #define BGP_ATTR_AS_PATHLIMIT                   21
+#if defined(USE_SRX) && !defined(BGP_ATTR_BGPSEC)
+#define BGP_ATTR_BGPSEC                         33
+#endif
 
 /* BGP update origin.  */
 #define BGP_ORIGIN_IGP                           0
@@ -668,7 +1088,10 @@ struct bgp_nlri
 #define BGP_NOTIFY_OPEN_AUTH_FAILURE             5
 #define BGP_NOTIFY_OPEN_UNACEP_HOLDTIME          6
 #define BGP_NOTIFY_OPEN_UNSUP_CAPBL              7
-#define BGP_NOTIFY_OPEN_MAX                      8
+#ifdef USE_SRX
+#define BGP_NOTIFY_OPEN_UNSUP_BGPSEC             8
+#endif
+#define BGP_NOTIFY_OPEN_MAX                      9
 
 /* BGP_NOTIFY_UPDATE_ERR sub codes.  */
 #define BGP_NOTIFY_UPDATE_MAL_ATTR               1
@@ -883,6 +1306,32 @@ extern int bgp_timers_unset (struct bgp 
 extern int bgp_default_local_preference_set (struct bgp *, u_int32_t);
 extern int bgp_default_local_preference_unset (struct bgp *);
 
+#ifdef USE_SRX
+extern int bgp_srx_set (struct bgp *, struct vty *, const char *, int, bool);
+extern int bgp_srx_unset (struct bgp *bgp);
+
+// does both, set and unset
+extern int bgp_srx_evaluation (struct bgp *, int);
+extern int bgp_srx_display (struct bgp *bgp, int);
+extern int bgp_srx_conf_default_result (struct bgp *bgp, int, int);
+
+// does set
+extern int srx_set_proxyID(struct bgp* , uint32_t);
+
+extern int srx_val_local_preference_set (struct bgp *, int, int, uint32_t);
+extern int srx_val_local_preference_unset (struct bgp *, int);
+extern int srx_val_policy_set (struct bgp *, uint16_t);
+extern int srx_val_policy_unset (struct bgp *, uint16_t);
+
+extern int srx_extcommunity_set (struct bgp *, uint8_t, const char *);
+extern int srx_extcommunity_unset (struct bgp *);
+
+extern int srx_config_check (struct bgp *, uint16_t);
+
+extern int srx_connect_proxy(struct bgp *);
+#define DEBUG_TEST
+#endif /* USE_SRX */
+
 extern int peer_rsclient_active (struct peer *);
 
 extern int peer_remote_as (struct bgp *, union sockunion *, as_t *, afi_t, safi_t);
--- ./bgpd/bgp_validate.c	1969-12-31 19:00:00.000000000 -0500
+++ ./bgpd/bgp_validate.c	2017-06-26 16:01:23.000000000 -0400
@@ -0,0 +1,1369 @@
+#include <zebra.h>
+#ifdef USE_SRX
+
+#include "log.h"
+#include "hash.h"
+#include "jhash.h"
+#include "memory.h"
+#include "vector.h"
+#include "prefix.h"
+#include "log.h"
+#include "stream.h"
+#include "vty.h"
+#include "bgpd/bgpd.h"
+#include "bgpd/bgp_attr.h"
+#include "bgpd/bgp_debug.h"
+#include "bgpd/bgp_aspath.h"
+#include "bgpd/bgp_validate.h"
+
+#include <srx/srxcryptoapi.h>
+SRxCryptoAPI *g_capi;
+#define RET_ID_OFFSET 1
+
+/* Hash for bgpsec path.  This is the top level structure of BGPSEC AS path. */
+static struct hash *bgpsechash;
+// Forward declarations
+static u_int8_t* ski_new();
+static void *signature_new(size_t size);
+static struct PathSegment* pathSegment_New(void);
+static struct SigSegment* sigSegment_New(void);
+static struct SigBlock* sigBlock_New(void);
+static void bgpsec_sigBlock_free_all (struct SigBlock *sb);
+static void bgpsec_sigBlock_free (struct SigBlock *sb);
+static void sigSegment_free_all(struct SigSegment *ss);
+static void sigSegment_free(struct SigSegment *ss);
+static void bgpsec_path_segment_free_all (struct PathSegment *seg);
+static void bgpsec_path_segment_free (struct PathSegment *seg);
+static struct BgpsecPathAttr * bgpsec_path_attr_new (void);
+static void * bgpsec_path_hash_alloc (void *arg);
+
+/* If two aspath have same value then return 1 else return 0 */
+int bgpsec_path_attr_cmp (const void *arg1, const void *arg2)
+{
+  if (arg1 == arg2)
+    return 1;
+  if (arg1 == NULL && arg2 == NULL)
+    return 1;
+
+  const struct PathSegment *seg1 = ((const struct BgpsecPathAttr *)arg1)->pathSegments;
+  const struct PathSegment *seg2 = ((const struct BgpsecPathAttr *)arg2)->pathSegments;
+
+  const struct SigBlock *sb1 = ((const struct BgpsecPathAttr *)arg1)->sigBlocks;
+  const struct SigBlock *sb2 = ((const struct BgpsecPathAttr *)arg2)->sigBlocks;
+
+  const struct SigSegment *ss1;
+  const struct SigSegment *ss2;
+
+  while (seg1 || seg2)
+    {
+      if ((!seg1 && seg2) || (seg1 && !seg2))
+	return 0;
+      if (seg1->as != seg2->as)
+        return 0;
+      if (seg1->pCount != seg2->pCount)
+        return 0;
+      if (seg1->flags != seg2->flags)
+          return 0;
+      seg1 = seg1->next;
+      seg2 = seg2->next;
+    }
+
+  while (sb1 || sb2)
+    {
+      if ((!sb1 && sb2) || (sb1 && !sb2))
+	return 0;
+      if (sb1->sigBlockLen != sb2->sigBlockLen)
+        return 0;
+      if (sb1->algoSuiteId != sb2->algoSuiteId)
+        return 0;
+
+      ss1 = sb1->sigSegments;
+      ss2 = sb2->sigSegments;
+
+      while(ss1 || ss2)
+      {
+        if ((!ss1  && ss2) || (ss1 && !ss2))
+          return 0;
+        if (memcmp(ss1->ski, ss2->ski, BGPSEC_SKI_LENGTH) != 0)
+          return 0;
+        if (ss1->sigLen != ss2->sigLen)
+          return 0;
+        if (memcmp(ss1->signature, ss2->signature, ss1->sigLen) != 0)
+          return 0;
+
+        ss1 = ss1->next;
+        ss2 = ss2->next;
+      }
+
+      sb1 = sb1->next;
+      sb2 = sb2->next;
+    }
+  return 1;
+}
+
+
+/* Make hash value by raw bgpsec path attr data. */
+unsigned int bgpsec_path_attr_key_make (void *p)
+{
+  struct BgpsecPathAttr *bpa = (struct BgpsecPathAttr *) p;
+  struct PathSegment *seg = bpa->pathSegments;
+  struct SigBlock *sb = bpa->sigBlocks;
+  struct SigSegment *ss;
+  unsigned int key = 0;
+
+
+  if (sb)
+  {
+    ss = sb->sigSegments;
+    key += jhash(sb, 4, 0);
+    key += jhash (ss->signature, ss->sigLen, 0);
+  }
+  /*
+  else if(seg)
+  {
+    u_int32_t as = seg->as;
+
+    key += (as & 0xff000000) >> 24;
+    key += (as & 0x00ff0000) >> 16;
+    key += (as & 0x0000ff00) >> 8;
+    key += (as & 0x000000ff);
+  }
+  */
+  else
+  {
+#define MIX(val)	key = jhash_1word(val, key)
+    MIX(bpa->securePathLen);
+    key += jhash(bpa->pathSegments, 4, 0);
+    key += jhash(bpa->sigBlocks, 4, 0);
+  }
+
+  return key;
+}
+
+/*
+ * Initialize the bgpsec path hash - similar to the as path hash and initializes
+ * the srx-crypto-api
+ *
+ */
+void bgpsec_path_attr_init()
+{
+ // @TODO: If no crypto is performed on the router side (e.g. srx-server does
+ //        crypto - then the API might not need to be initialized.)
+ //        One exception though, if we keep signing here even with the use of
+ //        srx-server.
+  // aspath_init initialize its aspath hash as many as the number of 32767 hashes, so follows the same number
+  bgpsechash = hash_create_size (32767, bgpsec_path_attr_key_make, bgpsec_path_attr_cmp);
+  g_capi = malloc(sizeof(SRxCryptoAPI));
+  memset (g_capi, 0, sizeof(SRxCryptoAPI));
+  sca_status_t sca_status = API_STATUS_OK;
+
+  if(srxCryptoInit(g_capi, &sca_status) == API_FAILURE)
+  {
+    zlog_err("[BGPSEC] SRxCryptoAPI not initialized (0x%X)!\n", sca_status);
+  }
+}
+
+/**
+ * Returns the pointer to the internal crypto api.
+ *
+ * @return Returns the pointer to the internal crypto api
+ */
+SRxCryptoAPI* getSrxCAPI()
+{
+  return g_capi;
+}
+
+/**
+ * Clean the hash
+ */
+void bgpsec_path_attr_finish (void)
+{
+  hash_free (bgpsechash);
+  bgpsechash = NULL;
+}
+
+static void * bgpsec_path_hash_alloc (void *arg)
+{
+  const struct BgpsecPathAttr *bpa = arg;
+  struct BgpsecPathAttr *new;
+  struct PathSegment *newSeg, *origSeg;
+
+  /* Malformed AS path value. */
+  assert (bpa->sigBlocks);
+  assert (bpa->pathSegments);
+  if (! bpa->sigBlocks->sigSegments)
+    return NULL;
+
+  /* New aspath structure is needed. */
+  new = bgpsec_path_attr_new();
+  new->securePathLen    = bpa->securePathLen;
+  new->pathSegments     = pathSegment_New();
+
+  /* pathSegment allocation according to the number of segments */
+  origSeg   = bpa->pathSegments;
+  newSeg    = new->pathSegments;
+  while(origSeg)
+  {
+    *newSeg  = *origSeg; //struct copy
+
+    if(origSeg->next)
+    {
+      newSeg->next = pathSegment_New();
+      newSeg = newSeg->next;
+    }
+
+    origSeg = origSeg->next;
+  }
+
+  /* sigBlock allocation according to the number of segments */
+  struct SigSegment *newSig, *origSig;
+  if(bpa->sigBlocks)
+  {
+    new->sigBlocks = sigBlock_New();
+    *new->sigBlocks = *bpa->sigBlocks; // sigBlock struct copy
+
+    newSig = new->sigBlocks->sigSegments = sigSegment_New();
+    origSig = bpa->sigBlocks->sigSegments;
+
+    while (origSig)
+    {
+      *newSig = *origSig;     // sigSegment strcut copy
+
+      /* ski allocation and copy from arg */
+      if(origSig->ski)
+      {
+        newSig->ski = calloc (1, BGPSEC_SKI_LENGTH);
+        memcpy(newSig->ski, origSig->ski, BGPSEC_SKI_LENGTH);
+      }
+
+      /* signature allocation and copy from arg */
+      if(origSig->signature)
+      {
+        newSig->signature = calloc (1, origSig->sigLen);
+        memcpy(newSig->signature, origSig->signature, origSig->sigLen);
+      }
+
+      if(origSig->next)
+      {
+        newSig->next = sigSegment_New();
+        newSig = newSig->next;
+      }
+
+      origSig = origSig->next;
+    } /* while */
+  } /* if - sigBlock */
+
+  new->refcnt = 0;
+  return new;
+}
+
+/**
+ * Instantiate an initialize a new BgpsecPathAttr instance.
+ *
+ * @return the new instantiated BgpsecPathAttr.
+ *
+ * @see bgpsec_path_free
+ */
+static struct BgpsecPathAttr * bgpsec_path_attr_new (void)
+{
+  struct BgpsecPathAttr *new;
+  new = XCALLOC (MTYPE_BGPSEC_PATH, sizeof (struct BgpsecPathAttr));
+  memset(new, 0x0, sizeof(struct BgpsecPathAttr));
+  return new;
+}
+
+/**
+ * Create a complete BgpsecPathAttr structure including all internal
+ * allocations to the pointers.
+ *
+ * @return A fully instantiated BgpsecPathAttr.
+ *
+ * @see bgpsec_path_free
+ */
+static struct BgpsecPathAttr * bgpsec_path_attr_all_new(void)
+{
+  struct BgpsecPathAttr *bpa;
+
+  bpa = bgpsec_path_attr_new();
+  bpa->pathSegments           = pathSegment_New();
+  bpa->sigBlocks              = sigBlock_New();
+  bpa->sigBlocks->sigSegments = sigSegment_New();
+
+  return bpa;
+}
+
+/**
+ * Free the path segment of the segment structure.
+ *
+ * @param seg The secure path segment to be freed
+ *
+ * @see pathSegment_New
+ */
+static void bgpsec_path_segment_free (struct PathSegment *seg)
+{
+  if (seg != NULL)
+  {
+    memset(seg, 0, sizeof(struct PathSegment));
+    XFREE (MTYPE_BGPSEC_PATH_SEG, seg);
+  }
+
+  return;
+}
+
+/**
+ * Free entire chain of segments.
+ *
+ * @param seg The chain of signature segments.
+ */
+static void bgpsec_path_segment_free_all (struct PathSegment *seg)
+{
+  struct PathSegment *prev;
+
+  while (seg != NULL)
+  {
+    prev = seg;
+    seg = seg->next;
+    bgpsec_path_segment_free (prev);
+  }
+}
+
+/**
+ * Frees the allocated memory for the given signature segment.
+ *
+ * @param ss The signature segment to be freed.
+ *
+ * @see sigSegment_New
+ *
+ */
+static void sigSegment_free(struct SigSegment *ss)
+{
+  if (ss != NULL)
+  {
+   // Free the ski
+   if (ss->ski != NULL)
+   {
+     memset( ss->ski, 0, SKI_LENGTH);
+     free(ss->ski);
+   }
+
+   // Free the signature
+   if (ss->signature != NULL)
+   {
+     memset(ss->signature, 0, ss->sigLen);
+     free(ss->signature);
+   }
+
+   memset (ss, 0, sizeof(struct SigSegment));
+   /* but here, call xfree for Signature Segment itself */
+   XFREE (MTYPE_BGPSEC_SIG_SEG, ss);
+  }
+}
+
+/**
+ * Free the complete signature segment chain
+ *
+ * @param ss The signature segment chain.
+ */
+static void sigSegment_free_all(struct SigSegment *ss)
+{
+  struct SigSegment *prev;
+
+  while (ss != NULL)
+  {
+    prev = ss;
+    ss = ss->next;
+    sigSegment_free(prev);
+  }
+}
+
+/**
+ * Free the signature block of the list structure
+ *
+ * @param sb The signature block to be freed.
+ *
+ * @see sigBlock_New
+ */
+static void bgpsec_sigBlock_free (struct SigBlock *sb)
+{
+  if (sb != NULL)
+  {
+    // First free all signature segments
+    sigSegment_free_all(sb->sigSegments);
+    memset (sb, 0, sizeof(struct SigBlock));
+    XFREE (MTYPE_BGPSEC_SIG_BLK, sb);
+  }
+}
+
+/**
+ * free entire chain of Signature_Block segments
+ *
+ * @param sb Free all signature blocks.
+ */
+static void bgpsec_sigBlock_free_all (struct SigBlock *sb)
+{
+  struct SigBlock *prev;
+
+  while (sb != NULL)
+  {
+    prev = sb;
+    sb = sb->next;
+    bgpsec_sigBlock_free (prev);
+  }
+}
+
+/**
+ * Free BGPSEC path attr structure.
+ *
+ * @param bgp The complete
+ *
+ * @see bgpsec_path_attr_all_new
+ */
+void bgpsec_path_free (struct BgpsecPathAttr *bpa)
+{
+  if (bpa != NULL)
+  {
+    bgpsec_path_segment_free_all (bpa->pathSegments);
+    bgpsec_sigBlock_free_all (bpa->sigBlocks);
+
+    memset(bpa, 0, sizeof(struct BgpsecPathAttr));
+    XFREE (MTYPE_BGPSEC_PATH, bpa);
+  }
+}
+
+
+/* Unintern bgpsec path attr from bgpsec path attr bucket. */
+void bgpsec_path_unintern (struct BgpsecPathAttr **pbpa)
+{
+  if (BGP_DEBUG (bgpsec, BGPSEC_DETAIL))
+    zlog_debug("[BGPSEC]  bgpsec_path_unintern function called");
+  struct BgpsecPathAttr *ret;
+  struct BgpsecPathAttr *bpa = *pbpa;
+
+  if (bpa->refcnt)
+    bpa->refcnt--;
+
+  if (bpa->refcnt == 0)
+    {
+      /* This bgpsec path attr must exist in bgpsec path attr hash table. */
+      ret = hash_release (bgpsechash, bpa);
+      assert (ret != NULL);
+      if (BGP_DEBUG (bgpsec, BGPSEC_DETAIL))
+        zlog_debug("[BGPSEC] [%s] bpa: %p will be uninterned ", __FUNCTION__, bpa);
+      bgpsec_path_free (bpa);
+      *pbpa = NULL;
+    }
+}
+
+
+/* Intern allocated bgpsec path attr. */
+struct BgpsecPathAttr *bgpsec_path_intern (struct BgpsecPathAttr *bpa)
+{
+  struct BgpsecPathAttr *find;
+
+  /* Assert this BGPSEC path attr structure is not interned. */
+  assert (bpa->refcnt == 0);
+
+  /* Check bgpsec path attr hash. */
+  find = hash_get (bgpsechash, bpa, bgpsec_path_hash_alloc);
+
+
+  if (find != bpa)
+    bgpsec_path_free (bpa);
+
+  find->refcnt++;
+
+  return find;
+}
+
+
+/**
+ * Allocates memory for the new secure path segment
+ *
+ * @return Return a newly allocates secure path segment
+ *
+ * @see bgpsec_path_segment_free
+ */
+static struct PathSegment* pathSegment_New(void)
+{
+  struct PathSegment *new;
+  new = XCALLOC (MTYPE_BGPSEC_PATH_SEG, sizeof (struct PathSegment));
+  memset(new, 0x00, sizeof(struct PathSegment));
+
+  return new;
+}
+
+/**
+ * Generates and returns a zero initialized ski of length SKI_LENGTH
+ *
+ * @return Generates and returns a zero initialized ski of length SKI_LENGTH
+ */
+static u_int8_t* ski_new()
+{
+  u_int8_t* ski = malloc (SKI_LENGTH);
+  memset(ski, 0, SKI_LENGTH);
+  return ski;
+}
+
+/* signature allocation */
+static void *signature_new(size_t size)
+{
+  u_int8_t* signature;
+  signature = XMALLOC(MTYPE_BGPSEC_SIGNATURE, size);
+  memset(signature, 0, size);
+  return signature;
+//  return calloc (1, size);
+}
+
+/**
+ * Create a new signature segment for the pointer structure.
+ *
+ * @return The signature segment.
+ *
+ * @see sigSegment_free
+ */
+static struct SigSegment* sigSegment_New(void)
+{
+
+  struct SigSegment *new;
+  new = XCALLOC (MTYPE_BGPSEC_SIG_SEG, sizeof (struct SigSegment));
+  memset(new, 0x00, sizeof(struct SigSegment));
+
+  return new;
+}
+
+/**
+ * Generate a new Signature Block for the pinter structure.
+ *
+ * @return The new created signature block
+ *
+ * @see bgpsec_sigBlock_free
+ */
+static struct SigBlock* sigBlock_New(void)
+{
+  struct SigBlock *new;
+  new = XCALLOC (MTYPE_BGPSEC_SIG_BLK, sizeof (struct SigBlock));
+  memset(new, 0x00, sizeof(struct SigBlock));
+
+  return new;
+}
+
+
+/**
+ * This function parses the byte stream and generates the internal
+ * bgpsecPathAttr structure. In case the handed update is malformed no
+ * bgpsecPathAttr is generated and the return value is NULL
+ *
+ * @param attr The attribute.
+ * @param peer The bgpsec session information
+ * @param s The stream containing the attribute information.
+ * @param length total length of bgpsec pdu including Secure_Path and Signature_Block
+ *
+ * @return The BgpsecPathAttr as pointer structure or NULL in case the BGPSEC
+ *         attribute is malformed.
+ */
+struct BgpsecPathAttr* bgpsec_parse(struct attr *attr, struct peer *peer,
+                                    struct stream *s, size_t length)
+{
+  // @INFO:  The pointer structure makes sense for generation of the sending out
+  //         attribute.
+  u_char* startp = NULL;
+  u_char* endp   = NULL;
+//  struct stream *s = peer->ibuf;
+  size_t start_getp = 0;
+  size_t start_endp = 0;
+  // This is the secure path pointer
+  size_t spp = 0;
+  // This is the secure block pointer
+  size_t sbp = 0;
+
+  /* sanity check */
+  // @TODO: Add the correct sanity check as specified in the DRAFT, This means
+  //        Check the existence of max 2 signature blocks etc.
+  if ((STREAM_READABLE(s) < length) || (length <= 0))
+  {
+    zlog_err("bad bgpsec packet - length mismatch");
+    return NULL;
+  }
+
+  startp     = BGP_INPUT_PNT (peer); // current address pointer
+  start_getp = stream_get_getp (s);
+  start_endp = stream_get_endp (s);
+  endp       = startp + length;
+
+  if (BGP_DEBUG (bgpsec, BGPSEC_IN) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
+  {
+    zlog_debug("[IN] %p -  startp: %p-- getp:%d endp:%d -- endp(startp+length):%p length:%d ", \
+        stream_pnt(s), startp, (int)start_getp, (int)start_endp, endp, (int)length);
+  }
+
+  // Retrieving the prefix is not needed anymore, this function just does
+  // Syntax check and generation of the helper structure.
+  int numSecurePathSegment = 0;
+
+  if (BGP_DEBUG (bgpsec, BGPSEC_IN) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
+  {
+    zlog_debug("[IN] peer as:%d peer->local_as:%d Secure_Path Len:%d",\
+        peer->as, peer->local_as, stream_getw_from(s, start_getp));
+  }
+
+  /* calculation of total aspath length using SecurePath Len */
+  u_int16_t spl    = stream_getw_from(s, start_getp);
+  u_int16_t numSeg = 0;
+
+  if ( (spl-OCTET_SECURE_PATH_LEN) % OCTET_SECURE_PATH_SEGMENT != 0)
+  {
+    zlog_err(" SecurePath Length parsing error");
+    return NULL;
+  }
+
+  numSeg = (spl - OCTET_SECURE_PATH_LEN) / OCTET_SECURE_PATH_SEGMENT;
+
+  struct BgpsecPathAttr* bpa = NULL;
+  struct PathSegment *seg;
+  struct SigBlock    *sb;
+
+  bool syntaxError = false;
+
+  /*
+   * If this is the originating AS
+   */
+  // @INFO: OK this is wrong. if numSeg is < 2 this does not mean that this is
+  // the originator. numSeg is also < 2 if this is the second hop. I will modify
+  // the code in such that it uses the iteration in both parts.
+  /*
+   * in case not origin as, which means transit router
+   */
+  // It is a transit AS, it received this attribute.
+  u_short iter;
+  struct PathSegment  *prev = NULL, *head = NULL;
+
+  /* BGPSEC_Path Attribute and others */
+  bpa = bgpsec_path_attr_new();
+  /* Secure_Path len */
+  bpa->securePathLen = stream_getw(s);
+
+  /* Secure_Path length includes two octets used to express its own length field */
+  iter = numSecurePathSegment =
+    (bpa->securePathLen - OCTET_SECURE_PATH_LEN) / OCTET_SECURE_PATH_SEGMENT;
+
+  /* read the multiple Secure_Path Segments */
+  while(iter)
+  {
+    // Check we have enough bytes left
+    if (STREAM_READABLE(s) < OCTET_SECURE_PATH_SEGMENT)
+    {
+      syntaxError = true;
+      break;
+    }
+    seg = pathSegment_New();
+
+    /* concatenating */
+    if (prev)
+    {
+      prev->next = seg;
+    }
+    else
+    {
+      bpa->pathSegments = head = seg;
+    }
+
+    // Moved AS down, DRAFT 15
+    seg->pCount = stream_getc(s);
+    seg->flags  = stream_getc(s);
+    seg->as     = stream_getl(s);
+
+    if (BGP_DEBUG (bgpsec, BGPSEC_IN) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
+    {
+      zlog_debug("[IN]  Secure_Path segment --> %d AS:%d", iter, seg->as);
+    }
+
+    prev = seg;
+
+    iter--;
+  } /* end of while */
+
+  // @INFO: I don't really know the meaning of the comment below but for now,
+  // I let it stand and do check during debug what is going on. Also very
+  // important here is to make sure that we have a maximum of 2 signature blocks
+  // if we have more, we encountered a syntax error and have to clean up all our
+  // data.
+  /*
+   * TODO: the code for parsing the 2nd Signature Block(sb2)
+   * But, here, just assumed one Sigature Block received.
+  */
+  struct SigSegment *ss_prev = NULL, *ss_curr = NULL;
+
+  // @INFO Now add my change of parsing through the signature block. Also add
+  // the RFC required syntax check.
+  if (STREAM_READABLE(s) < 1)
+  {
+    syntaxError = true;
+  }
+
+  int numSigBlocks = 0;
+  while (STREAM_READABLE(s) > 0)
+  {
+    numSigBlocks++;
+    if (numSigBlocks > BGPSEC_MAX_SIGBLOCK)
+    {
+      syntaxError = true;
+      break;
+    }
+    // Now generate the BgpsecPathAttribtue Signature block structure.
+    if (bpa->sigBlocks == NULL)
+    {
+      // This is the first signature block
+      sb = bpa->sigBlocks = sigBlock_New(); // new Signature_Block instance
+    }
+    else
+    {
+      sb->next = sigBlock_New();
+      sb = sb->next;
+    }
+
+    sb->sigBlockLen = stream_getw(s);   // Signature_Block Length incl. this field.
+    if ((sb->sigBlockLen-2) > STREAM_READABLE(s))
+    {
+      // Length field contains invalid value.
+      syntaxError = true;
+      break;
+    }
+    sb->algoSuiteId     = stream_getc(s);   // Algorithm Suite Identifier
+    // The remaining bytes for the signature segments
+    u_int16_t remainingBytes = sb->sigBlockLen - 3;
+
+    if (BGP_DEBUG (bgpsec, BGPSEC_IN) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
+    {
+      zlog_debug("[IN] Secure_Block --> %d, AlgoID: %u, Length: %u",
+                 numSigBlocks, sb->algoSuiteId, sb->sigBlockLen);
+    }
+
+    int numSignatures = 0;
+  // @INFO: Actually according to the RFC we need to parse according to the
+  // block length, not blindly through the number of segments. This is false.
+  // Only this way we can detect a structural error with the update.
+    while (remainingBytes > 0)
+    {
+      numSignatures++;
+      if (sb->sigSegments == NULL)
+      {
+        sb->sigSegments = sigSegment_New();
+        ss_prev = NULL;
+        ss_curr = sb->sigSegments;
+      }
+      else
+      {
+        ss_prev->next = sigSegment_New();
+        ss_curr = ss_prev->next;
+      }
+      ss_prev = ss_curr;
+
+      ss_curr->ski = ski_new();
+      stream_get(ss_curr->ski, s, SKI_LENGTH); // SKI
+      remainingBytes -= SKI_LENGTH;
+      ss_curr->sigLen = stream_getw(s);        // Signature Length
+      remainingBytes -= 2;
+
+      if (STREAM_READABLE(s) < ss_curr->sigLen)
+      {
+        // Invalid signature length
+        zlog_err("Bad bgpsec signatUre length: bigger than remaining byte");
+        syntaxError = true;
+        break;
+      }
+
+      ss_curr->signature = signature_new(ss_curr->sigLen);
+      stream_get(ss_curr->signature, s, ss_curr->sigLen);     // signature
+      remainingBytes -= ss_curr->sigLen;
+
+      if (BGP_DEBUG (bgpsec, BGPSEC_IN) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
+      {
+        zlog_debug("[IN]    signature --> %d, Length: %u",
+                   numSignatures, ss_curr->sigLen);
+      }
+    }
+    if (numSignatures != numSecurePathSegment)
+    {
+      zlog_err("Number signatures does not match number secure path segments");
+      syntaxError = true;
+      break;
+    }
+  }
+
+  if (syntaxError)
+  {
+    // cleanup
+    bgpsec_path_free(bpa);
+    bpa = NULL;
+  }
+
+  if (BGP_DEBUG (bgpsec, BGPSEC_IN) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
+  {
+    zlog_debug("[IN]  %s: return value(final bpa): %p", __FUNCTION__, bpa);
+  }
+
+  return bpa;
+}
+
+/**
+ * This method does call the signing of the BGPSEC path attribute. This method
+ * assumes that the peer is NOT an iBGP peer.
+ *
+ * @param bgp The bgp session.
+ * @param peer The peer to sign it too
+ * @param pfx The prefix to sign over (only for origin anouncements)
+ * @param attr The attribute containing the path information.
+ * @param pCount The pCount of this update
+ * @param flags the update flags.
+ *
+ * @return The generated signature. If managed by the SrxCryptoAPI module
+ *         then it must be freed by the crypto module, otherwise it can be freed
+ *         using sca_freeSignature or manual using free etc.
+ *
+ * @see srxcryptoapi.h:sca_freeSignature
+ */
+SCA_Signature* signBGPSecPathAttr(struct bgp* bgp, struct peer* peer,
+                                  struct prefix* pfx, struct attr* attr,
+                                  u_int8_t pCount, u_int8_t flags)
+{
+  // @TODO: The current implementation only deals with one hash message,
+  //        modify this by using both - Then remove the two defines below
+#define BLOCK_0 0
+#define BLOCK_1 1
+
+  // This is used to determine if the bgpsec_validation data is temp or not.
+  // The data will be set to temporary for originations only.
+  // See BZ#1022
+  bool tmpData = false;
+
+  if (bgp->srxCAPI == NULL)
+  {
+    return NULL;
+  }
+
+  // If this is the originator, nothing might exist yet, no bgpsec_path_attr,
+  // no valdata etc. If nothing exist we have to build it, it it exists
+  // we can use it.
+
+  as_t targetAS = htonl(peer->as);
+  as_t localAS  = htonl(bgp->as);
+
+  // @TODO: here we would need some more info about a pCount > 0
+  SCA_BGPSEC_SecurePathSegment spSeg;
+  spSeg.pCount = pCount;
+  spSeg.flags  = flags;
+  spSeg.asn    = htonl(bgp->as);
+
+  // Removed ski str to bin conversion. this is now done during configuration.
+
+  if (attr->bgpsec_validationData == NULL)
+  {
+    // This will be the case if the update never was send out before - it mainly
+    // is an origination..
+    attr->bgpsec_validationData = malloc(sizeof(SCA_BGPSecValidationData));
+    memset(attr->bgpsec_validationData, 0, sizeof(SCA_BGPSecValidationData));
+    tmpData = true;
+  }
+  // @TODO: I think [0] cannot be NULL and [1] be filled. At least this would
+  //        not make sense. At this point we anyhow only work with [0] until one
+  //        of the near future updates.
+
+  // The idea here is that if we have no hash message, the API needs to generate
+  // it. Now lets make sure the API has all information needed to do so.
+  if (attr->bgpsec_validationData->hashMessage[0] == NULL)
+  {
+    // So the validation data is not available - check if we have a bgpsec path
+    // attribute where we can generate the hash message from.
+    if (attr->bgpsec_validationData->bgpsec_path_attr == NULL)
+    {
+      // Ok it seems we don't have any data prepared. This is the case if we
+      // originate an update. Store the data needed.
+      if (attr->bgpsec_validationData->nlri == NULL)
+      {
+        // @TODO Maybe use XMALLOC with a Quagga MEMORY type
+        attr->bgpsec_validationData->nlri = malloc(sizeof(SCA_Prefix));
+        memset(attr->bgpsec_validationData->nlri, 0, sizeof(SCA_Prefix));
+        attr->bgpsec_validationData->nlri->afi    = htons(family2afi(pfx->family));
+        attr->bgpsec_validationData->nlri->safi   = SAFI_UNICAST;
+
+        attr->bgpsec_validationData->nlri->length = (u_int8_t)pfx->prefixlen;
+        int bLen = (pfx->prefixlen + 7) / 8;
+        memcpy(attr->bgpsec_validationData->nlri->addr.ip, pfx->u.val, bLen);
+      }
+
+    }
+  }
+
+  SCA_BGPSecSignData  scaSignData;
+  memset (&scaSignData, 0, sizeof(SCA_BGPSecSignData));
+
+  // Use the algorithm ID associated with the specified private key.
+  scaSignData.algorithmID = bgp->srx_bgpsec_key[bgp->srx_bgpsec_active_key].algoID;
+  scaSignData.myHost      = &spSeg;
+  scaSignData.peerAS      = targetAS;
+  scaSignData.nlri        = attr->bgpsec_validationData->nlri;
+  scaSignData.ski         = bgp->srx_bgpsec_key[bgp->srx_bgpsec_active_key].ski;
+  scaSignData.status      = API_STATUS_OK;
+  // Get the hash Message, if it was received and already validated, the
+  // hashMessage will not be NULL. If it is null, the signature algorithm
+  // assumes it is an origination.
+  scaSignData.signature   = NULL;
+  if ( CHECK_FLAG(bgp->srx_config, SRX_CONFIG_EVAL_DISTR))
+  {
+  /* hash message for Distribution version */
+  if (!tmpData) // in case, only if not origin for now
+    sca_generateHashMessage(attr->bgpsec_validationData,
+        SCA_ECDSA_ALGORITHM, &attr->bgpsec_validationData->status);
+  }
+  scaSignData.hashMessage = attr->bgpsec_validationData->hashMessage[BLOCK_0];
+
+
+  // Now do the signing. If it fails, cleanup what needs to be clean up
+  // and return 0
+  if (bgp->srxCAPI->sign(&scaSignData) == API_FAILURE)
+  {
+    zlog_err("[BGPSEC] Signing the bgpsec path to peer %u failed status (0x%X)\n",
+            peer->as, scaSignData.status);
+    if (attr->bgpsec_validationData->hashMessage[BLOCK_0] == NULL)
+    {
+      // We only need to clean up if the validation data was generated during
+      // this call
+      if (!bgp->srxCAPI->freeHashMessage(scaSignData.hashMessage))
+      {
+        // Now try to clean up - Normally we should not get here in the first
+        // place.
+        freeSCA_HashMessage(scaSignData.hashMessage);
+      }
+      scaSignData.hashMessage = NULL;
+    }
+    return 0;
+  }
+
+  if ( !CHECK_FLAG(bgp->srx_config, SRX_CONFIG_EVAL_DISTR))
+  {
+  if (attr->bgpsec_validationData->hashMessage[BLOCK_0] != scaSignData.hashMessage)
+  {
+    if (attr->bgpsec_validationData->hashMessage[BLOCK_0] != NULL)
+    {
+      if (!bgp->srxCAPI->freeHashMessage(attr->bgpsec_validationData->hashMessage[BLOCK_0]));
+      {
+        freeSCA_HashMessage(attr->bgpsec_validationData->hashMessage[BLOCK_0]);
+      }
+      attr->bgpsec_validationData->hashMessage[BLOCK_0] = NULL;
+    }
+
+    // Now store the new hash message - only if this is NOT an origin announcement
+    if (!tmpData)
+    {
+      attr->bgpsec_validationData->hashMessage[BLOCK_0] = scaSignData.hashMessage;
+    }
+    else
+    {
+      freeSCA_HashMessage(scaSignData.hashMessage);
+    }
+  }
+  }
+
+  if (tmpData)
+  {
+    // THis is an origin announcement, clean up
+    free (attr->bgpsec_validationData->nlri);
+    attr->bgpsec_validationData->nlri = NULL;
+    free (attr->bgpsec_validationData);
+    attr->bgpsec_validationData = NULL;
+    scaSignData.hashMessage = NULL;
+  }
+
+  return scaSignData.signature;
+}
+
+/**
+ * Construct the BGPSEC Path attribute. This includes signing the as path if it
+ * is not signed already.
+ * This function writes the data into the stream.
+ *
+ * @param bgp    The bgp session
+ * @param peer   The peer information
+ * @param aspath Pointer to the bgp4 as path representing the bgpsec path.
+ * @param p      The prefix
+ * @param s      The stream
+ * @param attr   The bgp attribute.
+ *
+ * @return The length of the attribtue
+ */
+int constructBGPSecPathAttribute(struct bgp *bgp, struct peer *peer,
+                                 struct aspath *aspath, struct prefix* p,
+                                 struct stream *s, struct attr *attr,
+                                 u_int8_t flags, u_int8_t pCount,
+                                 SCA_Signature** signatures, int numSignatures)
+{
+  size_t attrLenPtr = stream_get_endp(s);
+  // We already established that we do bgpsec and if internal, We already
+  // forwarded the traffic.
+  //
+  struct BgpsecPathAttr* bpa = bgpsecDup(attr->bgpsecPathAttr, true);
+  // Create the secure path
+  uint16_t secPathLen = LEN_SECPATHSEGMENT
+                        + ((bpa->securePathLen == 0) ? 2 : bpa->securePathLen);
+  stream_putw (s, secPathLen);
+
+  // Now add my own signature path segment
+  int numPathSegments = 1;
+  stream_putc (s, pCount);
+  stream_putc (s, flags);
+  stream_putl (s, bgp->as); // Check if these values have to be put in network format.
+  struct PathSegment* pSeg = bpa->pathSegments;
+  while (pSeg != NULL)
+  {
+    numPathSegments++;
+    stream_putc (s, pSeg->pCount);
+    stream_putc (s, pSeg->flags);
+    stream_putl (s, pSeg->as);
+    pSeg = pSeg->next;
+  }
+
+  int sigIdx = 0;
+  struct SigBlock* sigBlock = NULL;
+  // The prevBlock is used to allow removing the signature block.
+  // if we remove a signature block we might need to allow taking it out of the
+  // list. OK currently the list MUST NOT exceed two segments but this might
+  // change in the future - So I just prepare that.
+  struct SigBlock* prevBlock = NULL;
+  // Now add the signature block(s) - one for each signature generated.
+  SCA_Signature* signature = NULL;
+  for (sigIdx = 0; sigIdx < numSignatures; sigIdx++)
+  {
+    sigBlock  = bpa->sigBlocks;
+    prevBlock = sigBlock;
+    signature = signatures[sigIdx];
+
+    // Now locate the correct signature block that matches the signature.
+    // What about if we have more signature block with the same signature ID?????
+    // Maybe we have to remove the block once we found it?
+    while ((sigBlock != NULL) && (sigBlock->algoSuiteId != signature->algoID))
+    {
+      sigBlock  = sigBlock->next;
+      prevBlock = sigBlock;
+    }
+    if (sigBlock == NULL)
+    {
+      if (numPathSegments != 1)
+      {
+        zlog_err("[BGPSEC] no path segments, something went completely wrong!\n");
+        return 0;
+      }
+      // OK we are originating.
+
+      // Now generate a signature block for the signature we just generated
+      sigBlock  = sigBlock_New();
+      prevBlock = NULL;
+      sigBlock->algoSuiteId = signature->algoID;
+    }
+
+    // store the stream position to later determine the length of the block
+    size_t sbPointer = stream_get_endp (s);
+    stream_putw (s, 0); // Store a dummy as signature block length and come back
+                        // and store the correct value.
+    stream_putc (s, sigBlock->algoSuiteId);
+
+    // Now store latest generated signature
+    stream_put  (s, signature->ski, SKI_LENGTH);
+    stream_putw (s, signature->sigLen);
+    stream_put  (s, signature->sigBuff, signature->sigLen);
+
+    // Now add the remaining signatures to the block
+    struct SigSegment* sigSeg = sigBlock->sigSegments;
+    while (sigSeg != NULL)
+    {
+      stream_put  (s, sigSeg->ski, SKI_LENGTH);
+      stream_putw (s, sigSeg->sigLen);
+      stream_put  (s, sigSeg->signature, sigSeg->sigLen);
+      sigSeg = sigSeg->next;
+    }
+
+    // Now calculate the signatrue block length
+    size_t sbEndPointer = stream_get_endp(s);
+    uint16_t sbLength = (uint16_t)(sbEndPointer - sbPointer);
+    //stream_putw_at (s, sizep_PathLen, tmpBpa->securePathLen); // Secure_Path Len
+    stream_putw_at (s, sbPointer, sbLength); // Secure_Path Len
+
+    if (bpa->sigBlocks == sigBlock)
+    { // This block was the first one, move the head
+      bpa->sigBlocks = sigBlock->next;
+    }
+    else if (prevBlock != NULL)
+    { // The block was not the first one. In case the list exceeds two blocks we
+      // might be somewhere in the middle. Now point the previous block to the
+      // next one
+      prevBlock->next = sigBlock->next;
+    }
+    // Now we can remove the signature block
+    bgpsec_sigBlock_free(sigBlock);
+    sigBlock = NULL;
+  }
+  // Now set the length of the attribute
+  size_t endPtr = stream_get_endp(s);
+  uint16_t attrLen = (uint16_t)(endPtr - attrLenPtr);
+  bgpsec_path_free(bpa);
+  bpa = NULL;
+
+  return attrLen;
+}
+
+void test_print(struct BgpsecPdu pdu, size_t *bptr, char *sigbuff, char* hashbuff, size_t psize)
+{
+    unsigned int i=0;
+    printf(" \n %s: \n ", __FUNCTION__);
+    printf("Secure_Path length: %d", pdu.len_SecurePath);
+    printf(" - ASnum: %d \n", pdu.asNum);
+    printf(" - pcount: %d \n", pdu.pCount);
+    printf(" - flags: %d \n\n", pdu.flags);
+    printf("Signature_Block length: %d(0x%02x) \n", pdu.len_SigBlock, pdu.len_SigBlock);
+    printf(" - Algorithm Suite ID: %d \n", pdu.algoSuiteId);
+    printf(" - SKI: %p [bptr:%p]\n", pdu.ski, bptr);
+    for(;i<BGPSEC_SKI_LENGTH; i++)
+      printf("%02X ", *pdu.ski++);
+    printf("\n");
+    printf(" - sig length: %d \n", pdu.len_Sig);
+    printf(" - signature: \n");
+
+    for(i=0; i<pdu.len_Sig; i++ )
+    {
+      if(i%16 ==0) printf("\n");
+      printf("%02x ", (unsigned char)sigbuff[i]);
+    }
+    printf("\n");
+    for( i=0; i<psize; i++)
+      printf("%02x ", hashbuff[12+i]);
+    printf(" -- hash prefix\n");
+
+    printf("-- all verify hashbuff\n");
+    for(i=0; i<12+psize; i++)
+      printf("%02x ", hashbuff[i]);
+    printf("\n");
+}
+
+
+/**
+ * Print the given information using std-io
+ *
+ * @param bpa The BgpsecPathAttr.
+ */
+void print_signature(struct BgpsecPathAttr *bpa)
+{
+  //struct BgpsecPathAttr *new_bpa;
+  struct PathSegment *seg = bpa->pathSegments;
+  struct SigBlock *sb = bpa->sigBlocks;
+  struct SigSegment *ss = sb->sigSegments;
+
+  if(seg && sb && ss);
+
+  int i;
+  int sig_length = ss->sigLen;
+
+  if(zlog_default->maxlvl[ZLOG_DEST_STDOUT] > 0)
+  {
+  /* signature print out */
+    for(i=0; i<sig_length; i++ )
+    {
+      if(i%16 ==0) printf("\n");
+      printf("%02x ", (unsigned char)ss->signature[i]);
+    }
+    printf(" - from[%s]\n", __FUNCTION__);
+  }
+}
+
+int bgpsecSanityCheck(struct BgpsecPathAttr *bpa)
+{
+  struct PathSegment *seg;
+  struct SigBlock *sb;
+  struct SigSegment *ss;
+
+  if(!bpa)
+    return -1;
+
+  seg = bpa->pathSegments;
+  sb  = bpa->sigBlocks;
+
+  if(!seg || !sb)
+    return -1;
+
+  ss = sb->sigSegments;
+
+  if(!ss)
+    return -1;
+
+  if(!ss->signature || !ss->ski)
+    return -1;
+
+  return 0;
+}
+
+/**
+ * This function duplicate the original attribute and its sub structures into a
+ * new instance or generate a new empty one if requested. Freeing the memory
+ * of the original one does NOT affect the duplicate.
+ *
+ * @param orig The original bgpsec path attribute (can be NULL)
+ * @param newIfNULL generate a new empty structure if the original one is NULL.
+ *
+ * @return A copy of the given structure or a new one if the original is NULL
+ *         and the attribute newIfNULL is set to true.
+ */
+struct BgpsecPathAttr * bgpsecDup(struct BgpsecPathAttr *orig, bool newIfNULL)
+{
+  struct BgpsecPathAttr* new = NULL;
+
+  if(bgpsecSanityCheck(orig) == 0)
+  {
+    /* pointer links */
+    new = bgpsec_path_attr_all_new();
+
+    new->securePathLen = orig->securePathLen;
+
+    /* concatenation of Path_Segment */
+    concatPathSegment(new->pathSegments, orig->pathSegments);
+
+    /* concatenation of Sigature_Blocks and Signature_Segment inside this function */
+    concatSigBlock(new->sigBlocks, orig->sigBlocks);
+  }
+  else if ((new == NULL) && newIfNULL)
+  {
+    new = bgpsec_path_attr_new();
+  }
+
+  return new;
+}
+
+void concatSigSegment(struct SigSegment* const new, struct SigSegment * const orig)
+{
+  struct SigSegment *src = orig;
+  struct SigSegment *pnt = new;
+
+  while(pnt)
+  {
+    /* ski allocation and copy from original */
+    pnt->ski = calloc (1, BGPSEC_SKI_LENGTH);
+    assert(src->ski);
+    memcpy(pnt->ski, src->ski, BGPSEC_SKI_LENGTH);
+
+    pnt->sigLen = src->sigLen;
+
+    /* signature allocation and copy from original */
+    pnt->signature = calloc (1, src->sigLen);
+    assert(src->signature);
+    memcpy(pnt->signature, src->signature, src->sigLen);
+
+    if(src->next)
+    {
+      src       = src->next;
+      pnt->next = sigSegment_New();
+    }
+
+    pnt = pnt->next;
+  }
+
+}
+
+void concatSigBlock(struct SigBlock* const new, struct SigBlock * const orig)
+{
+
+  struct SigBlock *src = orig;
+  struct SigBlock *pnt = new;
+
+  while(pnt)
+  {
+    pnt->sigBlockLen = src->sigBlockLen;
+    pnt->algoSuiteId = src->algoSuiteId;
+
+    concatSigSegment(pnt->sigSegments, src->sigSegments);
+
+    if(src->next)
+    {
+      src       = src->next;
+      pnt->next = sigBlock_New();
+    }
+
+    pnt = pnt->next;
+  }
+
+}
+
+void concatPathSegment(struct PathSegment * const new_seg,
+                       struct PathSegment * const orig)
+{
+
+  /* concatenation of path segemnts */
+  struct PathSegment *src = orig;
+  struct PathSegment *pntSeg = new_seg;
+
+  while(pntSeg)
+  {
+    pntSeg->as       = src->as;
+    pntSeg->pCount   = src->pCount;
+    pntSeg->flags    = src->flags;
+
+    if(src->next)
+    {
+      src = src->next;
+      pntSeg->next = pathSegment_New();
+    }
+
+    pntSeg = pntSeg->next;
+  }
+
+}
+
+
+/**
+ * @brief convert into binary value, faster than stdio functions
+ *
+ * @param in one byte of hex ascii
+ *
+ * @return one byte of binary data
+ */
+#define CHAR_CONV_CONST     0x37
+#define DIGIT_CONV_CONST    0x30
+#define LEN_BYTE_NIBBLE     0x02
+
+unsigned char hex2bin_byte(char* in)
+{
+  unsigned char result=0;
+  int i=0;
+  for(i=0; i < LEN_BYTE_NIBBLE; i++)
+  {
+    if(in[i] > 0x40)
+      result |= ((in[i] - CHAR_CONV_CONST) & 0x0f) << (4-(i*4));
+    else if(in[i] > 0x30 && in[i] < 0x40)
+      result |= (in[i] - DIGIT_CONV_CONST) << (4-(i*4));
+  }
+  return result;
+}
+
+/**
+ * This function is a wrapper for the corresponding CAPI function. This function
+ * is needed to allow the memory management performed by the CAPI itself.
+ *
+ * @param message The hashInput to be freed.
+ *
+ * @since 0.4.2.0
+ */
+void freeSCA_HashMessage(SCA_HashMessage* message)
+{
+  if (g_capi != NULL)
+  {
+    if (g_capi->freeHashMessage(message))
+    {
+      message = NULL;
+    }
+  }
+  if (message != NULL)
+  {
+    sca_freeHashInput(message);
+  }
+}
+
+
+
+
+#endif /* USE_SRX */
--- ./bgpd/bgp_vty.c	2013-02-01 11:55:27.000000000 -0500
+++ ./bgpd/bgp_vty.c	2017-07-05 12:04:09.000000000 -0400
@@ -19,6 +19,9 @@ Software Foundation, Inc., 59 Temple Pla
 02111-1307, USA.  */
 
 #include <zebra.h>
+#ifdef USE_SRX
+#include <srx/srxcryptoapi.h>
+#endif
 
 #include "command.h"
 #include "prefix.h"
@@ -49,6 +52,7 @@ Software Foundation, Inc., 59 Temple Pla
 #include "bgpd/bgp_table.h"
 #include "bgpd/bgp_vty.h"
 #include "bgpd/bgp_mpath.h"
+#include "bgp_validate.h"
 
 extern struct in_addr router_id_zebra;
 
@@ -1390,6 +1394,987 @@ ALIAS (no_bgp_default_local_preference,
        "local preference (higher=more preferred)\n"
        "Configure default local preference value\n")
 
+#ifdef USE_SRX
+DEFUN (srx_show_config,
+       srx_show_config_cmd,
+       SRX_VTY_CMD_SHOW_CONFIG,
+       SRX_VTY_HLP_SHOW_CONFIG)
+{
+  #define _BLANKS "                   "
+  struct bgp *bgp;
+  int doPolicy;
+
+  bgp      = vty->index;
+  doPolicy = 0;
+
+  vty_out (vty, "SRx-Server configuration settings:%s", VTY_NEWLINE);
+  vty_out (vty, "  srx-server.....: %s%s", bgp->srx_host, VTY_NEWLINE);
+  vty_out (vty, "  port...........: %d%s", bgp->srx_port, VTY_NEWLINE);
+  vty_out (vty, "  proxy-id.......: 0x%08X (%u.%u.%u.%u - %u)%s",
+           bgp->srx_proxyID,
+           (bgp->srx_proxyID >> 24) & 0xFF,
+           (bgp->srx_proxyID >> 16) & 0xFF,
+           (bgp->srx_proxyID >>  8) & 0xFF,
+           (bgp->srx_proxyID) & 0xFF, bgp->srx_proxyID, VTY_NEWLINE);
+  vty_out (vty, "  keep-window....: %d%s", bgp->srx_keepWindow, VTY_NEWLINE);
+  vty_out (vty, "  connected......: %s%s", (isConnected(bgp->srxProxy)
+                                          ? "true" : "false"), VTY_NEWLINE);
+
+  vty_out (vty, "BGPSEC configuration settings:%s", VTY_NEWLINE);
+  vty_out (vty, "  active key.....: %u%s", bgp->srx_bgpsec_active_key,
+           VTY_NEWLINE);
+  int kIdx = 0;
+  int bIdx = 0;
+  char skiStr[SKI_HEX_LENGTH+1];
+  char*skiPtr;
+  for (; kIdx < SRX_MAX_PRIVKEYS; kIdx++)
+  {
+    memset(skiStr, '\0', SKI_HEX_LENGTH+1);
+    skiPtr = skiStr;
+    for (bIdx = 0; bIdx < SKI_LENGTH; bIdx++)
+    {
+      skiPtr += sprintf(skiPtr, "%02X", bgp->srx_bgpsec_key[kIdx].ski[bIdx]);
+    }
+    vty_out (vty, "  Private key %u %sactive%s", kIdx,
+             bgp->srx_bgpsec_active_key == kIdx ? "- ":"- in", VTY_NEWLINE);
+    vty_out (vty, "  - algorith-id..: %u%s", bgp->srx_bgpsec_key[kIdx].algoID,
+             VTY_NEWLINE);
+    vty_out (vty, "  - ski..........: %s%s", skiStr, VTY_NEWLINE);
+    vty_out (vty, "  - DER-loaded...: %s%s",
+            bgp->srx_bgpsec_key[kIdx].keyLength > 0 ? "yes":"no", VTY_NEWLINE);
+  }
+
+  vty_out (vty, "SRx Router Configuration settings:%s", VTY_NEWLINE);
+  vty_out (vty, "  evaluation.....: ");
+  if (CHECK_FLAG(bgp->srx_config, SRX_CONFIG_EVAL_PATH))
+  {
+    if (CHECK_FLAG(bgp->srx_config, SRX_CONFIG_EVAL_DISTR))
+    {
+      vty_out (vty, "bgpsec (prefix-origin and path processing) using "
+                    "srx-server%s", VTY_NEWLINE);      
+    }
+    else
+    {
+      vty_out (vty, "bgpsec (prefix-origin and path processing) locally%s", 
+               VTY_NEWLINE);
+    }
+  }
+  else if (CHECK_FLAG(bgp->srx_config, SRX_CONFIG_EVAL_ORIGIN))
+  {
+    vty_out (vty, "origin_only (prefix-origin processing)%s", VTY_NEWLINE);
+  }
+  else
+  {
+    vty_out (vty, "disabled!%s", VTY_NEWLINE);
+  }
+
+  // Default value for origin validation
+  vty_out (vty, "  default value..: (origin) ");
+  switch (bgp->srx_default_roaVal)
+  {
+    case SRx_RESULT_VALID:
+      vty_out (vty, "  v = valid%s", VTY_NEWLINE); break;
+    case SRx_RESULT_NOTFOUND:
+      vty_out (vty, "  n = notfound%s", VTY_NEWLINE); break;
+    case SRx_RESULT_INVALID:
+      vty_out (vty, "  i = invalid%s", VTY_NEWLINE); break;
+    case SRx_RESULT_UNDEFINED:
+      vty_out (vty, "  ? = undefined%s", VTY_NEWLINE); break;
+    default:
+      vty_out (vty, "  invalid value%s", VTY_NEWLINE);
+  }
+
+  // Default value for path validation
+  vty_out (vty, "  default value..: ( path ) ");
+  switch (bgp->srx_default_bgpsecVal)
+  {
+    case SRx_RESULT_VALID:
+      vty_out (vty, "  v = valid%s", VTY_NEWLINE); break;
+    case SRx_RESULT_INVALID:
+      vty_out (vty, "  i = invalid%s", VTY_NEWLINE); break;
+    case SRx_RESULT_UNDEFINED:
+      vty_out (vty, "  ? = undefined%s", VTY_NEWLINE); break;
+    default:
+      vty_out (vty, "  invalid value%s", VTY_NEWLINE);
+  }
+
+   // always active
+  vty_out (vty, "  policy.........: ");
+  if (bgp->srx_val_policy & SRX_VAL_POLICY_IGNORE_NOTFOUND)
+  {
+    vty_out (vty, "%signore-notfound%s", (doPolicy ? _BLANKS : ""),VTY_NEWLINE);
+    doPolicy = 1;
+  }
+  if (bgp->srx_val_policy & SRX_VAL_POLICY_IGNORE_INVALID)
+  {
+    vty_out (vty, "%signore-invalid%s", (doPolicy ? _BLANKS : ""), VTY_NEWLINE);
+    doPolicy = 1;
+  }
+  if (bgp->srx_val_policy & SRX_VAL_POLICY_IGNORE_UNDEFINED)
+  {
+    vty_out (vty, "%signore-undefined%s", (doPolicy ? _BLANKS : ""),
+             VTY_NEWLINE);
+    doPolicy = 1;
+  }
+  if (bgp->srx_val_local_pref[VAL_LOCPRF_VALID].is_set)
+  {
+    vty_out (vty, "%slocal-preference valid %d", (doPolicy ? _BLANKS : ""),
+                  bgp->srx_val_local_pref[VAL_LOCPRF_VALID].value);
+    switch (bgp->srx_val_local_pref[VAL_LOCPRF_VALID].relative)
+    {
+      case -1 : vty_out (vty, " SUBTRACT%s", VTY_NEWLINE); break;
+      case  1 : vty_out (vty, " ADD%s", VTY_NEWLINE); break;
+      default: vty_out (vty, "%s", VTY_NEWLINE);
+    }
+    doPolicy = 1;
+  }
+  if (bgp->srx_val_local_pref[VAL_LOCPRF_NOTFOUND].is_set)
+  {
+    vty_out (vty, "%slocal-preference notfound %d", (doPolicy ? _BLANKS : ""),
+                  bgp->srx_val_local_pref[VAL_LOCPRF_NOTFOUND].value);
+    switch (bgp->srx_val_local_pref[VAL_LOCPRF_NOTFOUND].relative)
+    {
+      case -1 : vty_out (vty, " SUBTRACT%s", VTY_NEWLINE); break;
+      case  1 : vty_out (vty, " ADD%s", VTY_NEWLINE); break;
+      default: vty_out (vty, "%s", VTY_NEWLINE);
+    }
+    doPolicy = 1;
+  }
+  if (bgp->srx_val_local_pref[VAL_LOCPRF_INVALID].is_set)
+  {
+    vty_out (vty, "%slocal-preference invalid %d", (doPolicy ? _BLANKS : ""),
+                  bgp->srx_val_local_pref[VAL_LOCPRF_INVALID].value);
+    switch (bgp->srx_val_local_pref[VAL_LOCPRF_INVALID].relative)
+    {
+      case -1 : vty_out (vty, " SUBTRACT%s", VTY_NEWLINE); break;
+      case  1 : vty_out (vty, " ADD%s", VTY_NEWLINE); break;
+      default: vty_out (vty, "%s", VTY_NEWLINE);
+    }
+    doPolicy = 1;
+  }
+  if (bgp->srx_val_policy & SRX_VAL_POLICY_PREFER_VALID)
+  {
+    vty_out (vty, "%sprefer-valid%s", (doPolicy ? _BLANKS : ""), VTY_NEWLINE);
+    doPolicy = 1;
+  }
+  if (doPolicy == 0)
+  {
+    vty_out (vty, "%s", VTY_NEWLINE);
+  }
+
+  if (CHECK_FLAG(bgp->srx_ecommunity_flags,SRX_BGP_FLAG_ECOMMUNITY))
+  {
+    vty_out (vty, "  ext community..: %d%s", bgp->srx_ecommunity_subcode,
+                                             VTY_NEWLINE);
+    vty_out (vty, "  incl-eBGP......: %s%s",
+             (CHECK_FLAG(bgp->srx_ecommunity_flags,SRX_BGP_FLAG_ECOMMUNITY_EBGP)
+             ? "true" : "false"), VTY_NEWLINE);
+  }
+  else
+  {
+    vty_out (vty, "  ext community..: off%s", VTY_NEWLINE);
+  }
+
+  return CMD_SUCCESS;
+}
+
+DEFUN (srx_set_server,
+       srx_set_server_cmd,
+       SRX_VTY_CMD_SET_SERVER,
+       SRX_VTY_HLP_SET_SERVER)
+{
+  struct bgp *bgp;
+  int port;
+
+  bgp = vty->index;
+
+  if (argc != 2)
+  {
+    return CMD_ERR_INCOMPLETE;
+  }
+
+  /* Host name */
+  if (strlen(argv[SRX_VTY_PARAM_CONNECT_SRV]) == 0)
+  {
+    vty_out (vty, "%% Empty SRx host name%s", VTY_NEWLINE);
+    return CMD_WARNING;
+  }
+
+  /* Port number */
+  VTY_GET_INTEGER_RANGE ("Port", port, argv[SRX_VTY_PARAM_CONNECT_PORT],
+                         1, 65535);
+
+  /* Set configuration */
+  return bgp_srx_set (bgp, vty, argv[SRX_VTY_PARAM_CONNECT_SRV], port, false);
+}
+
+DEFUN (srx_connect_short,
+       srx_connect_short_cmd,
+       SRX_VTY_CMD_CONNECT_SHORT,
+       SRX_VTY_HLP_CONNECT_SHORT)
+{
+  struct bgp *bgp;
+  bgp = vty->index;
+
+  /* Host name */
+  if (bgp->srx_host == NULL)
+  {
+    vty_out (vty, "%% SRx host name not defined, use \"%s\" or pass server and "
+                  "port with this command%s",
+                  SRX_VTY_CMD_SET_SERVER_SHORT, VTY_NEWLINE);
+    return CMD_WARNING;
+  }
+
+  if (strlen(bgp->srx_host) == 0)
+  {
+    vty_out (vty, "Empty SRx host name%s", VTY_NEWLINE);
+    return CMD_WARNING;
+  }
+
+  /* Port number */
+  if (bgp->srx_port == 0)
+  {
+    vty_out (vty, "%% SRx port not specified!%s", VTY_NEWLINE);
+    return CMD_WARNING;
+  }
+
+  /* Set configuration */
+  return bgp_srx_set (bgp, vty, bgp->srx_host, bgp->srx_port, true);
+}
+
+/**
+ * This function sets the key for the given ski.
+ *
+ * @param vty The vty
+ * @param skiNum The ski that is being used - 0 or 1
+ * @param algoID The algorithm ID of the used key.
+ *
+ * @return CMD_SUCCESS, CMD_WARNING, or CMD_ERR_INCOMPLETE
+ */
+int srx_set_ski(struct vty* vty, u_int8_t skiNum, char* skiStr, u_int8_t algoID)
+{
+  int retVal = CMD_SUCCESS;
+  struct bgp* bgp = vty->index;
+
+  if (strlen(skiStr) != SKI_HEX_LENGTH)
+  {
+    vty_out (vty, "SKI must be exact 20 bytes ASCII %s", VTY_NEWLINE);
+    return CMD_ERR_INCOMPLETE;
+  }
+  if (skiNum >= SRX_MAX_PRIVKEYS)
+  {
+    vty_out (vty, "Select an ski between 0..%u, The selected ski %u is outside of there boundaries",
+             SRX_MAX_PRIVKEYS-1, skiNum, VTY_NEWLINE);
+    return CMD_ERR_INCOMPLETE;
+  }
+
+  // The array index starts by zero "0" but the key numbering by one "1"
+  BGPSecKey* key = &bgp->srx_bgpsec_key[skiNum];
+  if (key->keyLength > 0)
+  {
+    // A previous key was loaded, remove it and load the new one.
+    if (bgp->srxCAPI != NULL)
+    {
+      sca_status_t keyStatus = API_STATUS_OK;
+      if (bgp->srxCAPI->unregisterPrivateKey(key, &keyStatus) == API_FAILURE)
+      {
+        vty_out (vty, "Removal of previous router key '%s' failed (status:0x%X)!%s",
+                 skiStr, keyStatus, VTY_NEWLINE);
+      }
+      else
+      {
+        vty_out (vty, "Old router key '%s' successfully removed!%s",
+                 skiStr, VTY_NEWLINE);
+      }
+    }
+
+    // Free previously set values.
+    free(key->keyData);
+    key->keyData   = NULL;
+    key->keyLength = 0;
+  }
+
+  // @TODO: This value should va
+  key->algoID = algoID;
+  key->asn    = htonl(bgp->as);
+  memset(key->ski, 0, SKI_LENGTH);
+
+  // Now set the key ski values
+  int max = strlen(skiStr) < SKI_LENGTH ? strlen(skiStr) : SKI_LENGTH;
+  int idx = 0;
+  char* ch = skiStr;
+  for (; idx < max; idx++)
+  {
+    key->ski[idx] = hex2bin_byte(ch);
+    ch += 2;
+  }
+
+
+  // First try to load the key, if this fails we cannot register.
+  sca_status_t keyStatus = API_STATUS_OK;
+  if (sca_loadKey(key, true, &keyStatus) == API_SUCCESS)
+  {
+    // Now register the private key
+    if (bgp->srxCAPI != NULL)
+    {
+      if (bgp->srxCAPI->registerPrivateKey(key, &keyStatus) == API_FAILURE)
+      {
+        zlog_err ("Installation of router key: #%u, algorithm-id: %u, ski: '%s' failed (status:0x%X)!\n",
+                   skiNum, algoID, skiStr, keyStatus);
+        vty_out (vty, "Installation of router key: #%u, algorithm-id: %u, ski: '%s' failed (status:0x%X)!%s",
+                 skiNum, algoID, skiStr, keyStatus, VTY_NEWLINE);
+        retVal = CMD_WARNING;
+      }
+      else
+      {
+        zlog_info ("Router key: #%u, algorithm-id: %u, ski: '%s' successfully installed!\n",
+                   skiNum, algoID, skiStr);
+        vty_out (vty, "Router key: #%u, algorithm-id: %u, ski: '%s' successfully installed!%s",
+                 skiNum, algoID, skiStr, VTY_NEWLINE);
+      }
+    }
+    else
+    {
+      zlog_warn ("Cannot install router key '%s', crypto api not available!",
+                 skiStr);
+      vty_out (vty, "Cannot install router key '%s', crypto api not available!%s",
+               skiStr, VTY_NEWLINE);
+
+      retVal = CMD_WARNING;
+    }
+  }
+  else
+  {
+    zlog_warn ("Router key %u '%s' not found in key_volt - Check configuration of SRxCryptoAPI!",
+             skiNum, skiStr);
+    vty_out (vty, "Router key %u '%s' not found in key_volt - Check configuration of SRxCryptoAPI!%s",
+             skiNum, skiStr, VTY_NEWLINE);
+    retVal = CMD_WARNING;
+  }
+
+  return retVal;
+}
+
+/**
+ * This function is deprecated and just kept for compatibility
+ * I did not ALIAS it to allow printing out a deprecation message.
+ */
+DEFUN (bgpsec_ski,
+       bgpsec_ski_cmd,
+       SRX_VTY_CMD_BGPSEC_DEP_SKI,
+       SRX_VTY_HLP_BGPSEC_DEP_SKI)
+{
+  struct bgp *bgp;
+  bgp = vty->index;
+
+  if (argc != 1)
+  {
+    return CMD_ERR_INCOMPLETE;
+  }
+
+  vty_out(vty, "WARNING: The configuration command '%s' is deprecated! Use '%s %s' instead %s",
+          SRX_VTY_CMD_BGPSEC_DEP_SKI_PRNT, SRX_VTY_CMD_BGPSEC_SKI_PRNT, argv[0],
+          VTY_NEWLINE);
+  zlog_warn("The configuration command '%s' is deprecated! Use '%s %s' instead %s",
+          SRX_VTY_CMD_BGPSEC_DEP_SKI_PRNT, SRX_VTY_CMD_BGPSEC_SKI_PRNT, argv[0],
+          VTY_NEWLINE);
+
+  // in this old setting mode, we store it as the first key only.
+  bgp->srx_bgpsec_active_key = 0;
+  return srx_set_ski(vty, bgp->srx_bgpsec_active_key, (char*)argv[0],
+                     SCA_ECDSA_ALGORITHM);
+}
+
+// THIS COMMMAND IS NOT IN USE ANYMORE
+DEFUN (bgpsec_sign,
+       bgpsec_sign_cmd,
+       SRX_VTY_CMD_BGPSEC_DEP_SIGN,
+       SRX_VTY_HLP_BGPSEC_DEP_SIGN)
+{
+  vty_out(vty, "This command does not have any affect anymore - remove it.%s",
+          VTY_NEWLINE);
+
+  return CMD_WARNING;
+}
+
+DEFUN (srx_bgpsec_ski,
+       srx_bgpsec_ski_cmd,
+       SRX_VTY_CMD_BGPSEC_SKI,
+       SRX_VTY_HLP_BGPSEC_SKI)
+{
+  struct bgp *bgp;
+  bgp = vty->index;
+
+  if (argc != 3)
+  {
+    return CMD_ERR_INCOMPLETE;
+  }
+
+  // in this old setting mode, we store it as the first key only.
+  uint32_t skiNum = (uint32_t)atoi(argv[0]);
+  int      algoID = atoi(argv[1]);
+  char*    skiStr = (char*)argv[2];
+  int retVal = CMD_ERR_INCOMPLETE;
+  if (skiNum >= SRX_MAX_PRIVKEYS)
+  {
+    zlog_err("This provided ski number is outside of the accepted boundaries%s",
+            VTY_NEWLINE);
+    vty_out(vty, "This provided ski number is outside of the accepted boundaries%s",
+            VTY_NEWLINE);
+  }
+  else
+  {
+    if (   (algoID < SRX_VTY_PARAM_BGPSEC_MIN_ALGOID)
+        || (algoID > SRX_VTY_PARAM_BGPSEC_MAX_ALGOID))
+    {
+      zlog_err("This provided algorithm identifier is outside of the accepted boundaries%s",
+              VTY_NEWLINE);
+      vty_out(vty, "This provided algorithm identifier is outside of the accepted boundaries%s",
+              VTY_NEWLINE);
+    }
+    else
+    {
+      retVal = srx_set_ski(vty, skiNum, skiStr, algoID);
+    }
+  }
+
+  return retVal;
+}
+
+DEFUN (srx_bgpsec_active_ski,
+       srx_bgpsec_active_ski_cmd,
+       SRX_VTY_CMD_BGPSEC_ACTIVE_SKI,
+       SRX_VTY_HLP_BGPSEC_ACTIVE_SKI)
+{
+  struct bgp *bgp;
+  bgp = vty->index;
+
+  if (argc != 1)
+  {
+    return CMD_ERR_INCOMPLETE;
+  }
+
+  int retVal = CMD_SUCCESS;
+
+  uint32_t activeNum = (uint32_t)atoi(argv[0]);
+  if (activeNum >= SRX_MAX_PRIVKEYS)
+  {
+    vty_out(vty, "This provided ski number is outside of the accepted boundaries%s",
+            VTY_NEWLINE);
+    retVal = CMD_ERR_INCOMPLETE;
+  }
+  else
+  {
+    bgp->srx_bgpsec_active_key = activeNum;
+  }
+
+  return retVal;
+}
+
+DEFUN (srx_bgpsec_register_pkeys,
+       srx_bgpsec_register_pkeys_cmd,
+       SRX_VTY_CMD_BGPSEC_REGISTER_P_KEYS,
+       SRX_VTY_HLP_BGPSEC_REGISTER_P_KEYS)
+{
+  struct bgp *bgp;
+  bgp = vty->index;
+
+  if (argc != 1)
+  {
+    return CMD_ERR_INCOMPLETE;
+  }
+
+  int retVal = CMD_SUCCESS;
+
+  // Check if the keys are available in DER format and if not use the srx-crytpao-api
+  // to load them.
+  int kIdx = 0;
+  for (; kIdx < SRX_MAX_PRIVKEYS; kIdx++)
+  {
+    if (bgp->srx_bgpsec_key[kIdx].keyLength = 0)
+    {
+      sca_status_t myStatus = API_STATUS_OK;
+      if (sca_loadKey(&bgp->srx_bgpsec_key[kIdx], true, &myStatus) == API_FAILURE)
+      {
+        zlog_warn ("Router key %u not found in key_volt (status: 0x%X) - Check configuration of SRxCryptoAPI!",
+                   kIdx, myStatus);
+        vty_out (vty, "Router key %u not found in key_volt (status: 0x%X) - Check configuration of SRxCryptoAPI!%s",
+                 kIdx, myStatus, VTY_NEWLINE);
+        retVal = CMD_WARNING;
+      }
+    }
+  }
+
+  // Now register the keys (again)
+  if (bgp->srxCAPI != NULL)
+  {
+    for (kIdx = 0; kIdx < SRX_MAX_PRIVKEYS; kIdx++)
+    {
+      sca_status_t keyStatus = API_STATUS_OK;
+      if (bgp->srxCAPI->registerPrivateKey(&bgp->srx_bgpsec_key[kIdx], &keyStatus) == API_FAILURE)
+      {
+        zlog_err ("Installation of router key %u failed (status:0x%X)!",
+                   kIdx, keyStatus);
+        vty_out (vty, "Installation of router key %u failed (status:0x%X)!%s",
+                 kIdx, keyStatus, VTY_NEWLINE);
+      }
+    }
+  }
+  else
+  {
+    {
+      zlog_warn ("Cannot install router keys, crypto api not available!");
+      vty_out (vty, "Cannot install router keys, crypto api not available!%s",
+               VTY_NEWLINE);
+
+      retVal = CMD_WARNING;
+    }
+  }
+  return retVal;
+}
+
+DEFUN (srx_connect,
+       srx_connect_cmd,
+       SRX_VTY_CMD_CONNECT,
+       SRX_VTY_HLP_CONNECT)
+{
+  struct bgp *bgp;
+  int port;
+
+  bgp = vty->index;
+
+  /* Make sure both parameters are given, not only the host */
+  if (argc != 2)
+  {
+    return CMD_ERR_INCOMPLETE;
+  }
+
+  /* Host name */
+  if (strlen(argv[SRX_VTY_PARAM_CONNECT_SRV]) == 0)
+  {
+    vty_out (vty, "%% Empty SRx host name%s", VTY_NEWLINE);
+    return CMD_ERR_INCOMPLETE;
+  }
+
+  /* Port number */
+  VTY_GET_INTEGER_RANGE ("Port", port, argv[SRX_VTY_PARAM_CONNECT_PORT],
+                         1, 65535);
+
+  /* Set configuration */
+  return bgp_srx_set (bgp, vty, argv[SRX_VTY_PARAM_CONNECT_SRV], port, true);
+}
+
+DEFUN (srx_disconnect,
+       srx_disconnect_cmd,
+       SRX_VTY_CMD_DISCONNECT,
+       SRX_VTY_HLP_DISCONNECT)
+{
+  struct bgp *bgp;
+
+  bgp = vty->index;
+  bgp_srx_unset (bgp);
+  return CMD_SUCCESS;
+}
+
+DEFUN (srx_evaluation,
+       srx_evaluation_cmd,
+       SRX_VTY_CMD_EVALUATE,
+       SRX_VTY_HLP_EVALUATE)
+{
+  struct bgp* bgp;
+  int mode;
+
+  bgp = vty->index;
+  mode = SRX_CONFIG_EVAL_ORIGIN;
+  if (strncmp(argv[0], SRX_VTY_EVAL_BGPSEC, 1) == 0)
+  {
+    mode |= SRX_CONFIG_EVAL_PATH;
+  }
+
+  bgp_srx_evaluation(bgp, mode);
+  return CMD_SUCCESS;
+}
+
+// Enable srx evaluation using srx-server instead of local
+DEFUN (srx_evaluation_bgpsec_distribute,
+       srx_evaluation_bgpsec_distribute_cmd,
+       SRX_VTY_CMD_EVAL_WITHSRX,
+       SRX_VTY_HLP_EVAL_WITHSRX)
+{
+  struct bgp* bgp;
+  bgp = vty->index;
+  bgp_srx_evaluation(bgp, SRX_CONFIG_EVAL_DISTR);
+}
+
+// Configuration of default validation results
+DEFUN (srx_conf_default_roa_result_valid,
+       srx_conf_default_roa_result_valid_cmd,
+       SRX_VTY_CMD_CONF_DEF_ROA_RES_VALID,
+       SRX_VTY_HLP_CONF_DEF_ROA_RES_VALID)
+{
+  struct bgp* bgp;
+  bgp = vty->index;
+  bgp_srx_conf_default_result (bgp, SRX_VTY_PARAM_ORIGIN_VALUE,
+                               SRx_RESULT_VALID);
+  return CMD_SUCCESS;
+}
+
+DEFUN (srx_conf_default_roa_result_unknown,
+       srx_conf_default_roa_result_unknown_cmd,
+       SRX_VTY_CMD_CONF_DEF_ROA_RES_NOTFOUND,
+       SRX_VTY_HLP_CONF_DEF_ROA_RES_NOTFOUND)
+{
+  struct bgp* bgp;
+  bgp = vty->index;
+  bgp_srx_conf_default_result (bgp, SRX_VTY_PARAM_ORIGIN_VALUE,
+                               SRx_RESULT_NOTFOUND);
+  return CMD_SUCCESS;
+}
+
+DEFUN (srx_conf_default_roa_result_invalid,
+       srx_conf_default_roa_result_invalid_cmd,
+       SRX_VTY_CMD_CONF_DEF_ROA_RES_INVALID,
+       SRX_VTY_HLP_CONF_DEF_ROA_RES_INVALID)
+{
+  struct bgp* bgp;
+  bgp = vty->index;
+  bgp_srx_conf_default_result (bgp, SRX_VTY_PARAM_ORIGIN_VALUE,
+                               SRx_RESULT_INVALID);
+  return CMD_SUCCESS;
+}
+
+DEFUN (srx_conf_default_roa_result_undefined,
+       srx_conf_default_roa_result_undefined_cmd,
+       SRX_VTY_CMD_CONF_DEF_ROA_RES_UNDEFINED,
+       SRX_VTY_HLP_CONF_DEF_ROA_RES_UNDEFINED)
+{
+  struct bgp* bgp;
+  bgp = vty->index;
+  bgp_srx_conf_default_result (bgp, SRX_VTY_PARAM_ORIGIN_VALUE,
+                               SRx_RESULT_UNDEFINED);
+  return CMD_SUCCESS;
+}
+
+DEFUN (srx_conf_default_path_result_valid,
+       srx_conf_default_path_result_valid_cmd,
+       SRX_VTY_CMD_CONF_DEF_PATH_RES_VALID,
+       SRX_VTY_HLP_CONF_DEF_PATH_RES_VALID)
+{
+  struct bgp* bgp;
+  bgp = vty->index;
+  bgp_srx_conf_default_result (bgp, SRX_VTY_PARAM_PATH_VALUE,
+                               SRx_RESULT_VALID);
+  return CMD_SUCCESS;
+}
+
+DEFUN (srx_conf_default_path_result_invalid,
+       srx_conf_default_path_result_invalid_cmd,
+       SRX_VTY_CMD_CONF_DEF_PATH_RES_INVALID,
+       SRX_VTY_HLP_CONF_DEF_PATH_RES_INVALID)
+{
+  struct bgp* bgp;
+  bgp = vty->index;
+  bgp_srx_conf_default_result (bgp, SRX_VTY_PARAM_PATH_VALUE,
+                               SRx_RESULT_INVALID);
+  return CMD_SUCCESS;
+}
+
+DEFUN (srx_conf_default_path_result_undefined,
+       srx_conf_default_path_result_undefined_cmd,
+       SRX_VTY_CMD_CONF_DEF_PATH_RES_UNDEFINED,
+       SRX_VTY_HLP_CONF_DEF_PATH_RES_UNDEFINED)
+{
+  struct bgp* bgp;
+  bgp = vty->index;
+  bgp_srx_conf_default_result (bgp, SRX_VTY_PARAM_PATH_VALUE,
+                               SRx_RESULT_UNDEFINED);
+  return CMD_SUCCESS;
+}
+
+// Configuration of evaluation algorithm
+DEFUN (no_srx_evaluation,
+       no_srx_evaluation_cmd,
+       SRX_VTY_CMD_NO_EVALUATE,
+       SRX_VTY_HLP_NO_EVALUATE)
+{
+  struct bgp *bgp;
+
+  bgp = vty->index;
+  bgp_srx_evaluation (bgp, 0);
+  return CMD_SUCCESS;
+}
+
+// This command is disabled
+DEFUN (srx_apply_policy,
+       srx_apply_policy_cmd,
+       SRX_VTY_CMD_APPLY_POLICY,
+       SRX_VTY_HLP_APPLY_POLICY)
+{
+  struct bgp *bgp;
+
+  bgp = vty->index;
+  zlog_debug("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX");
+  srx_bgp_requeue_all(bgp);
+  return CMD_SUCCESS;
+}
+
+// Disabled for this prototype. srx_display_cmd is not installed.
+//
+DEFUN (srx_display,
+       srx_display_cmd,
+       SRX_VTY_CMD_DISPLAY,
+       SRX_VTY_HLP_DISPLAY)
+{
+  struct bgp *bgp;
+
+  bgp = vty->index;
+  bgp_srx_display (bgp, 1);
+  return CMD_SUCCESS;
+}
+
+DEFUN (no_srx_display,
+       no_srx_display_cmd,
+       "no " SRX_VTY_CMD_DISPLAY,
+       NO_STR
+       SRX_VTY_HLP_DISPLAY_NO)
+{
+  struct bgp *bgp;
+
+  bgp = vty->index;
+  bgp_srx_display (bgp, 0);
+  return CMD_SUCCESS;
+}
+
+DEFUN (srx_keepwindow,
+       srx_keepwindow_cmd,
+       SRX_VTY_CMD_KEEPWINDOW,
+       SRX_VTY_HLP_KEEPWINDOW)
+{
+  struct bgp *bgp;
+
+
+  bgp = vty->index;
+  bgp->srx_keepWindow = strtoul (argv[0], NULL, 10);
+
+  return CMD_SUCCESS;
+}
+
+DEFUN (srx_proxyid,
+       srx_proxyid_cmd,
+       SRX_VTY_CMD_PROXYID,
+       SRX_VTY_HLP_PROXYID)
+{
+  struct bgp *bgp = vty->index;
+  struct in_addr address;
+  uint32_t hAddress = 0;
+
+  if (inet_aton(argv[0], &address) != 0)
+  {
+    hAddress = address.s_addr;
+  }
+  else
+  {
+	  vty_out (vty, "%% Malformed proxy id (%s). Use A.B.C.D format%s",
+                  argv[0], VTY_NEWLINE);
+    return CMD_WARNING;
+  }
+
+  int retVal = srx_set_proxyID(bgp, ntohl(hAddress));
+  // Now check if setting the proxy id succeeded or not
+  if (retVal != CMD_SUCCESS)
+  {
+    hAddress = htonl(bgp->srxProxy->proxyID);
+	  vty_out (vty, "%% Proxy is already connected to SRx server using proxy id "
+                  "%u.%u.%u.%u (%u). Can not change proxy-id as long as proxy "
+                  "is connected!%s", (hAddress >> 24) & 0xFF,
+                  (hAddress >> 16) & 0xFF, (hAddress >> 8) & 0xFF,
+                  hAddress & 0xFF, hAddress, VTY_NEWLINE);
+  }
+
+  return retVal;
+}
+
+/**
+ *  Scan for the validation result "v" for valid, "u" for unknown, otherwise
+ * invalid.
+ *
+ * @param str The local pref validation string (valid, unknown, or invalid)
+ *
+ * @return the index type VAL_LOCPRF_VALID,VAL_LOCPRF_NOTFOUND, or
+ *         VAL_LOCPRF_INVALID
+ */
+static int parse_local_pref_index (const char *str)
+{
+  if (strncmp (str, "v", 1) == 0)
+  {
+    return VAL_LOCPRF_VALID;
+  }
+  return (strncmp (str, "n", 1) == 0) ? VAL_LOCPRF_NOTFOUND
+                                      : VAL_LOCPRF_INVALID;
+}
+
+/**
+ * Set the local pref policy
+ *
+ * @param argc the number of arguments passed
+ * @param type the argument array
+ * @param bgp the bgp struct
+ * @param set 1 == set the value, otherwise unset
+ * @return if the command could be executed successfully
+ */
+static int validation_local_preference(int argc, const char** argv,
+                                       struct bgp* bgp, int set)
+{
+  int index, relative;
+  uint32_t lp_val;
+
+  index  = parse_local_pref_index (argv[0]);
+
+  if (set == 1)
+  {
+    lp_val = strtoul (argv[1], NULL, 10);
+
+    if (argc == 2)
+      relative = 0;
+    else
+      relative = (strncmp (argv[2], "a", 1) == 0) ? 1 : -1;
+
+    srx_val_local_preference_set (bgp, index, relative, lp_val);
+  }
+  else
+  {
+    srx_val_local_preference_unset (bgp, index);
+  }
+  return CMD_SUCCESS;
+}
+
+DEFUN (srx_policy_local_preference_var,
+       srx_policy_local_preference_var_cmd,
+       SRX_VTY_CMD_POL_LOCP_VAR,
+       SRX_VTY_HLP_POL_LOCP_VAR
+       )
+{
+  return validation_local_preference(argc, argv, vty->index, 1);
+}
+
+DEFUN (srx_policy_local_preference_fix,
+       srx_policy_local_preference_fix_cmd,
+       SRX_VTY_CMD_POL_LOCP_FIX,
+       SRX_VTY_HLP_POL_LOCP_FIX
+       )
+{
+  return validation_local_preference(argc, argv, vty->index, 1);
+}
+
+DEFUN (no_srx_policy_local_preference,
+       no_srx_policy_local_preference_cmd,
+       SRX_VTY_CMD_NO_POL_LOCP,
+       SRX_VTY_HLP_NO_POL_LOCP
+       )
+{
+  return validation_local_preference(argc, argv, vty->index, 0);
+}
+
+DEFUN (srx_policy_ignore_notfound,
+       srx_policy_ignore_notfound_cmd,
+       SRX_VTY_CMD_POL_IGNORE_NOTFOUND,
+       SRX_VTY_HLP_POL_IGNORE_NOTFOUND)
+{
+  srx_val_policy_set (vty->index, SRX_VAL_POLICY_IGNORE_NOTFOUND);
+  return  CMD_SUCCESS;
+}
+
+DEFUN (no_srx_policy_ignore_notfound,
+       no_srx_policy_ignore_notfound_cmd,
+       "no " SRX_VTY_CMD_POL_IGNORE_NOTFOUND,
+       NO_STR
+       SRX_VTY_HLP_POL_IGNORE_NOTFOUND)
+{
+  srx_val_policy_unset (vty->index, SRX_VAL_POLICY_IGNORE_NOTFOUND);
+  return  CMD_SUCCESS;
+}
+
+DEFUN (srx_policy_ignore_invalid,
+       srx_policy_ignore_invalid_cmd,
+       SRX_VTY_CMD_POL_IGNORE_INVALID,
+       SRX_VTY_HLP_POL_IGNORE_INVALID)
+{
+  srx_val_policy_set (vty->index, SRX_VAL_POLICY_IGNORE_INVALID);
+  return  CMD_SUCCESS;
+}
+
+DEFUN (no_srx_policy_ignore_invalid,
+       no_srx_policy_ignore_invalid_cmd,
+       "no " SRX_VTY_CMD_POL_IGNORE_INVALID,
+       NO_STR
+       SRX_VTY_HLP_POL_IGNORE_INVALID)
+{
+  srx_val_policy_unset (vty->index, SRX_VAL_POLICY_IGNORE_INVALID);
+  return  CMD_SUCCESS;
+}
+
+DEFUN (srx_policy_ignore_undefined,
+       srx_policy_ignore_undefined_cmd,
+       SRX_VTY_CMD_POL_IGNORE_UNDEFINED,
+       SRX_VTY_HLP_POL_IGNORE_UNDEFINED)
+{
+  srx_val_policy_set (vty->index, SRX_VAL_POLICY_IGNORE_UNDEFINED);
+  return  CMD_SUCCESS;
+}
+
+DEFUN (no_srx_policy_ignore_undefined,
+       no_srx_policy_ignore_undefined_cmd,
+       "no " SRX_VTY_CMD_POL_IGNORE_UNDEFINED,
+       NO_STR
+       SRX_VTY_HLP_POL_IGNORE_UNDEFINED)
+{
+  srx_val_policy_unset (vty->index, SRX_VAL_POLICY_IGNORE_UNDEFINED);
+  return  CMD_SUCCESS;
+}
+
+DEFUN (srx_policy_prefer_valid,
+       srx_policy_prefer_valid_cmd,
+       SRX_VTY_CMD_POL_PREFV,
+       SRX_VTY_HLP_POL_PREFV)
+{
+  return srx_val_policy_set (vty->index, SRX_VAL_POLICY_PREFER_VALID);
+}
+
+DEFUN (no_srx_policy_prefer_valid,
+       no_srx_policy_prefer_valid_cmd,
+       "no " SRX_VTY_CMD_POL_PREFV,
+       NO_STR
+       SRX_VTY_HLP_POL_PREFV)
+{
+  return srx_val_policy_unset (vty->index, SRX_VAL_POLICY_PREFER_VALID);
+}
+
+DEFUN (srx_send_extcommunity,
+       srx_send_extcommunity_cmd,
+       SRX_VTY_CMD_EXT_CSTR,
+       SRX_VTY_HLP_EXT_CSTR)
+{
+  return srx_extcommunity_set (vty->index, atoi(argv[0]), "");
+}
+
+DEFUN (srx_send_extcommunity_ebgp,
+       srx_send_extcommunity_ebgp_cmd,
+       SRX_VTY_CMD_EXT_CSTR_EBGP,
+       SRX_VTY_HLP_EXT_CSTR_EBGP)
+{
+  return srx_extcommunity_set (vty->index, atoi(argv[0]), argv[1]);
+}
+
+DEFUN (no_srx_send_extcommunity,
+       no_srx_send_extcommunity_cmd,
+       SRX_VTY_CMD_NO_EXT_CSTR,
+       NO_STR
+       SRX_VTY_HLP_NO_EXT_CSTR)
+{
+  return srx_extcommunity_unset(vty->index);
+}
+#endif /* USE_SRX */
+
 static int
 peer_remote_as_vty (struct vty *vty, const char *peer_str, 
                     const char *as_str, afi_t afi, safi_t safi)
@@ -1969,6 +2954,291 @@ DEFUN (no_neighbor_dont_capability_negot
   return peer_flag_unset_vty (vty, argv[0], PEER_FLAG_DONT_CAPABILITY);
 }
 
+#ifdef USE_SRX
+// @TODO: Create defines for that and add them to the other ones.
+/* bgpsec neighbor capability */
+DEFUN (neighbor_capability_bgpsec,
+       neighbor_capability_bgpsec_cmd,
+       SRX_VTY_CMD_NEIGHBOR_BGPSEC_MODE,
+       SRX_VTY_HLP_NEIGHBOR_BGPSEC_MODE)
+{
+  u_int16_t flag = 0;
+
+  if (strncmp (argv[1], "s", 1) == 0)
+  {
+    flag = PEER_FLAG_BGPSEC_CAPABILITY_SEND | PEER_FLAG_BGPSEC_MPE_IPV4;
+  }
+  else if (strncmp (argv[1], "re", 2) == 0)
+  {
+    flag = PEER_FLAG_BGPSEC_CAPABILITY_RECV;
+  }
+  else if (strncmp (argv[1], "b", 1) == 0)
+  {
+    flag = PEER_FLAG_BGPSEC_CAPABILITY_SEND | PEER_FLAG_BGPSEC_CAPABILITY_RECV
+           | PEER_FLAG_BGPSEC_MPE_IPV4;
+  }
+  else if (strncmp (argv[1], "m", 1) == 0)
+  {
+    flag = PEER_FLAG_BGPSEC_MIGRATE;
+  }
+  else if (strncmp (argv[1], "ro", 2) == 0)
+  {
+    flag = PEER_FLAG_BGPSEC_ROUTE_SERVER;
+  }
+  else
+  {
+    return CMD_ERR_INCOMPLETE;
+  }
+
+  return peer_flag_set_vty(vty, argv[0], flag);
+}
+
+// @TODO: Create defines for that and add them to the other ones.
+DEFUN (no_neighbor_capability_bgpsec,
+       no_neighbor_capability_bgpsec_cmd,
+       SRX_VTY_CMD_NO_NEIGHBOR_BGPSEC_MODE,
+       SRX_VTY_HLP_NO_NEIGHBOR_BGPSEC_MODE)
+{
+  u_int16_t flag = 0;
+
+  if (strncmp (argv[1], "s", 1) == 0)
+  {
+    flag = PEER_FLAG_BGPSEC_CAPABILITY_SEND | PEER_FLAG_BGPSEC_MPE_IPV4;
+  }
+  else if (strncmp (argv[1], "re", 2) == 0)
+  {
+    flag = PEER_FLAG_BGPSEC_CAPABILITY_RECV;
+  }
+  else if (strncmp (argv[1], "b", 1) == 0)
+  {
+    flag = PEER_FLAG_BGPSEC_CAPABILITY_SEND | PEER_FLAG_BGPSEC_CAPABILITY_RECV
+           | PEER_FLAG_BGPSEC_MPE_IPV4;
+  }
+  else if (strncmp (argv[1], "m", 1) == 0)
+  {
+    flag = PEER_FLAG_BGPSEC_MIGRATE;
+  }
+  else if (strncmp (argv[1], "ro", 1) == 0)
+  {
+    flag = PEER_FLAG_BGPSEC_ROUTE_SERVER;
+  }
+  else
+  {
+    return CMD_ERR_INCOMPLETE;
+  }
+
+  return peer_flag_unset_vty(vty, argv[0], flag);
+}
+
+/* bgpsec neighbor capability */
+// DO NOT USE THIS ANYMORE
+DEFUN (neighbor_bgpsec_mpnlri_ipv4,
+       neighbor_bgpsec_mpnlri_ipv4_cmd,
+       NEIGHBOR_CMD2 "mpe",
+       NEIGHBOR_STR
+       NEIGHBOR_ADDR_STR2
+       "Deprecated: Encode sending IPv4 as MPNLRI. Covered by bgpsec (both|snd)!\n")
+{
+  u_int16_t flag = 0;
+
+  flag = PEER_FLAG_BGPSEC_MPE_IPV4;
+
+  vty_out (vty, "This command is deprecated and not used anymore. " \
+          "This flag will be set automatically if bgpsec send is enabled for this neighbor%s",
+          VTY_NEWLINE);
+
+//  return peer_flag_set_vty(vty, argv[0], flag);
+  peer_flag_set_vty(vty, argv[0], flag);
+  return CMD_WARNING;
+}
+
+/**
+ * Resize the buffer for this peer according to the current needs
+ *
+ * @param peer The peer structure
+ * @param newsize The new bugffer size.
+ */
+static void __resizeBuffer(struct peer *peer, size_t newsize)
+{
+  size_t oldsize;
+  if(peer->ibuf)
+  {
+    oldsize = stream_get_size (peer->ibuf);
+    if (oldsize != newsize)
+    {
+      newsize = stream_resize (peer->ibuf, newsize);
+    }
+  }
+  if(peer->work)
+  {
+    oldsize = stream_get_size (peer->work);
+    if (oldsize != newsize)
+    {
+      newsize = stream_resize (peer->work, newsize);
+    }
+  }
+}
+
+/**
+ * Set/unset the extended message support flag (Only if not connected!)
+ */
+static int _setExtendedMessageSupport(struct vty *vty, const char* ip, bool enable)
+{
+  struct peer *peer = peer_and_group_lookup_vty (vty, ip);
+  char* msg1 = NULL;
+  int retVal = CMD_WARNING;
+
+  if (peer)
+  {
+    if (!peer->established)
+    {
+      __resizeBuffer(peer, enable ? BGP_MAX_PACKET_SIZE_EXTENDED
+                                    : BGP_MAX_PACKET_SIZE);
+      if (enable)
+      {
+        retVal = peer_flag_set_vty (vty, ip, PEER_FLAG_EXTENDED_MESSAGE_SUPPORT);
+      }
+      else
+      {
+        retVal = peer_flag_unset_vty (vty, ip, PEER_FLAG_EXTENDED_MESSAGE_SUPPORT);
+      }
+      if (retVal == CMD_SUCCESS)
+      {
+        msg1 = enable ? "Enabled extended message capability"
+                      : "Disabled extended message capability";
+      }
+      else
+      {
+        msg1 = "Error modifying extended message capability";
+      }
+    }
+    else
+    {
+      msg1 = "Cannot modify extended message capability while session is established!\0";
+    }
+  }
+
+  if (msg1 != NULL)
+  {
+    //zlog_info ("%s %s", msg1, VTY_NEWLINE);
+    vty_out (vty, "%s %s", msg1, VTY_NEWLINE);
+  }
+
+  return retVal;
+}
+
+/**
+ * Enable or disable the extended message liberal behavior. This can be done
+ * in live operation.
+ */
+static int _setExtendedMessageLiberal(struct vty *vty, const char* ip, bool enable)
+{
+  int retVal = CMD_WARNING;
+  char* msg1 = NULL;
+  char* msg2 = NULL;
+  struct peer *peer = peer_and_group_lookup_vty (vty, ip);
+
+  if (peer)
+  {
+    retVal = peer_flag_set_vty(vty, ip, PEER_FLAG_EXTENDED_MESSAGE_LIBERAL);
+
+    if (retVal == CMD_SUCCESS)
+    {
+      if (!enable)
+      {
+        // Check if the buffer can be resized back again.
+        msg1 = "Disabled extended message liberal policy";
+
+        if (!CHECK_FLAG (peer->flags, PEER_FLAG_EXTENDED_MESSAGE_SUPPORT))
+        {
+          __resizeBuffer(peer, BGP_MAX_PACKET_SIZE);
+        }
+        else
+        {
+          msg2 = "Extended message capability still active";
+        }
+      }
+      else
+      {
+        msg1 = "Enabled extended message liberal policy";
+        __resizeBuffer(peer, BGP_MAX_PACKET_SIZE_EXTENDED);
+      }
+    }
+    else
+    {
+      msg1 = "Error modifying liberal policy flag!";
+    }
+
+  }
+
+  if (msg1 != NULL)
+  {
+    //zlog_info ("%s %s", msg1, VTY_NEWLINE);
+    vty_out (vty, "%s %s", msg1, VTY_NEWLINE);
+  }
+  if (msg2 != NULL)
+  {
+    //zlog_info ("%s %s", msg2, VTY_NEWLINE);
+    vty_out (vty, "%s %s", msg2, VTY_NEWLINE);
+  }
+
+  return retVal;
+}
+
+/* BGP Extended Message Support */
+DEFUN (neighbor_capability_extended_message_support,
+       neighbor_capability_extended_message_support_cmd,
+       NEIGHBOR_CMD2 "capability extended",
+       NEIGHBOR_STR
+       NEIGHBOR_ADDR_STR2
+       "Advertise capability to the peer\n"
+       "Advertise extended message support to the neighbor\n")
+{
+  return _setExtendedMessageSupport(vty, argv[0], true);
+}
+
+DEFUN (no_neighbor_capability_extended_message_support,
+       no_neighbor_capability_extended_message_support_cmd,
+       NO_NEIGHBOR_CMD2 "capability extended",
+       NO_STR
+       NEIGHBOR_STR
+       NEIGHBOR_ADDR_STR2
+       "Do not advertise capability to the peer\n"
+       "Disable extended message support to the neighbor\n")
+{
+  return _setExtendedMessageSupport(vty, argv[0], false);
+}
+
+
+/* extended message support for bgp (optional) */
+DEFUN (neighbor_capability_extended_message_support_liberal,
+       neighbor_capability_extended_message_support_liberal_cmd,
+       NEIGHBOR_CMD2 "capability extended liberal",
+       NEIGHBOR_STR
+       NEIGHBOR_ADDR_STR2
+       "Advertise capability to the peer\n"
+       "Advertise extended message support for bgp to the neighbor\n"
+       "Accept extended message even if not negotiated\n")
+{
+  return _setExtendedMessageLiberal(vty, argv[0], true);
+}
+
+
+DEFUN (no_neighbor_capability_extended_message_support_liberal,
+       no_neighbor_capability_extended_message_support_liberal_cmd,
+       NO_NEIGHBOR_CMD2 "capability extended (liberal)",
+       NO_STR
+       NEIGHBOR_STR
+       NEIGHBOR_ADDR_STR2
+       "Configure capability to the peer\n"
+       "Disable extended message support for bgp to the neighbor\n"
+       "Disable libaral policy only.\n")
+{
+  return _setExtendedMessageLiberal(vty, argv[0], false);
+}
+
+#endif /* USE_SRX */
+
 static int
 peer_af_flag_modify_vty (struct vty *vty, const char *peer_str, afi_t afi,
 			 safi_t safi, u_int32_t flag, int set)
@@ -6922,6 +8192,12 @@ bgp_show_summary (struct vty *vty, struc
                                      ents * sizeof (struct bgp_node)),
                        VTY_NEWLINE);
               
+              #ifdef USE_SRX
+              vty_out (vty,
+                       "SRx host %s, port %d%s",
+                       bgp->srx_host, bgp->srx_port, VTY_NEWLINE);
+              #endif /* USE_SRX */
+
               /* Peer related usage */
               ents = listcount (bgp->peer);
               vty_out (vty, "Peers %ld, using %s of memory%s",
@@ -9197,6 +10473,71 @@ bgp_vty_init (void)
   install_element (BGP_NODE, &no_bgp_default_local_preference_cmd);
   install_element (BGP_NODE, &no_bgp_default_local_preference_val_cmd);
 
+#ifdef USE_SRX
+  /* "srx *" commands. */
+  install_element (BGP_NODE, &srx_show_config_cmd);
+
+  install_element (BGP_NODE, &srx_connect_short_cmd);
+  install_element (BGP_NODE, &srx_connect_cmd);
+  install_element (BGP_NODE, &srx_disconnect_cmd);
+
+  install_element (BGP_NODE, &srx_set_server_cmd);
+
+  install_element (BGP_NODE, &srx_conf_default_roa_result_valid_cmd);
+  install_element (BGP_NODE, &srx_conf_default_roa_result_unknown_cmd);
+  install_element (BGP_NODE, &srx_conf_default_roa_result_invalid_cmd);
+  install_element (BGP_NODE, &srx_conf_default_roa_result_undefined_cmd);
+  install_element (BGP_NODE, &srx_conf_default_path_result_valid_cmd);
+  install_element (BGP_NODE, &srx_conf_default_path_result_invalid_cmd);
+  install_element (BGP_NODE, &srx_conf_default_path_result_undefined_cmd);
+
+  install_element (BGP_NODE, &srx_evaluation_cmd);
+  install_element (BGP_NODE, &no_srx_evaluation_cmd);
+  install_element (BGP_NODE, &srx_evaluation_bgpsec_distribute_cmd);
+  //install_element (BGP_NODE, &no_srx_evaluation_bgpsec_distribute_cmd);
+
+
+// NOT IN THIS VERSION
+//  install_element (BGP_NODE, &srx_apply_policy_cmd);
+
+  install_element (BGP_NODE, &srx_display_cmd);
+  install_element (BGP_NODE, &no_srx_display_cmd);
+
+  install_element (BGP_NODE, &srx_keepwindow_cmd);
+  install_element (BGP_NODE, &srx_proxyid_cmd);
+
+  install_element (BGP_NODE, &srx_policy_local_preference_var_cmd);
+  install_element (BGP_NODE, &srx_policy_local_preference_fix_cmd);
+  install_element (BGP_NODE, &no_srx_policy_local_preference_cmd);
+
+  install_element (BGP_NODE, &srx_policy_ignore_notfound_cmd);
+  install_element (BGP_NODE, &no_srx_policy_ignore_notfound_cmd);
+
+  install_element (BGP_NODE, &srx_policy_ignore_invalid_cmd);
+  install_element (BGP_NODE, &no_srx_policy_ignore_invalid_cmd);
+
+  install_element (BGP_NODE, &srx_policy_ignore_undefined_cmd);
+  install_element (BGP_NODE, &no_srx_policy_ignore_undefined_cmd);
+
+  install_element (BGP_NODE, &srx_policy_prefer_valid_cmd);
+  install_element (BGP_NODE, &no_srx_policy_prefer_valid_cmd);
+  // The following two entries are deprecated but kept in place to not break
+  // all previous configurations. It will be mapped into install ski 1 and also
+  // selects this ski. Also a warning will be printed.
+  install_element (BGP_NODE, &bgpsec_ski_cmd);
+  // This will only display a NOT USED anymore warning. Printout for running
+  // config and all other functional code will be removed.
+  install_element (BGP_NODE, &bgpsec_sign_cmd);
+  // New key management
+  install_element (BGP_NODE, &srx_bgpsec_ski_cmd);
+  install_element (BGP_NODE, &srx_bgpsec_active_ski_cmd);
+  install_element (BGP_NODE, &srx_bgpsec_register_pkeys_cmd);
+
+  install_element (BGP_NODE, &srx_send_extcommunity_cmd);
+  install_element (BGP_NODE, &srx_send_extcommunity_ebgp_cmd);
+  install_element (BGP_NODE, &no_srx_send_extcommunity_cmd);
+#endif /* USE_SRX */
+
   /* "neighbor remote-as" commands. */
   install_element (BGP_NODE, &neighbor_remote_as_cmd);
   install_element (BGP_NODE, &no_neighbor_cmd);
@@ -9514,6 +10855,18 @@ bgp_vty_init (void)
   install_element (BGP_IPV6_NODE, &no_neighbor_capability_orf_prefix_cmd);
   install_element (BGP_IPV6M_NODE, &neighbor_capability_orf_prefix_cmd);
   install_element (BGP_IPV6M_NODE, &no_neighbor_capability_orf_prefix_cmd);
+#ifdef USE_SRX
+  install_element (BGP_NODE, &neighbor_capability_bgpsec_cmd);
+  install_element (BGP_NODE, &no_neighbor_capability_bgpsec_cmd);
+  // this one is deprecated
+  install_element (BGP_NODE, &neighbor_bgpsec_mpnlri_ipv4_cmd);
+
+  /* bgp extended message support */
+  install_element (BGP_NODE, &neighbor_capability_extended_message_support_cmd);
+  install_element (BGP_NODE, &no_neighbor_capability_extended_message_support_cmd);
+  install_element (BGP_NODE, &neighbor_capability_extended_message_support_liberal_cmd);
+  install_element (BGP_NODE, &no_neighbor_capability_extended_message_support_liberal_cmd);
+#endif
 
   /* "neighbor capability dynamic" commands.*/
   install_element (BGP_NODE, &neighbor_capability_dynamic_cmd);
--- ./bgpd/bgp_aspath.h	2013-01-26 21:25:34.000000000 -0500
+++ ./bgpd/bgp_aspath.h	2017-06-26 15:53:49.000000000 -0400
@@ -105,4 +105,8 @@ extern unsigned int aspath_has_as4 (stru
 /* For SNMP BGP4PATHATTRASPATHSEGMENT, might be useful for debug */
 extern u_char *aspath_snmp_pathseg (struct aspath *, size_t *);
 
+#ifdef USE_SRX
+extern as_t aspath_origin_as (struct aspath *);
+#endif /* USE_SRX */
+
 #endif /* _QUAGGA_BGP_ASPATH_H */
--- ./bgpd/bgp_aspath.c	2013-01-26 21:25:34.000000000 -0500
+++ ./bgpd/bgp_aspath.c	2017-06-26 15:53:49.000000000 -0400
@@ -35,6 +35,10 @@ Software Foundation, Inc., 59 Temple Pla
 #include "bgpd/bgp_debug.h"
 #include "bgpd/bgp_attr.h"
 
+#ifdef USE_SRX
+#include "srx/srx_defs.h"
+#endif /* USE_SRX */
+
 /* Attr. Flags and Attr. Type Code. */
 #define AS_HEADER_SIZE        2	 
 
@@ -797,6 +801,24 @@ aspath_parse (struct stream *s, size_t l
    */
   if (length % AS16_VALUE_SIZE )
     return NULL;
+#ifdef USE_SRX
+  if (BGP_DEBUG (as4, AS4_SEGMENT))
+  {
+    size_t i = stream_get_getp (s);
+    zlog_debug ("[AS4SEG] aspath_parse: dump stream length:%d - getp:%d ",\
+               (int)length, stream_getc_from(s, i) );
+    size_t tot = length + i, inc=0;
+    for (i; i < tot; i++)
+    {
+      if (++inc % 16 == 0) 
+      {
+        printf("\n");
+      }
+      printf("%02x ", s->data[i]);
+    }
+    printf(" - from[%s]\n", __FUNCTION__);
+  }
+#endif /* USE_SRX */
 
   memset (&as, 0, sizeof (struct aspath));
   if (assegments_parse (s, length, &as.segments, use32bit) < 0)
@@ -1827,6 +1849,48 @@ aspath_key_make (void *p)
   return key;
 }
 
+#ifdef USE_SRX
+
+/**
+ * Determine the right most as in the path as origin as! In case no ASN can be 
+ * determined according to (RFC 6483) the ASN 65536 which is reserved for 
+ * documentation examples (RFC 5398) is used to prevent any ASN collisions.
+ * 
+ * @param ap The AS path
+ * 
+ * @return the right most AS or 65536 as indicator for unusable ASN. 
+ */
+as_t aspath_origin_as (struct aspath *ap)
+{
+  struct assegment* cseg;
+  as_t oas = 0;
+
+  if (ap == NULL)
+  {
+    return 0;
+  }
+  
+  // take the last element in each segment. At the end the origin is 
+  // written in the oas value.
+  for (cseg = ap->segments; cseg; cseg = cseg->next)
+  {
+    if (cseg->type == AS_SEQUENCE)
+    {
+      oas = cseg->as[cseg->length - 1];
+    }
+    else if (cseg->type == AS_SET)
+    {
+      // AS_SET found, origin cannot be determined (RFC 6483), use an ASN of
+      // rfc 5398 - see srx_defs.h
+      oas = UNKNOWN_ASN;
+      break;
+    }
+  }
+
+  return oas;
+}
+#endif /* USE_SRX */
+
 /* If two aspath have same value then return 1 else return 0 */
 int
 aspath_cmp (const void *arg1, const void *arg2)
--- ./bgpd/bgp_packet.h	2012-11-08 11:41:48.000000000 -0500
+++ ./bgpd/bgp_packet.h	2017-06-26 15:53:49.000000000 -0400
@@ -39,6 +39,11 @@ Software Foundation, Inc., 59 Temple Pla
 
 /* Packet send and receive function prototypes. */
 extern int bgp_read (struct thread *);
+#ifdef USE_SRX
+extern int bgp_read2 (struct thread *);
+struct ecommunity* srxEcommunityChange(struct bgp *, struct attr *, struct bgp_info *);
+int srxEcommunityRestore(struct attr *, struct ecommunity* );
+#endif /* USE_SRX */
 extern int bgp_write (struct thread *);
 
 extern void bgp_keepalive_send (struct peer *);
--- ./bgpd/bgp_info_hash.c	1969-12-31 19:00:00.000000000 -0500
+++ ./bgpd/bgp_info_hash.c	2017-06-26 15:53:49.000000000 -0400
@@ -0,0 +1,304 @@
+/**
+ * This software was developed at the National Institute of Standards and
+ * Technology by employees of the Federal Government in the course of
+ * their official duties. Pursuant to title 17 Section 105 of the United
+ * States Code this software is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * NIST assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the software is used.
+ * 
+ * NIST ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS SOFTWARE.
+ * 
+ * This software might use libraries that are under GNU public license or
+ * other licenses. Please refer to the licenses of all libraries required 
+ * by this software.
+ *
+ * Various function to make debugging easier.
+ *
+ * @version 0.3.1.0
+ *
+ * Changelog:
+ * -----------------------------------------------------------------------------
+ * 0.3.1.0 - 2015/11/26 - oborchert
+ *            * Added Changelog
+ */
+#include <zebra.h>
+
+#ifdef USE_SRX
+
+#include "command.h"
+#include "linklist.h"
+#include "memory.h"
+#include "prefix.h"
+#include "vty.h"
+
+#include "bgpd/bgpd.h"
+#include "bgpd/bgp_aspath.h"
+#include "bgpd/bgp_attr.h"
+#include "bgpd/bgp_info_hash.h"
+#include "bgpd/bgp_route.h"
+#include "bgpd/bgp_table.h"
+
+#define SHOW_SCODE_HEADER "Validation code: v valid, n notfound, i invalid, ? undefined%s%s"
+#define SHOW_HEADER "         Ident          Network       I LocPrf Path%s"
+
+static int show_info_hash (struct vty* vty, struct bgp* bgp, 
+                           struct bgp_info_hash *hash)
+{
+  static const char RES_CODE_CHAR[] = { 'v', 'n', 'i', '?' };
+
+  struct bgp_info_hash_item* curr;
+  char pbuf[INET6_ADDRSTRLEN];
+  struct attr* attr;
+  int valState;
+  
+  if (HASH_COUNT (hash->table) == 0)
+  {
+    vty_out (vty, "   (No entries)%s%s", VTY_NEWLINE, VTY_NEWLINE);
+    return 0;
+  }
+
+  vty_out (vty, SHOW_HEADER, VTY_NEWLINE);
+  for (curr = hash->table; curr != NULL; curr = curr->hh.next)
+  {
+    valState = srx_calc_validation_state(bgp, curr->info);
+    vty_out (vty, "   %c(%c%c) %08X ", 
+        RES_CODE_CHAR[valState],             
+        RES_CODE_CHAR[curr->info->val_res_ROA],
+        RES_CODE_CHAR[curr->info->val_res_BGPSEC],
+        curr->identifier);
+
+    /* Node - identified by its prefix */
+    if (curr->info->node)
+    {
+      vty_out (vty, "%15s/%-2d  ",
+               inet_ntop (curr->info->node->p.family, 
+                          &curr->info->node->p.u.prefix, 
+                          pbuf, INET6_ADDRSTRLEN),
+        curr->info->node->p.prefixlen);
+    }
+    else
+    {
+      vty_out (vty, "(NULL node)         ");
+    }
+
+    /* Ignore flag */
+    if (CHECK_FLAG (curr->info->flags, BGP_INFO_IGNORE))
+    {
+      vty_out (vty, "x ");
+    }
+    else
+    {
+      vty_out (vty, "  ");
+    }
+
+    attr = curr->info->attr;
+
+    /* Local-preference and adjustment */
+    if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF))
+    {
+      vty_out (vty, "%d", attr->local_pref);
+    }
+    else
+    {
+      vty_out (vty, "D:%d", bgp->default_local_pref);
+    }
+
+    switch (valState)
+    {
+      case SRx_RESULT_VALID:
+        valState = VAL_LOCPRF_VALID;
+        break;
+      case SRx_RESULT_NOTFOUND:
+        valState = VAL_LOCPRF_NOTFOUND;
+        break;
+      case SRx_RESULT_INVALID:
+        valState = VAL_LOCPRF_INVALID;
+        break;
+      case SRx_RESULT_UNDEFINED:
+      default:
+        valState = -1;
+    }
+    if (valState != -1)
+    {
+      if (bgp->srx_val_local_pref[valState].is_set)
+      {
+        if (bgp->srx_val_local_pref[valState].relative)
+        {
+          vty_out (vty, "%c%4d", 
+                   (bgp->srx_val_local_pref[valState].relative == 1) ? '+' 
+                                                                     : '-' ,
+                    bgp->srx_val_local_pref[valState].value);
+        }
+        else
+        {
+          vty_out (vty, "->%4d", bgp->srx_val_local_pref[valState].value);
+        }        
+      }
+    }
+    else
+    {
+      vty_out (vty, "      ");
+    }        
+
+    /* AS-Path */
+    if (attr->aspath)
+    {
+      aspath_print_vty (vty, " \"%s\"", attr->aspath, " ");
+    }
+ 
+    vty_out (vty, "%s", VTY_NEWLINE);
+  }
+  vty_out (vty, "%s", VTY_NEWLINE);
+
+  return 1;
+}
+
+/** Is not available in terminal session. */
+DEFUN (show_bgp_info_hashes,
+       show_bgp_info_hashes_cmd,
+       "show bgp info-hashes",
+       SHOW_STR
+       BGP_STR
+       "Display all info hashes\n")
+{
+  struct listnode* curr;
+  struct bgp* bgp;
+
+  vty_out (vty, SHOW_SCODE_HEADER, VTY_NEWLINE, VTY_NEWLINE);
+  for (ALL_LIST_ELEMENTS_RO(bm->bgp, curr, bgp))
+  {
+    vty_out (vty, "BGP info hash UID of AS %d%s", bgp->as, VTY_NEWLINE);
+    show_info_hash(vty, bgp, bgp->info_uid_hash);
+    vty_out (vty, "BGP info hash LID of AS %d%s", bgp->as, VTY_NEWLINE);
+    show_info_hash(vty, bgp, bgp->info_lid_hash);
+  }
+
+  return CMD_SUCCESS;
+}
+
+void bgp_all_info_hashes_init (void)
+{
+// remove this debug command!
+// install_element (VIEW_NODE, &show_bgp_info_hashes_cmd);
+}
+
+struct bgp_info_hash* bgp_info_hash_init (void)
+{
+  struct bgp_info_hash* new;
+  
+  new = XCALLOC(MTYPE_BGP_INFO_HASH, sizeof(struct bgp_info_hash));
+  if (new)
+  {
+    new->table = NULL;
+  }
+  return new;
+}
+
+void bgp_info_hash_finish (struct bgp_info_hash** hash)
+{
+  struct bgp_info_hash_item* curr;
+
+  while ((*hash)->table)
+  {
+    curr = (*hash)->table;
+    HASH_DEL ((*hash)->table, curr);
+    XFREE (MTYPE_BGP_INFO_HASH_ITEM, curr);
+  }
+
+  XFREE (MTYPE_BGP_INFO_HASH, *hash);
+  *hash = NULL;
+}
+
+/**
+ * 
+ * @param hash
+ * @param info
+ * @param identifier
+ * 
+ * @return 1 if the registration was successfull, 0 if the update identifier was
+ *         already known to the system and -1 if an error occured.
+ */
+int bgp_info_register (struct bgp_info_hash* hash, struct bgp_info* info, 
+                       uint32_t identifier)
+{
+  if (identifier == 0)
+  {
+    return 0;
+  }
+  
+  struct bgp_info_hash_item *new;
+  
+  /* Add to the hash */
+  new = XCALLOC (MTYPE_BGP_INFO_HASH_ITEM, sizeof(struct bgp_info_hash_item));
+  if (new == NULL) 
+  {
+    zlog_err("Not enough memory to store update [0x%80X]", identifier);
+    return -1;
+  }
+
+  new->identifier = identifier;
+  new->info       = info;
+
+  HASH_ADD(hh, hash->table, identifier, sizeof(uint32_t), new);
+
+  info->info_hash = hash;
+
+  return 1;
+}
+
+/**
+ * Remove the update id <-> update relation from the hash table.
+ * 
+ * @param hash The hash table
+ * @param identifier the update identifier who has to be removed.
+ */
+void bgp_info_unregister(struct bgp_info_hash* hash, uint32_t identifier)
+{
+  struct bgp_info_hash_item* entry;
+
+  HASH_FIND(hh, hash->table, &identifier, sizeof(uint32_t), entry);
+  if (entry)
+  {
+    HASH_DEL(hash->table, entry);
+    XFREE(MTYPE_BGP_INFO_HASH, entry);
+  }
+}
+
+/**
+ * Retrieve the bgp update associated with the update id or NULL
+ * 
+ * @param hash the info hash table
+ * @param identifier the update identifier
+ * 
+ * @return the bgp update or NULL
+ */
+struct bgp_info* bgp_info_fetch (struct bgp_info_hash* hash, 
+                                 uint32_t identifier)
+{
+  struct bgp_info_hash_item* entry;
+  
+  HASH_FIND (hh, hash->table, &identifier, sizeof(uint32_t), entry);
+
+  if(entry) 
+  {
+    for( entry= hash->table; entry!=NULL; 
+         entry=(struct bgp_info_hash_item*)(entry->hh.next))
+    {
+      if (entry->identifier == identifier)
+      {
+        return entry->info;
+      }
+    }
+  }
+  return NULL;
+}
+
+#endif /* USE_SRX */
+
--- ./bgpd/bgp_open.c	2013-02-01 11:55:04.000000000 -0500
+++ ./bgpd/bgp_open.c	2017-07-11 18:18:36.000000000 -0400
@@ -424,6 +424,9 @@ static const struct message capcode_str[
   { CAPABILITY_CODE_DYNAMIC,		"Dynamic"			},
   { CAPABILITY_CODE_REFRESH_OLD,	"Route Refresh (Old)"		},
   { CAPABILITY_CODE_ORF_OLD,		"ORF (Old)"			},
+#ifdef USE_SRX
+  { CAPABILITY_CODE_EXTENDED,		"Extended Message Support"      },
+#endif
 };
 static const int capcode_str_max = array_size(capcode_str);
 
@@ -438,6 +441,9 @@ static const size_t cap_minsizes[] = 
   [CAPABILITY_CODE_DYNAMIC]	= CAPABILITY_CODE_DYNAMIC_LEN,
   [CAPABILITY_CODE_REFRESH_OLD]	= CAPABILITY_CODE_REFRESH_LEN,
   [CAPABILITY_CODE_ORF_OLD]	= sizeof (struct capability_orf_entry),
+#ifdef USE_SRX
+  [CAPABILITY_CODE_EXTENDED]    = CAPABILITY_CODE_EXTENDED_LEN,
+#endif
 };
 
 /**
@@ -455,6 +461,10 @@ bgp_capability_parse (struct peer *peer,
   struct stream *s = BGP_INPUT (peer);
   size_t end = stream_get_getp (s) + length;
   
+#ifdef USE_SRX
+  struct BgpsecCapVal cv;
+#endif
+
   assert (STREAM_READABLE (s) >= length);
   
   while (stream_get_getp (s) < end)
@@ -500,6 +510,10 @@ bgp_capability_parse (struct peer *peer,
           case CAPABILITY_CODE_RESTART:
           case CAPABILITY_CODE_AS4:
           case CAPABILITY_CODE_DYNAMIC:
+#ifdef USE_SRX
+          case CAPABILITY_CODE_BGPSEC:
+          case CAPABILITY_CODE_EXTENDED:
+#endif
               /* Check length. */
               if (caphdr.length < cap_minsizes[caphdr.code])
                 {
@@ -569,6 +583,54 @@ bgp_capability_parse (struct peer *peer,
               if (!bgp_capability_as4 (peer, &caphdr))
                 return -1;
               break;            
+#ifdef USE_SRX
+          case CAPABILITY_CODE_BGPSEC:
+              memset(&cv, 0xff, sizeof(struct BgpsecCapVal));
+              cv.version_dir = stream_getc(s);
+              cv.afi = stream_getw(s);
+
+              if (BGP_DEBUG (bgpsec, BGPSEC_IN) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
+              {
+                zlog_debug("[BGPSEC] ------- BGPSEC capability parsing -------");
+                zlog_debug("[BGPSEC] %s capability code: %d length:%d version_dir:%02x afi:%02x", \
+                    peer->host, caphdr.code, caphdr.length, cv.version_dir, cv.afi);
+              }
+
+              /* check if the connected peer has the recv-direction capability */
+              if( (cv.version_dir & ~(BGPSEC_CAP_DIR_RECV)) == 0)    // 0x00 : dir bit
+              {
+                SET_FLAG (peer->cap, PEER_CAP_BGPSEC_ADV);
+
+                if (BGP_DEBUG (bgpsec, BGPSEC_IN) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
+                  zlog_debug("[BGPSEC] peer Capability RECV set");
+              }
+
+              /* check if the connected peer has the send-direction capability */
+              //if( (cv.version_dir & 0x08) == 0)    // 0x08 : dir bit
+              if( cv.version_dir & (BGPSEC_CAP_DIR_SEND))    // 0x08 : dir bit
+              {
+                SET_FLAG (peer->cap, PEER_CAP_BGPSEC_ADV_SEND);
+
+                if (BGP_DEBUG (bgpsec, BGPSEC_IN) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
+                  zlog_debug("[BGPSEC] peer Capability SEND set");
+              }
+              break;
+
+          /* Extended Message Support for BGP */
+          case CAPABILITY_CODE_EXTENDED:
+                SET_FLAG (peer->cap, PEER_CAP_EXTENDED_MSG_SUPPORT);
+                if(peer->ibuf)
+                {
+                  if(stream_get_size (peer->ibuf) <= BGP_MAX_PACKET_SIZE)
+                    stream_resize (peer->ibuf, BGP_MAX_PACKET_SIZE_EXTENDED);
+                }
+                if(peer->work)
+                {
+                  if(stream_get_size (peer->work) <= BGP_MAX_PACKET_SIZE)
+                    stream_resize (peer->work, BGP_MAX_PACKET_SIZE_EXTENDED);
+                }
+                break;
+#endif
           default:
             if (caphdr.code > 128)
               {
@@ -763,6 +825,13 @@ bgp_open_option_parse (struct peer *peer
 	  ret = -1;
 	  break;
 	}
+#if 0
+      /* Notification is sending to neighbor : type 2/99 */
+      if(ret < 0 && ret == -2)
+        bgp_notify_send (peer,
+                         BGP_NOTIFY_OPEN_ERR,
+                         BGP_NOTIFY_OPEN_UNSUP_BGPSEC);
+#endif
 
       /* Parse error.  To accumulate all unsupported capability codes,
          bgp_capability_parse does not return -1 when encounter
@@ -950,6 +1019,11 @@ bgp_open_capability (struct stream *s, s
       stream_putc (s, 0);
       stream_putc (s, SAFI_MPLS_LABELED_VPN);
     }
+  
+#ifdef USE_SRX
+  bool mpnlri_v6_announced = false;
+#endif
+  
 #ifdef HAVE_IPV6
   /* IPv6 unicast. */
   if (peer->afc[AFI_IP6][SAFI_UNICAST])
@@ -962,6 +1036,11 @@ bgp_open_capability (struct stream *s, s
       stream_putw (s, AFI_IP6);
       stream_putc (s, 0);
       stream_putc (s, SAFI_UNICAST);
+#endif
+#if defined(USE_SRX) && defined(HAVE_IPV6)
+      mpnlri_v6_announced = true;
+#endif
+#ifdef HAVE_IPV6
     }
   /* IPv6 multicast. */
   if (peer->afc[AFI_IP6][SAFI_MULTICAST])
@@ -974,6 +1053,11 @@ bgp_open_capability (struct stream *s, s
       stream_putw (s, AFI_IP6);
       stream_putc (s, 0);
       stream_putc (s, SAFI_MULTICAST);
+#endif
+#if defined(USE_SRX) && defined(HAVE_IPV6)
+      mpnlri_v6_announced = true;
+#endif
+#ifdef HAVE_IPV6
     }
 #endif /* HAVE_IPV6 */
 
@@ -1030,8 +1114,101 @@ bgp_open_capability (struct stream *s, s
       stream_putc (s, CAPABILITY_CODE_RESTART_LEN);
       stream_putw (s, peer->bgp->restart_time);
      }
+#ifdef USE_SRX
+  /* BGPSEC Capability */
+  if (CHECK_FLAG (peer->flags, PEER_FLAG_BGPSEC_CAPABILITY_SEND))
+  {
+    /* direction - send, IPv4 capability */
+    stream_putc (s, BGP_OPEN_OPT_CAP);
+    stream_putc (s, CAPABILITY_CODE_BGPSEC_LEN + 2);
+    stream_putc (s, CAPABILITY_CODE_BGPSEC);
+    stream_putc (s, CAPABILITY_CODE_BGPSEC_LEN);
+    makeBgpsecCapability(s, BGPSEC_CAP_VERSION, BGPSEC_CAP_DIR_SEND, BGPSEC_CAP_AFI_IPv4);
+
+    if (BGP_DEBUG (bgpsec, BGPSEC_OUT) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
+      zlog_debug("[BGPSEC]  %s: BGPSEC SEND Capability set for IPv4", __FUNCTION__);
+  }
+
+  if(CHECK_FLAG (peer->flags, PEER_FLAG_BGPSEC_CAPABILITY_RECV))
+  {
+    /* direction -  recv, IPv4 capability */
+    stream_putc (s, BGP_OPEN_OPT_CAP);
+    stream_putc (s, CAPABILITY_CODE_BGPSEC_LEN + 2);
+    stream_putc (s, CAPABILITY_CODE_BGPSEC);
+    stream_putc (s, CAPABILITY_CODE_BGPSEC_LEN);
+    makeBgpsecCapability(s, BGPSEC_CAP_VERSION, BGPSEC_CAP_DIR_RECV, BGPSEC_CAP_AFI_IPv4);
+
+    if (BGP_DEBUG (bgpsec, BGPSEC_OUT) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
+      zlog_debug("[BGPSEC]  %s: BGPSEC RECV Capability set for IPv4", __FUNCTION__);
+  }
+  else if(!CHECK_FLAG (peer->flags, PEER_FLAG_BGPSEC_CAPABILITY_SEND))
+  {
+    if (BGP_DEBUG (bgpsec, BGPSEC_OUT) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
+      zlog_debug("[BGPSEC]  %s: BGPSEC Capability NOT set for IPv4", __FUNCTION__);
+  }
+
+  /* BGPSec capability IPv6  */
+  if (mpnlri_v6_announced 
+      && (CHECK_FLAG (peer->flags, PEER_FLAG_BGPSEC_CAPABILITY_SEND)))
+  {
+    /* direction - send, IPv6 capability */
+    stream_putc (s, BGP_OPEN_OPT_CAP);
+    stream_putc (s, CAPABILITY_CODE_BGPSEC_LEN + 2);
+    stream_putc (s, CAPABILITY_CODE_BGPSEC);
+    stream_putc (s, CAPABILITY_CODE_BGPSEC_LEN);
+    makeBgpsecCapability(s, BGPSEC_CAP_VERSION, BGPSEC_CAP_DIR_SEND, BGPSEC_CAP_AFI_IPv6);
+
+    if (BGP_DEBUG (bgpsec, BGPSEC_OUT) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
+      zlog_debug("[BGPSEC]  %s: BGPSEC SEND Capability set for IPv6", __FUNCTION__);
+  }
+
+  if (mpnlri_v6_announced 
+      && (CHECK_FLAG (peer->flags, PEER_FLAG_BGPSEC_CAPABILITY_RECV)))
+  {
+    /* direction -  recv, IPv6 capability */
+    stream_putc (s, BGP_OPEN_OPT_CAP);
+    stream_putc (s, CAPABILITY_CODE_BGPSEC_LEN + 2);
+    stream_putc (s, CAPABILITY_CODE_BGPSEC);
+    stream_putc (s, CAPABILITY_CODE_BGPSEC_LEN);
+    makeBgpsecCapability(s, BGPSEC_CAP_VERSION, BGPSEC_CAP_DIR_RECV, BGPSEC_CAP_AFI_IPv6);
+
+    if (BGP_DEBUG (bgpsec, BGPSEC_OUT) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
+      zlog_debug("[BGPSEC]  %s: BGPSEC RECV Capability set for IPv6", __FUNCTION__);
+  }
+  else if(!CHECK_FLAG (peer->flags, PEER_FLAG_BGPSEC_CAPABILITY_SEND))
+  {
+    if (BGP_DEBUG (bgpsec, BGPSEC_OUT) || BGP_DEBUG(bgpsec, BGPSEC_DETAIL))
+      zlog_debug("[BGPSEC]  %s: BGPSEC Capability NOT set for IPv6", __FUNCTION__);
+  }
+
+  /* Extended Message Support for BGP */
+  if (CHECK_FLAG (peer->flags, PEER_FLAG_EXTENDED_MESSAGE_SUPPORT))
+  {
+    if (BGP_DEBUG (normal, NORMAL))
+      zlog_debug("%s: Extended Message Support Capability Set", __FUNCTION__);
+
+    stream_putc (s, BGP_OPEN_OPT_CAP);
+    stream_putc (s, CAPABILITY_CODE_EXTENDED_LEN+ 2);
+    stream_putc (s, CAPABILITY_CODE_EXTENDED);
+    stream_putc (s, CAPABILITY_CODE_EXTENDED_LEN);
+  }
+#endif
 
   /* Total Opt Parm Len. */
   len = stream_get_endp (s) - cp - 1;
   stream_putc_at (s, cp, len);
 }
+
+#ifdef USE_SRX
+void makeBgpsecCapability(struct stream* s, uint8_t version, uint8_t dir, uint16_t afi)
+{
+  struct BgpsecCapVal cv;
+  memset(&cv, 0x0, sizeof(struct BgpsecCapVal));
+  SET_FLAG(cv.version_dir, version);
+  SET_FLAG(cv.version_dir, dir);
+  cv.afi = afi;
+
+  stream_putc (s, cv.version_dir);
+  stream_putw (s, cv.afi);
+}
+#endif
--- ./bgpd/bgp_ecommunity.c	2013-01-26 21:25:34.000000000 -0500
+++ ./bgpd/bgp_ecommunity.c	2017-06-26 15:53:49.000000000 -0400
@@ -40,6 +40,7 @@ ecommunity_new (void)
 					sizeof (struct ecommunity));
 }
 
+
 /* Allocate ecommunities.  */
 void
 ecommunity_free (struct ecommunity **ecom)
@@ -564,6 +565,37 @@ ecommunity_str2com (const char *str, int
   return ecom;
 }
 
+#ifdef USE_SRX
+/**
+ * @brief bgpsec ecommunity parsing function
+ *
+ * @param type
+ * @param state_value
+ *
+ * @return
+ */
+struct ecommunity *
+ecommunity_bgpsec_str2com(int type, unsigned int state_value)
+{
+  struct ecommunity *ecom = NULL;
+  struct ecommunity_val eval;
+
+  memset(&eval, 0x00, sizeof(struct ecommunity_val));
+  ecom = ecommunity_new ();
+
+  eval.val[0] = ECOMMUNITY_ENCODE_BGPSEC;   /* high order type */
+  //eval.val[0] = ECOMMUNITY_ENCODE_TRANSITIVE_BGPSEC;   /* TEST high order type */
+  //eval.val[1] = ECOMMUNITY_BGPSEC_SUB;      /* low order type */
+  eval.val[1] = type;      /* low order type */
+  eval.val[7] = state_value;
+  //eval.val[7] = 0xAB; // for test
+
+  ecommunity_add_val (ecom, &eval);
+
+  return ecom;
+}
+#endif
+
 /* Convert extended community attribute to string.  
 
    Due to historical reason of industry standard implementation, there
--- ./bgpd/bgp_ecommunity.h	2013-01-26 21:25:34.000000000 -0500
+++ ./bgpd/bgp_ecommunity.h	2017-06-26 15:53:49.000000000 -0400
@@ -25,10 +25,18 @@ Software Foundation, Inc., 59 Temple Pla
 #define ECOMMUNITY_ENCODE_AS                0x00
 #define ECOMMUNITY_ENCODE_IP                0x01
 #define ECOMMUNITY_ENCODE_AS4               0x02
+#ifdef USE_SRX
+#define ECOMMUNITY_ENCODE_BGPSEC            0x43  /* opaque type */
+#define ECOMMUNITY_ENCODE_TRANSITIVE_BGPSEC 0x03  /* opaque type */
+#endif
+
 
 /* Low-order octet of the Extended Communityes type field.  */
 #define ECOMMUNITY_ROUTE_TARGET             0x02
 #define ECOMMUNITY_SITE_ORIGIN              0x03
+#ifdef USE_SRX
+#define ECOMMUNITY_BGPSEC_SUB               0x00  /* TBD */
+#endif
 
 /* Extended communities attribute string format.  */
 #define ECOMMUNITY_FORMAT_ROUTE_MAP            0
@@ -41,6 +49,23 @@ Software Foundation, Inc., 59 Temple Pla
 /* Extended Communities type flag.  */
 #define ECOMMUNITY_FLAG_NON_TRANSITIVE      0x40  
 
+/* Extended Communities BGPSEC validation state values */
+#ifdef USE_SRX
+// INFO: Scripting these values as hex values implies that they might be bit 
+//       encoded which they are definitely NOT. So I changed them into integers.
+//       also UNDEFINED is missing - which is an SRX Origin validation result. 
+//       The name itself should be changed from ECOMMUNITY_BGPSEC_... to 
+//       E_COMMUNITY_SRX... because these values are same for RPKI as well as 
+//       PATH validation.
+//       additional it will make sense to add an SRX_COMMON.h where system wide
+//       variables are defined used in all products throughout the SRx Software
+//       suite. 
+#define ECOMMUNITY_BGPSEC_VALID             0
+#define ECOMMUNITY_BGPSEC_NOT_FOUND         1
+#define ECOMMUNITY_BGPSEC_INVALID           2
+#define ECOMMUNITY_BGPSEC_UNDEFINED         3
+#endif
+
 /* Extended Communities attribute.  */
 struct ecommunity
 {
@@ -77,6 +102,9 @@ extern int ecommunity_cmp (const void *,
 extern void ecommunity_unintern (struct ecommunity **);
 extern unsigned int ecommunity_hash_make (void *);
 extern struct ecommunity *ecommunity_str2com (const char *, int, int);
+#ifdef USE_SRX
+extern struct ecommunity *ecommunity_bgpsec_str2com(int, unsigned int);
+#endif
 extern char *ecommunity_ecom2str (struct ecommunity *, int);
 extern int ecommunity_match (const struct ecommunity *, const struct ecommunity *);
 extern char *ecommunity_str (struct ecommunity *);
--- ./bgpd/bgp_open.h	2012-11-08 11:41:48.000000000 -0500
+++ ./bgpd/bgp_open.h	2017-07-10 11:53:13.000000000 -0400
@@ -53,6 +53,22 @@ struct capability_as4
   uint32_t as4;
 };
 
+#ifdef USE_SRX
+/* BGPSEC capability value */
+struct BgpsecCapVal
+{
+  uint8_t version_dir;
+#define BGPSEC_CAP_VERSION      (0 << 4)  /* current version of BGPSEC is 0 */
+#define BGPSEC_CAP_DIR_RECV     (0 << 3)
+#define BGPSEC_CAP_DIR_SEND     (1 << 3)
+
+  /* address family identifier */
+  uint16_t afi;
+#define BGPSEC_CAP_AFI_IPv4     1
+#define BGPSEC_CAP_AFI_IPv6     2
+};
+#endif
+
 struct graceful_restart_af
 {
   afi_t afi;
@@ -70,11 +86,17 @@ struct capability_gr
 #define CAPABILITY_CODE_MP              1 /* Multiprotocol Extensions */
 #define CAPABILITY_CODE_REFRESH         2 /* Route Refresh Capability */
 #define CAPABILITY_CODE_ORF             3 /* Cooperative Route Filtering Capability */
+#ifdef USE_SRX
+#define CAPABILITY_CODE_EXTENDED        6 /* Extended Message Support for BGP */
+#endif /* USE_SRX */
 #define CAPABILITY_CODE_RESTART        64 /* Graceful Restart Capability */
 #define CAPABILITY_CODE_AS4            65 /* 4-octet AS number Capability */
 #define CAPABILITY_CODE_DYNAMIC        66 /* Dynamic Capability */
 #define CAPABILITY_CODE_REFRESH_OLD   128 /* Route Refresh Capability(cisco) */
 #define CAPABILITY_CODE_ORF_OLD       130 /* Cooperative Route Filtering Capability(cisco) */
+#if defined(USE_SRX) && !defined(CAPABILITY_CODE_BGPSEC)
+#define CAPABILITY_CODE_BGPSEC          7 /* BGPSEC capability code in accordance with BRID */
+#endif /* USE_SRX && !CAPABILITY_CODE_BGPSEC */
 
 /* Capability Length */
 #define CAPABILITY_CODE_MP_LEN          4
@@ -82,6 +104,10 @@ struct capability_gr
 #define CAPABILITY_CODE_DYNAMIC_LEN     0
 #define CAPABILITY_CODE_RESTART_LEN     2 /* Receiving only case */
 #define CAPABILITY_CODE_AS4_LEN         4
+#ifdef USE_SRX
+#define CAPABILITY_CODE_BGPSEC_LEN      3
+#define CAPABILITY_CODE_EXTENDED_LEN    0 /* Extended Massage Support for BGP */
+#endif /* USE_SRX */
 
 /* Cooperative Route Filtering Capability.  */
 
@@ -107,5 +133,6 @@ extern void bgp_open_capability (struct 
 extern void bgp_capability_vty_out (struct vty *, struct peer *);
 extern as_t peek_for_as4_capability (struct peer *, u_char);
 extern int bgp_afi_safi_valid_indices (afi_t, safi_t *);
+void makeBgpsecCapability(struct stream* s, uint8_t version, uint8_t dir, uint16_t afi);
 
 #endif /* _QUAGGA_BGP_OPEN_H */
--- ./bgpd/bgp_attr.h	2013-01-26 21:25:34.000000000 -0500
+++ ./bgpd/bgp_attr.h	2017-06-26 15:53:49.000000000 -0400
@@ -21,6 +21,10 @@ Software Foundation, Inc., 59 Temple Pla
 #ifndef _QUAGGA_BGP_ATTR_H
 #define _QUAGGA_BGP_ATTR_H
 
+#ifdef USE_SRX
+#include <srx/srxcryptoapi.h>
+#endif // USE_SRX
+
 /* Simple bit mapping. */
 #define BITMAP_NBBY 8
 
@@ -87,6 +91,7 @@ struct attr_extra
   u_char mp_nexthop_len;
 };
 
+
 /* BGP core attribute structure. */
 struct attr
 {
@@ -112,6 +117,12 @@ struct attr
   
   /* Path origin attribute */
   u_char origin;
+
+#ifdef USE_SRX
+  struct BgpsecPathAttr *bgpsecPathAttr;
+
+  SCA_BGPSecValidationData* bgpsec_validationData;
+#endif
 };
 
 /* Router Reflector related structure. */
@@ -157,10 +168,20 @@ extern struct attr *bgp_attr_default_int
 extern struct attr *bgp_attr_aggregate_intern (struct bgp *, u_char,
                                         struct aspath *, 
                                         struct community *, int as_set);
+#ifdef USE_SRX
+// Added the OUT parameter fSetAspath which will be returned true if the
+// path was send as AS_PATH and false if the path was send as BGPSEC path.
+extern bgp_size_t bgp_packet_attribute (struct bgp *bgp, struct peer *,
+                                 struct stream *, struct attr *,
+                                 struct prefix *, afi_t, safi_t,
+                                 struct peer *, struct prefix_rd *, u_char *,
+                                 bool* fSetAspath);
+#else
 extern bgp_size_t bgp_packet_attribute (struct bgp *bgp, struct peer *, 
                                  struct stream *, struct attr *, 
                                  struct prefix *, afi_t, safi_t, 
                                  struct peer *, struct prefix_rd *, u_char *);
+#endif
 extern bgp_size_t bgp_packet_withdraw (struct peer *peer, struct stream *s, 
                                 struct prefix *p, afi_t, safi_t, 
                                 struct prefix_rd *, u_char *);
@@ -193,5 +214,4 @@ extern int bgp_mp_reach_parse (struct bg
 			       struct bgp_nlri *);
 extern int bgp_mp_unreach_parse (struct bgp_attr_parser_args *args,
                                  struct bgp_nlri *);
-
 #endif /* _QUAGGA_BGP_ATTR_H */
--- ./bgpd/bgp_nexthop.c	2013-01-26 21:25:34.000000000 -0500
+++ ./bgpd/bgp_nexthop.c	2017-06-26 15:53:49.000000000 -0400
@@ -1178,6 +1178,7 @@ zlookup_connect (struct thread *t)
   return 0;
 }
 
+
 /* Check specified multiaccess next-hop. */
 int
 bgp_multiaccess_check_v4 (struct in_addr nexthop, char *peer)
--- ./lib/memtypes.h	2013-01-27 08:18:14.000000000 -0500
+++ ./lib/memtypes.h	2017-06-26 15:53:49.000000000 -0400
@@ -127,6 +127,19 @@ enum
   MTYPE_BGP_REGEXP,
   MTYPE_BGP_AGGREGATE,
   MTYPE_BGP_ADDR,
+#ifdef USE_SRX
+  MTYPE_SRX_HOST,
+  MTYPE_SRX_SCA_CAPI,
+  MTYPE_BGP_INFO_HASH,
+  MTYPE_BGP_INFO_HASH_ITEM,
+  // see Bugzilla #20
+  MTYPE_BGP_INFO_HASH_MUTEX,
+  MTYPE_BGPSEC_PATH,
+  MTYPE_BGPSEC_SIGNATURE,
+  MTYPE_BGPSEC_PATH_SEG,
+  MTYPE_BGPSEC_SIG_SEG,
+  MTYPE_BGPSEC_SIG_BLK,
+#endif /* USE_SRX */
   MTYPE_RIP,
   MTYPE_RIP_INFO,
   MTYPE_RIP_INTERFACE,
--- ./lib/memtypes.c	2013-01-26 21:25:34.000000000 -0500
+++ ./lib/memtypes.c	2017-06-26 15:53:49.000000000 -0400
@@ -152,6 +152,20 @@ struct memory_list memory_list_bgp[] =
   { MTYPE_BGP_REGEXP,		"BGP regexp"			},
   { MTYPE_BGP_AGGREGATE,	"BGP aggregate"			},
   { MTYPE_BGP_ADDR,		"BGP own address"		},
+#ifdef USE_SRX
+  { 0, NULL },
+  { MTYPE_SRX_HOST,            "SRx host name" },
+  { MTYPE_SRX_SCA_CAPI,        "SRx Crypto API" },
+  { MTYPE_SRX_SCA_CAPI,        "BGPSEC Signature" },
+  { MTYPE_BGP_INFO_HASH,       "BGP info hash" },
+  { MTYPE_BGP_INFO_HASH_ITEM,  "BGP info hash item" },
+  { MTYPE_BGP_INFO_HASH_MUTEX, ""},
+  { MTYPE_BGPSEC_SIGNATURE,    "BGPSEC signature"},
+  { MTYPE_BGPSEC_PATH,         "BGPSEC PATH structure"},
+  { MTYPE_BGPSEC_PATH_SEG,     "BGPSEC PATH segment" },
+  { MTYPE_BGPSEC_SIG_SEG,      "Signal segment"},
+  { MTYPE_BGPSEC_SIG_BLK,      "Signal block"},  
+#endif /* USE_SRX */
   { -1, NULL }
 };
 
--- ./lib/version.h	2013-02-09 21:30:18.000000000 -0500
+++ ./lib/version.h	2017-07-11 13:03:50.000000000 -0400
@@ -35,11 +35,11 @@
 #define GIT_INFO ""
 #endif
 
-#define QUAGGA_PROGNAME   "Quagga"
+#define QUAGGA_PROGNAME   "QuaggaSRx"
 
-#define QUAGGA_VERSION     "0.99.22" GIT_SUFFIX
+#define QUAGGA_VERSION     "0.4.2.4" GIT_SUFFIX
 
-#define ZEBRA_BUG_ADDRESS "https://bugzilla.quagga.net"
+#define ZEBRA_BUG_ADDRESS "http://bgpsrx.antd.nist.gov"
 
 #define QUAGGA_URL "http://www.quagga.net"
 
--- ./config.h	1969-12-31 19:00:00.000000000 -0500
+++ ./config.h	2017-07-11 13:03:51.000000000 -0400
@@ -0,0 +1,867 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+/* #undef AC_APPLE_UNIVERSAL_BUILD */
+
+/* babeld vty socket */
+#define BABEL_VTYSH_PATH "/users/kyehwanl/Quagga_test/Proces_Performance/QuaggaSRxSuite/qsrx-gitsvn/test_install/etc/babeld.vty"
+
+/* bgpd vty socket */
+#define BGP_VTYSH_PATH "/users/kyehwanl/Quagga_test/Proces_Performance/QuaggaSRxSuite/qsrx-gitsvn/test_install/etc/bgpd.vty"
+
+/* BSDI */
+/* #undef BSDI_NRL */
+
+/* Mask for config files */
+#define CONFIGFILE_MASK 0644
+
+/* Consumed Time Check */
+#define CONSUMED_TIME_CHECK 5000000
+
+/* daemon vty directory */
+#define DAEMON_VTY_DIR "/users/kyehwanl/Quagga_test/Proces_Performance/QuaggaSRxSuite/qsrx-gitsvn/test_install/etc"
+
+/* Disable BGP installation to zebra */
+#define DISABLE_BGP_ANNOUNCE 0
+
+/* include git version info */
+/* #undef GIT_VERSION */
+
+/* GNU Linux */
+#define GNU_LINUX /**/
+
+/* Define to 1 if you have the `alarm' function. */
+#define HAVE_ALARM 1
+
+/* Define to 1 if you have the <arpa/inet.h> header file. */
+#define HAVE_ARPA_INET_H 1
+
+/* Define to 1 if you have the <asm/types.h> header file. */
+#define HAVE_ASM_TYPES_H 1
+
+/* Broken Alias */
+/* #undef HAVE_BROKEN_ALIASES */
+
+/* Broken CMSG_FIRSTHDR */
+/* #undef HAVE_BROKEN_CMSG_FIRSTHDR */
+
+/* BSD ifi_link_state available */
+/* #undef HAVE_BSD_IFI_LINK_STATE */
+
+/* BSD link-detect */
+/* #undef HAVE_BSD_LINK_DETECT */
+
+/* Can pass ifindex in struct ip_mreq */
+/* #undef HAVE_BSD_STRUCT_IP_MREQ_HACK */
+
+/* capabilities */
+/* #undef HAVE_CAPABILITIES */
+
+/* Define to 1 if your system has a working `chown' function. */
+#define HAVE_CHOWN 1
+
+/* Have monotonic clock */
+#define HAVE_CLOCK_MONOTONIC /**/
+
+/* Define to 1 if you have the `daemon' function. */
+#define HAVE_DAEMON 1
+
+/* Define to 1 if you have the declaration of `TCP_MD5SIG', and to 0 if you
+   don't. */
+#define HAVE_DECL_TCP_MD5SIG 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
+/* #undef HAVE_DOPRNT */
+
+/* Define to 1 if you have the `dup2' function. */
+#define HAVE_DUP2 1
+
+/* Define to 1 if you have the `fcntl' function. */
+#define HAVE_FCNTL 1
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define to 1 if your system has a working POSIX `fnmatch' function. */
+#define HAVE_FNMATCH 1
+
+/* Define to 1 if you have the `fork' function. */
+#define HAVE_FORK 1
+
+/* Forwarding Plane Manager support */
+/* #undef HAVE_FPM */
+
+/* Define to 1 if you have the `ftruncate' function. */
+#define HAVE_FTRUNCATE 1
+
+/* Define to 1 if you have the `getaddrinfo' function. */
+#define HAVE_GETADDRINFO 1
+
+/* Define to 1 if you have the `getcwd' function. */
+#define HAVE_GETCWD 1
+
+/* Define to 1 if you have the `gethostbyname' function. */
+#define HAVE_GETHOSTBYNAME 1
+
+/* Define to 1 if you have the `getifaddrs' function. */
+#define HAVE_GETIFADDRS 1
+
+/* Define to 1 if you have the `getpagesize' function. */
+#define HAVE_GETPAGESIZE 1
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#define HAVE_GETTIMEOFDAY 1
+
+/* Glibc backtrace */
+#define HAVE_GLIBC_BACKTRACE /**/
+
+/* GNU regexp library */
+#define HAVE_GNU_REGEX /**/
+
+/* Define to 1 if you have the `if_indextoname' function. */
+#define HAVE_IF_INDEXTONAME 1
+
+/* Define to 1 if you have the `if_nametoindex' function. */
+#define HAVE_IF_NAMETOINDEX 1
+
+/* __inet_aton */
+#define HAVE_INET_ATON 1
+
+/* Define to 1 if you have the <inet/nd.h> header file. */
+/* #undef HAVE_INET_ND_H */
+
+/* Define to 1 if you have the `inet_ntoa' function. */
+#define HAVE_INET_NTOA 1
+
+/* __inet_ntop */
+#define HAVE_INET_NTOP /**/
+
+/* __inet_pton */
+#define HAVE_INET_PTON /**/
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Linux IPv6 */
+#define HAVE_IPV6 1
+
+/* IRDP */
+#define HAVE_IRDP /**/
+
+/* Define to 1 if you have the <kvm.h> header file. */
+/* #undef HAVE_KVM_H */
+
+/* Capabilities */
+/* #undef HAVE_LCAPS */
+
+/* Define to 1 if you have the `crypt' library (-lcrypt). */
+#define HAVE_LIBCRYPT 1
+
+/* Define to 1 if you have the `kvm' library (-lkvm). */
+/* #undef HAVE_LIBKVM */
+
+/* Have libm */
+#define HAVE_LIBM /**/
+
+/* Define to 1 if you have the `nsl' library (-lnsl). */
+/* #undef HAVE_LIBNSL */
+
+/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
+/* #undef HAVE_LIBPCREPOSIX */
+
+/* Define to 1 if you have the `resolv' library (-lresolv). */
+/* #undef HAVE_LIBRESOLV */
+
+/* Define to 1 if you have the `socket' library (-lsocket). */
+/* #undef HAVE_LIBSOCKET */
+
+/* Define to 1 if you have the `umem' library (-lumem). */
+/* #undef HAVE_LIBUMEM */
+
+/* Define to 1 if you have the `xnet' library (-lxnet). */
+/* #undef HAVE_LIBXNET */
+
+/* Define to 1 if you have the <limits.h> header file. */
+#define HAVE_LIMITS_H 1
+
+/* Define to 1 if you have the <linux/version.h> header file. */
+#define HAVE_LINUX_VERSION_H 1
+
+/* mallinfo */
+#define HAVE_MALLINFO /**/
+
+/* Define to 1 if you have the `memchr' function. */
+#define HAVE_MEMCHR 1
+
+/* Define to 1 if you have the `memmove' function. */
+#define HAVE_MEMMOVE 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `memset' function. */
+#define HAVE_MEMSET 1
+
+/* Define to 1 if you have the <netdb.h> header file. */
+#define HAVE_NETDB_H 1
+
+/* Define to 1 if you have the <netinet6/in6.h> header file. */
+/* #undef HAVE_NETINET6_IN6_H */
+
+/* Define to 1 if you have the <netinet6/in6_var.h> header file. */
+/* #undef HAVE_NETINET6_IN6_VAR_H */
+
+/* Define to 1 if you have the <netinet6/nd6.h> header file. */
+/* #undef HAVE_NETINET6_ND6_H */
+
+/* Define to 1 if you have the <netinet/icmp6.h> header file. */
+#define HAVE_NETINET_ICMP6_H 1
+
+/* Define to 1 if you have the <netinet/in6_var.h> header file. */
+/* #undef HAVE_NETINET_IN6_VAR_H */
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#define HAVE_NETINET_IN_H 1
+
+/* Define to 1 if you have the <netinet/in_systm.h> header file. */
+#define HAVE_NETINET_IN_SYSTM_H 1
+
+/* Define to 1 if you have the <netinet/in_var.h> header file. */
+/* #undef HAVE_NETINET_IN_VAR_H */
+
+/* Define to 1 if you have the <netinet/ip_icmp.h> header file. */
+#define HAVE_NETINET_IP_ICMP_H 1
+
+/* netlink */
+#define HAVE_NETLINK /**/
+
+/* Define to 1 if you have the <net/if_dl.h> header file. */
+/* #undef HAVE_NET_IF_DL_H */
+
+/* Define to 1 if you have the <net/if.h> header file. */
+#define HAVE_NET_IF_H 1
+
+/* Define to 1 if you have the <net/if_var.h> header file. */
+/* #undef HAVE_NET_IF_VAR_H */
+
+/* Define to 1 if you have the <net/netopt.h> header file. */
+/* #undef HAVE_NET_NETOPT_H */
+
+/* Define to 1 if you have the <net/route.h> header file. */
+#define HAVE_NET_ROUTE_H 1
+
+/* NET_RT_IFLIST */
+/* #undef HAVE_NET_RT_IFLIST */
+
+/* OSPF Opaque LSA */
+#define HAVE_OPAQUE_LSA /**/
+
+/* Have openpam.h */
+/* #undef HAVE_OPENPAM_H */
+
+/* OSPF TE */
+#define HAVE_OSPF_TE /**/
+
+/* Have pam_misc.h */
+/* #undef HAVE_PAM_MISC_H */
+
+/* Define to 1 if you have the `pow' function. */
+#define HAVE_POW 1
+
+/* Solaris printstack */
+/* #undef HAVE_PRINTSTACK */
+
+/* Define to 1 if you have the <priv.h> header file. */
+/* #undef HAVE_PRIV_H */
+
+/* /proc/net/dev */
+/* #undef HAVE_PROC_NET_DEV */
+
+/* /proc/net/if_inet6 */
+/* #undef HAVE_PROC_NET_IF_INET6 */
+
+/* prctl */
+#define HAVE_PR_SET_KEEPCAPS /**/
+
+/* Have RFC3678 protocol-independed API */
+#define HAVE_RFC3678 1
+
+/* Enable IPv6 Routing Advertisement support */
+#define HAVE_RTADV /**/
+
+/* rusage */
+#define HAVE_RUSAGE /**/
+
+/* Define to 1 if you have the `select' function. */
+#define HAVE_SELECT 1
+
+/* Have setproctitle */
+/* #undef HAVE_SETPROCTITLE */
+
+/* Define to 1 if you have the <signal.h> header file. */
+#define HAVE_SIGNAL_H 1
+
+/* SNMP */
+/* #undef HAVE_SNMP */
+
+/* Define to 1 if you have the `snprintf' function. */
+#define HAVE_SNPRINTF 1
+
+/* Define to 1 if you have the `socket' function. */
+#define HAVE_SOCKET 1
+
+/* Define to 1 if the system has the type `socklen_t'. */
+#define HAVE_SOCKLEN_T 1
+
+/* getpflags */
+/* #undef HAVE_SOLARIS_CAPABILITIES */
+
+/* Stack symbol decoding */
+#define HAVE_STACK_TRACE /**/
+
+/* Define to 1 if `stat' has the bug that it succeeds when given the
+   zero-length file name argument. */
+/* #undef HAVE_STAT_EMPTY_STRING_BUG */
+
+/* Define to 1 if you have the <stddef.h> header file. */
+#define HAVE_STDDEF_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strcasecmp' function. */
+#define HAVE_STRCASECMP 1
+
+/* Define to 1 if you have the `strchr' function. */
+#define HAVE_STRCHR 1
+
+/* Define to 1 if you have the `strcspn' function. */
+#define HAVE_STRCSPN 1
+
+/* Define to 1 if you have the `strdup' function. */
+#define HAVE_STRDUP 1
+
+/* Define to 1 if you have the `strerror' function. */
+#define HAVE_STRERROR 1
+
+/* Define to 1 if you have the `strftime' function. */
+#define HAVE_STRFTIME 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strlcat' function. */
+/* #undef HAVE_STRLCAT */
+
+/* Define to 1 if you have the `strlcpy' function. */
+/* #undef HAVE_STRLCPY */
+
+/* Define to 1 if you have the `strncasecmp' function. */
+#define HAVE_STRNCASECMP 1
+
+/* Define to 1 if you have the `strndup' function. */
+#define HAVE_STRNDUP 1
+
+/* Define to 1 if you have the `strnlen' function. */
+#define HAVE_STRNLEN 1
+
+/* Define to 1 if you have the <stropts.h> header file. */
+/* #undef HAVE_STROPTS_H */
+
+/* Define to 1 if you have the `strrchr' function. */
+#define HAVE_STRRCHR 1
+
+/* Define to 1 if you have the `strspn' function. */
+#define HAVE_STRSPN 1
+
+/* Define to 1 if you have the `strstr' function. */
+#define HAVE_STRSTR 1
+
+/* Define to 1 if you have the `strtol' function. */
+#define HAVE_STRTOL 1
+
+/* Define to 1 if you have the `strtoul' function. */
+#define HAVE_STRTOUL 1
+
+/* Define to 1 if the system has the type `struct icmphdr'. */
+#define HAVE_STRUCT_ICMPHDR 1
+
+/* Define to 1 if the system has the type `struct if6_aliasreq'. */
+/* #undef HAVE_STRUCT_IF6_ALIASREQ */
+
+/* Define to 1 if `ifra_lifetime' is a member of `struct if6_aliasreq'. */
+/* #undef HAVE_STRUCT_IF6_ALIASREQ_IFRA_LIFETIME */
+
+/* Define to 1 if the system has the type `struct ifaliasreq'. */
+/* #undef HAVE_STRUCT_IFALIASREQ */
+
+/* Define to 1 if `ifm_status' is a member of `struct ifmediareq'. */
+/* #undef HAVE_STRUCT_IFMEDIAREQ_IFM_STATUS */
+
+/* Define to 1 if `ifi_link_state' is a member of `struct if_data'. */
+/* #undef HAVE_STRUCT_IF_DATA_IFI_LINK_STATE */
+
+/* Define to 1 if the system has the type `struct in6_aliasreq'. */
+/* #undef HAVE_STRUCT_IN6_ALIASREQ */
+
+/* Define to 1 if the system has the type `struct in_pktinfo'. */
+#define HAVE_STRUCT_IN_PKTINFO 1
+
+/* Define to 1 if `imr_ifindex' is a member of `struct ip_mreqn'. */
+#define HAVE_STRUCT_IP_MREQN_IMR_IFINDEX 1
+
+/* Define to 1 if the system has the type `struct nd_opt_adv_interval'. */
+#define HAVE_STRUCT_ND_OPT_ADV_INTERVAL 1
+
+/* Define to 1 if `nd_opt_ai_type' is a member of `struct
+   nd_opt_adv_interval'. */
+/* #undef HAVE_STRUCT_ND_OPT_ADV_INTERVAL_ND_OPT_AI_TYPE */
+
+/* Define to 1 if the system has the type `struct nd_opt_homeagent_info'. */
+/* #undef HAVE_STRUCT_ND_OPT_HOMEAGENT_INFO */
+
+/* Define to 1 if the system has the type `struct rt_addrinfo'. */
+/* #undef HAVE_STRUCT_RT_ADDRINFO */
+
+/* Define to 1 if the system has the type `struct sockaddr'. */
+#define HAVE_STRUCT_SOCKADDR 1
+
+/* Define to 1 if the system has the type `struct sockaddr_dl'. */
+/* #undef HAVE_STRUCT_SOCKADDR_DL */
+
+/* Define to 1 if `sdl_len' is a member of `struct sockaddr_dl'. */
+/* #undef HAVE_STRUCT_SOCKADDR_DL_SDL_LEN */
+
+/* Define to 1 if the system has the type `struct sockaddr_in'. */
+#define HAVE_STRUCT_SOCKADDR_IN 1
+
+/* Define to 1 if the system has the type `struct sockaddr_in6'. */
+#define HAVE_STRUCT_SOCKADDR_IN6 1
+
+/* Define to 1 if `sin6_scope_id' is a member of `struct sockaddr_in6'. */
+#define HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID 1
+
+/* Define to 1 if `sin_len' is a member of `struct sockaddr_in'. */
+/* #undef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN */
+
+/* Define to 1 if `sa_len' is a member of `struct sockaddr'. */
+/* #undef HAVE_STRUCT_SOCKADDR_SA_LEN */
+
+/* Define to 1 if the system has the type `struct sockaddr_un'. */
+#define HAVE_STRUCT_SOCKADDR_UN 1
+
+/* Define to 1 if `sun_len' is a member of `struct sockaddr_un'. */
+/* #undef HAVE_STRUCT_SOCKADDR_UN_SUN_LEN */
+
+/* Define to 1 if you have the <syslog.h> header file. */
+#define HAVE_SYSLOG_H 1
+
+/* Define to 1 if you have the <sys/capability.h> header file. */
+/* #undef HAVE_SYS_CAPABILITY_H */
+
+/* Define to 1 if you have the <sys/conf.h> header file. */
+/* #undef HAVE_SYS_CONF_H */
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/ksym.h> header file. */
+/* #undef HAVE_SYS_KSYM_H */
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#define HAVE_SYS_PARAM_H 1
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/sockio.h> header file. */
+/* #undef HAVE_SYS_SOCKIO_H */
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/sysctl.h> header file. */
+#define HAVE_SYS_SYSCTL_H 1
+
+/* Define to 1 if you have the <sys/times.h> header file. */
+#define HAVE_SYS_TIMES_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/un.h> header file. */
+#define HAVE_SYS_UN_H 1
+
+/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
+#define HAVE_SYS_WAIT_H 1
+
+/* Define this if your system can create weak aliases */
+#define HAVE_SYS_WEAK_ALIAS 1
+
+/* Define this if weak aliases may be created with __attribute__ */
+#define HAVE_SYS_WEAK_ALIAS_ATTRIBUTE 1
+
+/* Define this if weak aliases may be created with #pragma _CRI duplicate */
+/* #undef HAVE_SYS_WEAK_ALIAS_CRIDUPLICATE */
+
+/* Define this if weak aliases in other files are honored */
+#define HAVE_SYS_WEAK_ALIAS_CROSSFILE 1
+
+/* Define this if weak aliases may be created with #pragma _HP_SECONDARY_DEF
+   */
+/* #undef HAVE_SYS_WEAK_ALIAS_HPSECONDARY */
+
+/* Define this if weak aliases may be created with #pragma weak */
+#define HAVE_SYS_WEAK_ALIAS_PRAGMA 1
+
+/* Old Linux 2.4 TCP MD5 Signature Patch */
+/* #undef HAVE_TCP_MD5_LINUX24 */
+
+/* Use TCP for zebra communication */
+/* #undef HAVE_TCP_ZEBRA */
+
+/* Define to 1 if you have the <time.h> header file. */
+#define HAVE_TIME_H 1
+
+/* Define to 1 if you have the <ucontext.h> header file. */
+#define HAVE_UCONTEXT_H 1
+
+/* Define to 1 if you have the `uname' function. */
+#define HAVE_UNAME 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the <uthash.h> header file. */
+#define HAVE_UTHASH_H 1
+
+/* Define to 1 if you have the `vfork' function. */
+#define HAVE_VFORK 1
+
+/* Define to 1 if you have the <vfork.h> header file. */
+/* #undef HAVE_VFORK_H */
+
+/* Define to 1 if you have the `vprintf' function. */
+#define HAVE_VPRINTF 1
+
+/* Define to 1 if you have the `vsnprintf' function. */
+#define HAVE_VSNPRINTF 1
+
+/* Define to 1 if you have the <wchar.h> header file. */
+#define HAVE_WCHAR_H 1
+
+/* Define to 1 if you have the <wctype.h> header file. */
+#define HAVE_WCTYPE_H 1
+
+/* Define to 1 if `fork' works. */
+#define HAVE_WORKING_FORK 1
+
+/* Define to 1 if `vfork' works. */
+#define HAVE_WORKING_VFORK 1
+
+/* INRIA IPv6 */
+/* #undef INRIA_IPV6 */
+
+/* IRIX 6.5 */
+/* #undef IRIX_65 */
+
+/* selected method for isis, == one of the constants */
+#define ISIS_METHOD ISIS_METHOD_PFPACKET
+
+/* constant value for isis method bpf */
+#define ISIS_METHOD_BPF 3
+
+/* constant value for isis method dlpi */
+#define ISIS_METHOD_DLPI 2
+
+/* constant value for isis method pfpacket */
+#define ISIS_METHOD_PFPACKET 1
+
+/* isisd vty socket */
+#define ISIS_VTYSH_PATH "/users/kyehwanl/Quagga_test/Proces_Performance/QuaggaSRxSuite/qsrx-gitsvn/test_install/etc/isisd.vty"
+
+/* KAME IPv6 stack */
+/* #undef KAME */
+
+/* Linux IPv6 stack */
+#define LINUX_IPV6 1
+
+/* Mask for log files */
+#define LOGFILE_MASK 0644
+
+/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
+   slash. */
+#define LSTAT_FOLLOWS_SLASHED_SYMLINK 1
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#define LT_OBJDIR ".libs/"
+
+/* Musica IPv6 stack */
+/* #undef MUSICA */
+
+/* Define to 1 if your C compiler doesn't accept -c and -o together. */
+/* #undef NO_MINUS_C_MINUS_O */
+
+/* NRL */
+/* #undef NRL */
+
+/* OpenBSD */
+/* #undef OPEN_BSD */
+
+/* ospf6d vty socket */
+#define OSPF6_VTYSH_PATH "/users/kyehwanl/Quagga_test/Proces_Performance/QuaggaSRxSuite/qsrx-gitsvn/test_install/etc/ospf6d.vty"
+
+/* ospfd vty socket */
+#define OSPF_VTYSH_PATH "/users/kyehwanl/Quagga_test/Proces_Performance/QuaggaSRxSuite/qsrx-gitsvn/test_install/etc/ospfd.vty"
+
+/* Name of package */
+#define PACKAGE "quaggasrx"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "http://bgpsrx.antd.nist.gov"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "QuaggaSRx"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "QuaggaSRx 0.4.2.4"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "quaggasrx"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "0.4.2.4"
+
+/* Have openpam_ttyconv */
+/* #undef PAM_CONV_FUNC */
+
+/* babeld PID */
+#define PATH_BABELD_PID "/users/kyehwanl/Quagga_test/Proces_Performance/QuaggaSRxSuite/qsrx-gitsvn/test_install/etc/babeld.pid"
+
+/* bgpd PID */
+#define PATH_BGPD_PID "/users/kyehwanl/Quagga_test/Proces_Performance/QuaggaSRxSuite/qsrx-gitsvn/test_install/etc/bgpd.pid"
+
+/* isisd PID */
+#define PATH_ISISD_PID "/users/kyehwanl/Quagga_test/Proces_Performance/QuaggaSRxSuite/qsrx-gitsvn/test_install/etc/isisd.pid"
+
+/* ospf6d PID */
+#define PATH_OSPF6D_PID "/users/kyehwanl/Quagga_test/Proces_Performance/QuaggaSRxSuite/qsrx-gitsvn/test_install/etc/ospf6d.pid"
+
+/* ospfd PID */
+#define PATH_OSPFD_PID "/users/kyehwanl/Quagga_test/Proces_Performance/QuaggaSRxSuite/qsrx-gitsvn/test_install/etc/ospfd.pid"
+
+/* ripd PID */
+#define PATH_RIPD_PID "/users/kyehwanl/Quagga_test/Proces_Performance/QuaggaSRxSuite/qsrx-gitsvn/test_install/etc/ripd.pid"
+
+/* ripngd PID */
+#define PATH_RIPNGD_PID "/users/kyehwanl/Quagga_test/Proces_Performance/QuaggaSRxSuite/qsrx-gitsvn/test_install/etc/ripngd.pid"
+
+/* watchquagga PID */
+#define PATH_WATCHQUAGGA_PID "/users/kyehwanl/Quagga_test/Proces_Performance/QuaggaSRxSuite/qsrx-gitsvn/test_install/etc/watchquagga.pid"
+
+/* zebra PID */
+#define PATH_ZEBRA_PID "/users/kyehwanl/Quagga_test/Proces_Performance/QuaggaSRxSuite/qsrx-gitsvn/test_install/etc/zebra.pid"
+
+/* Quagga Group */
+#define QUAGGA_GROUP "root"
+
+/* Hide deprecated interfaces */
+#define QUAGGA_NO_DEPRECATED_INTERFACES 1
+
+/* Quagga User */
+#define QUAGGA_USER "root"
+
+/* Define as the return type of signal handlers (`int' or `void'). */
+#define RETSIGTYPE void
+
+/* ripng vty socket */
+#define RIPNG_VTYSH_PATH "/users/kyehwanl/Quagga_test/Proces_Performance/QuaggaSRxSuite/qsrx-gitsvn/test_install/etc/ripngd.vty"
+
+/* rip vty socket */
+#define RIP_VTYSH_PATH "/users/kyehwanl/Quagga_test/Proces_Performance/QuaggaSRxSuite/qsrx-gitsvn/test_install/etc/ripd.vty"
+
+/* Define to the type of arg 1 for `select'. */
+#define SELECT_TYPE_ARG1 int
+
+/* Define to the type of args 2, 3 and 4 for `select'. */
+#define SELECT_TYPE_ARG234 (fd_set *)
+
+/* Define to the type of arg 5 for `select'. */
+#define SELECT_TYPE_ARG5 (struct timeval *)
+
+/* Use SNMP AgentX to interface with snmpd */
+/* #undef SNMP_AGENTX */
+
+/* Use SNMP SMUX to interface with snmpd */
+/* #undef SNMP_SMUX */
+
+/* Solaris IPv6 */
+/* #undef SOLARIS_IPV6 */
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* SunOS 5 */
+/* #undef SUNOS_5 */
+
+/* SunOS 5.6 to 5.7 */
+/* #undef SUNOS_56 */
+
+/* SunOS 5.8 up */
+/* #undef SUNOS_59 */
+
+/* OSPFAPI */
+/* #undef SUPPORT_OSPF_API */
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define TIME_WITH_SYS_TIME 1
+
+/* Define to 1 if your <sys/time.h> declares `struct tm'. */
+/* #undef TM_IN_SYS_TIME */
+
+/* Enable IS-IS topology generator code */
+/* #undef TOPOLOGY_GENERATE */
+
+/* Use PAM for authentication */
+/* #undef USE_PAM */
+
+/* SRX */
+#define USE_SRX /**/
+
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+# define _ALL_SOURCE 1
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE 1
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# define _POSIX_PTHREAD_SEMANTICS 1
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# define _TANDEM_SOURCE 1
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# define __EXTENSIONS__ 1
+#endif
+
+
+/* Version number of package */
+#define VERSION "0.4.2.4"
+
+/* VTY shell */
+/* #undef VTYSH */
+
+/* VTY Sockets Group */
+/* #undef VTY_GROUP */
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+/* #  undef WORDS_BIGENDIAN */
+# endif
+#endif
+
+/* zebra api socket */
+#define ZEBRA_SERV_PATH "/users/kyehwanl/Quagga_test/Proces_Performance/QuaggaSRxSuite/qsrx-gitsvn/test_install/etc/zserv.api"
+
+/* zebra vty socket */
+#define ZEBRA_VTYSH_PATH "/users/kyehwanl/Quagga_test/Proces_Performance/QuaggaSRxSuite/qsrx-gitsvn/test_install/etc/zebra.vty"
+
+/* Enable large inode numbers on Mac OS X 10.5.  */
+#ifndef _DARWIN_USE_64_BIT_INODE
+# define _DARWIN_USE_64_BIT_INODE 1
+#endif
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+#define _FILE_OFFSET_BITS 64
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef _LARGE_FILES */
+
+/* Define to 1 if on MINIX. */
+/* #undef _MINIX */
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+/* #undef _POSIX_1_SOURCE */
+
+/* Define to 1 if you need to in order for `stat' and other things to work. */
+/* #undef _POSIX_SOURCE */
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+/* #undef gid_t */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef mode_t */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef pid_t */
+
+/* Define to the equivalent of the C99 'restrict' keyword, or to
+   nothing if this is not supported.  Do not define if restrict is
+   supported directly.  */
+#define restrict __restrict
+/* Work around a bug in Sun C++: it does not support _Restrict or
+   __restrict__, even though the corresponding Sun C compiler ends up with
+   "#define restrict _Restrict" or "#define restrict __restrict__" in the
+   previous line.  Perhaps some future version of Sun C++ will work with
+   restrict; if so, hopefully it defines __RESTRICT like Sun C does.  */
+#if defined __SUNPRO_CC && !defined __RESTRICT
+# define _Restrict
+# define __restrict__
+#endif
+
+/* Old readline */
+/* #undef rl_completion_matches */
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+/* #undef uid_t */
+
+/* Define as `fork' if `vfork' does not work. */
+/* #undef vfork */
+
+/* Define to empty if the keyword `volatile' does not work. Warning: valid
+   code using `volatile' can become incorrect without. Disable with care. */
+/* #undef volatile */
