diff --git a/quaggasrx/bgpd/bgp_advertise.c b/quaggasrx/bgpd/bgp_advertise.c
index 079b4a2..6133eb8 100644
--- a/quaggasrx/bgpd/bgp_advertise.c
+++ b/quaggasrx/bgpd/bgp_advertise.c
@@ -120,6 +120,20 @@ bgp_advertise_delete (struct bgp_advertise_attr *baa,
     baa->adv = adv->next;
 }
 
+#ifdef SRX_COMM
+struct bgp_advertise_attr *
+bgp_advertise_intern_mod (struct hash *hash, struct attr *attr)
+{
+  struct bgp_advertise_attr ref;
+  struct bgp_advertise_attr *baa;
+
+  ref.attr = bgp_attr_intern (attr);
+  baa = (struct bgp_advertise_attr *) hash_get (hash, &ref, baa_hash_alloc);
+  baa->refcnt++;
+
+  return baa;
+}
+#endif
 static struct bgp_advertise_attr *
 bgp_advertise_intern (struct hash *hash, struct attr *attr)
 {
@@ -191,7 +205,7 @@ bgp_advertise_clean (struct peer *peer, struct bgp_adj_out *adj,
   next = NULL;
 
 #ifdef USE_SRX
-  zlog_debug("[%s] advertisement deletion called\n", __FUNCTION__);
+  printf("[%s] advertisement deletion called\n", __FUNCTION__);
 #endif
   if (baa)
     {
diff --git a/quaggasrx/bgpd/bgp_attr.c b/quaggasrx/bgpd/bgp_attr.c
index c72a3cc..5e160ed 100644
--- a/quaggasrx/bgpd/bgp_attr.c
+++ b/quaggasrx/bgpd/bgp_attr.c
@@ -287,6 +287,14 @@ transit_finish (void)
 /* Attribute hash routines. */
 static struct hash *attrhash;
 
+#ifdef SRX_COMM
+struct hash *
+attribute_hash(void)
+{
+  return attrhash;
+}
+#endif
+
 static struct attr_extra *
 bgp_attr_extra_new (void)
 {
@@ -462,8 +470,27 @@ static void
 attr_show_all_iterator (struct hash_backet *backet, struct vty *vty)
 {
   struct attr *attr = backet->data;
+
+#ifdef SRX_COMM
+  vty_out (vty, "attr: %p cnt:[%ld] nexthop:%s ", attr, attr->refcnt,
+	   inet_ntoa (attr->nexthop) );
+  if(attr->community && attr->community->str)
+    vty_out(vty, "comm:[%p]:%s ", attr->community, attr->community->str);
+  if(attr->extra && attr->extra->ecommunity && attr->extra->ecommunity->str)
+  {
+    vty_out(vty, "ext:(%p) ext-comm:[%p]:%s ",
+        attr->extra, attr->extra->ecommunity, attr->extra->ecommunity->str);
+    if(attr->extra->ecommunity->val)
+    {
+      struct ecommunity *ecom = attr->extra->ecommunity;
+      vty_out(vty, "val: (type)0x%x, (ValidStatus)0x%x", ecom->val[0], ecom->val[7]);
+    }
+  }
+  vty_out(vty, "%s", VTY_NEWLINE);
+#else
   vty_out (vty, "attr[%ld] nexthop %s%s", attr->refcnt,
 	   inet_ntoa (attr->nexthop), VTY_NEWLINE);
+#endif
 }
 
 void
@@ -475,6 +502,53 @@ attr_show_all (struct vty *vty)
 		vty);
 }
 
+#ifdef SRX_COMM
+int
+attr_show_all_iterator_mod (struct hash_backet *backet, struct attr **lplp_attr, void * com)
+{
+  struct attr *attr = backet->data;
+
+  *lplp_attr = attr;
+  printf(" lplp_attr:%p  attr: %p attr-community:%p  com:%p\n", \
+      lplp_attr, attr, attr->community, com);
+
+  if( attr->community == com)
+    return 1;
+  return 0;
+
+}
+
+int find_attr (struct attr **attr, void* com)
+{
+  int ret=0;
+  ret = hash_iterate_once (attrhash,
+      (int (*)(struct hash_backet *, void *, void*))
+      attr_show_all_iterator_mod,
+      attr,
+      com);
+  return ret;
+}
+
+void * bgp_attr_hash_alloc_mod (void *p)
+{
+  struct attr * val = (struct attr *) p;
+  struct attr *attr;
+
+  attr = XMALLOC (MTYPE_ATTR, sizeof (struct attr));
+  *attr = *val;
+  if (val->extra)
+  {
+    printf(" --if Instruction Pointer comes here, you need \
+        additional job for the extra value---- \n");
+    attr->extra = bgp_attr_extra_new ();
+    *attr->extra = *val->extra;
+  }
+  attr->refcnt = val->refcnt;
+  return attr;
+}
+
+#endif
+
 static void *
 bgp_attr_hash_alloc (void *p)
 {
@@ -512,6 +586,13 @@ bgp_attr_intern (struct attr *attr)
 	attr->community = community_intern (attr->community);
       else
 	attr->community->refcnt++;
+#ifdef SRX_COMM
+      printf("[bgp_attr_intern] attr:%p comm:%p attr->community->refcnt: %d  %s \n", \
+          attr,\
+          attr->community,\
+          attr->community->refcnt, \
+          attr->community->str);
+#endif
     }
   if (attr->extra)
     {
@@ -685,6 +766,10 @@ bgp_attr_unintern (struct attr **pattr)
       memcpy (tmp.extra, attr->extra, sizeof (struct attr_extra));
     }
 
+#ifdef SRX_COMM
+      printf("[%s] attr:%p cnt:%d  from pattr:%p \n",
+          __FUNCTION__, attr, attr->refcnt, pattr);
+#endif
   /* If reference becomes zero then free attribute object. */
   if (attr->refcnt == 0)
     {
@@ -1394,6 +1479,12 @@ bgp_attr_community (struct bgp_attr_parser_args *args)
                                BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,
                                args->total);
 
+#ifdef SRX_COMM
+  printf("[---bgp_attr community] %p attr->community->refcnt: %d %s \n" , attr->community, \
+      attr->community->refcnt, \
+      attr->community->str);
+#endif
+
   attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES);
 
   return BGP_ATTR_PARSE_PROCEED;
@@ -2224,6 +2315,15 @@ bgp_packet_attribute (struct bgp *bgp, struct peer *peer,
     }
 
   /* Community attribute. */
+#ifdef __SRX_COMM
+  printf(" -------- here community check and send \n");
+
+  //stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);
+  //stream_putc (s, BGP_ATTR_COMMUNITIES);
+  //stream_putc (s, 1 * 4);
+  //stream_put (s, "0x1", 1 * 4);
+  SET_FLAG(attr->flag, BGP_ATTR_FLAG_OPTIONAL);
+#endif
   if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY)
       && (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES)))
     {
@@ -2241,6 +2341,9 @@ bgp_packet_attribute (struct bgp *bgp, struct peer *peer,
 	}
       stream_put (s, attr->community->val, attr->community->size * 4);
     }
+#ifdef __SRX_COMM
+  UNSET_FLAG(attr->flag, BGP_ATTR_FLAG_OPTIONAL);
+#endif
 
   /* Route Reflector. */
   if (peer->sort == BGP_PEER_IBGP
diff --git a/quaggasrx/bgpd/bgp_attr.h b/quaggasrx/bgpd/bgp_attr.h
index 1602542..c6a46fc 100644
--- a/quaggasrx/bgpd/bgp_attr.h
+++ b/quaggasrx/bgpd/bgp_attr.h
@@ -169,6 +169,9 @@ extern void bgp_dump_routes_attr (struct stream *, struct attr *,
 extern int attrhash_cmp (const void *, const void *);
 extern unsigned int attrhash_key_make (void *);
 extern void attr_show_all (struct vty *);
+#ifdef SRX_COMM
+extern int find_attr (struct attr **attr, void* com);
+#endif
 extern unsigned long int attr_count (void);
 extern unsigned long int attr_unknown_count (void);
 
@@ -193,4 +196,7 @@ extern int bgp_mp_reach_parse (struct bgp_attr_parser_args *args,
 			       struct bgp_nlri *);
 extern int bgp_mp_unreach_parse (struct bgp_attr_parser_args *args,
                                  struct bgp_nlri *);
+#ifdef SRX_COMM
+extern void * bgp_attr_hash_alloc_mod (void *p);
+#endif
 #endif /* _QUAGGA_BGP_ATTR_H */
diff --git a/quaggasrx/bgpd/bgp_community.c b/quaggasrx/bgpd/bgp_community.c
index df234e1..160ffb1 100644
--- a/quaggasrx/bgpd/bgp_community.c
+++ b/quaggasrx/bgpd/bgp_community.c
@@ -292,6 +292,107 @@ community_com2str  (struct community *com)
   return str;
 }
 
+#ifdef SRX_COMM
+char *
+community_com2str_mod  (struct community *com)
+{
+  int i;
+  char *str;
+  char *pnt;
+  int len;
+  int first;
+  u_int32_t comval;
+  u_int16_t as;
+  u_int16_t val;
+
+  if (!com)
+    return NULL;
+
+  /* When communities attribute is empty.  */
+  if (com->size == 0)
+  {
+    str = XMALLOC (MTYPE_COMMUNITY_STR, 1);
+    str[0] = '\0';
+    return str;
+  }
+
+  /* Memory allocation is time consuming work.  So we calculate
+     required string length first.  */
+  len = 0;
+
+  for (i = 0; i < com->size; i++)
+  {
+    memcpy (&comval, com_nthval (com, i), sizeof (u_int32_t));
+    comval = ntohl (comval);
+
+    switch (comval)
+    {
+      case COMMUNITY_INTERNET:
+        len += strlen (" internet");
+        break;
+      case COMMUNITY_NO_EXPORT:
+        len += strlen (" no-export");
+        break;
+      case COMMUNITY_NO_ADVERTISE:
+        len += strlen (" no-advertise");
+        break;
+      case COMMUNITY_LOCAL_AS:
+        len += strlen (" local-AS");
+        break;
+      default:
+        len += strlen (" 65536:65535");
+        break;
+    }
+  }
+
+  /* Allocate memory.  */
+  str = pnt = XMALLOC (MTYPE_COMMUNITY_STR, len);
+  first = 1;
+
+  /* Fill in string.  */
+  for (i = 0; i < com->size; i++)
+  {
+    memcpy (&comval, com_nthval (com, i), sizeof (u_int32_t));
+    comval = ntohl (comval);
+
+    if (first)
+      first = 0;
+    else
+      *pnt++ = ' ';
+
+    switch (comval)
+    {
+      case COMMUNITY_INTERNET:
+        strcpy (pnt, "internet");
+        pnt += strlen ("internet");
+        break;
+      case COMMUNITY_NO_EXPORT:
+        strcpy (pnt, "no-export");
+        pnt += strlen ("no-export");
+        break;
+      case COMMUNITY_NO_ADVERTISE:
+        strcpy (pnt, "no-advertise");
+        pnt += strlen ("no-advertise");
+        break;
+      case COMMUNITY_LOCAL_AS:
+        strcpy (pnt, "local-AS");
+        pnt += strlen ("local-AS");
+        break;
+      default:
+        as = (comval >> 16) & 0xFFFF;
+        val = comval & 0xFFFF;
+        sprintf (pnt, "%u:%d", as, val);
+        pnt += strlen (pnt);
+        break;
+    }
+  }
+  *pnt = '\0';
+
+  return str;
+}
+#endif
+
+
 /* Intern communities attribute.  */
 struct community *
 community_intern (struct community *com)
@@ -333,11 +434,18 @@ community_unintern (struct community **com)
     {
       /* Community value com must exist in hash. */
       ret = (struct community *) hash_release (comhash, *com);
+#ifdef SRX_COMM
+      zlog_debug("---- ret:%p com:%p \n", ret, *com);
+#endif
       assert (ret != NULL);
 
       community_free (*com);
       *com = NULL;
     }
+#ifdef SRX_COMM
+  if(*com)
+    zlog_debug("[comm_unintern] %p com->refcnt: %d %s \n" , *com, (*com)->refcnt, (*com)->str);
+#endif
 }
 
 /* Create new community attribute. */
@@ -355,6 +463,9 @@ community_parse (u_int32_t *pnt, u_short length)
   tmp.size = length / 4;
   tmp.val = pnt;
 
+#ifdef SRX_COMM
+  zlog_debug("[parse] length:%d pnt: %s \n", length, pnt);
+#endif
   new = community_uniq_sort (&tmp);
 
   return community_intern (new);
@@ -579,6 +690,70 @@ community_gettoken (const char *buf, enum community_token *token,
   return NULL;
 }
 
+#ifdef SRX_COMM
+/* Get value token from string. */
+const char *
+community_getvalue_from_str (const char *buf, enum community_token *token,
+    u_int32_t *val)
+{
+
+  const char *p = buf;
+
+  /* Skip white space. */
+  while (isspace ((int) *p))
+    p++;
+
+  /* Check the end of the line. */
+  if (*p == '\0')
+    return NULL;
+
+  /* Community value. */
+  if (isdigit ((int) *p))
+  {
+    int separator = 0;
+    int digit = 0;
+    u_int32_t community_low = 0;
+    u_int32_t community_high = 0;
+
+    while (isdigit ((int) *p) || *p == ':')
+    {
+      if (*p == ':')
+      {
+        if (separator)
+        {
+          *token = community_token_unknown;
+          return NULL;
+        }
+        else
+        {
+          separator = 1;
+          digit = 0;
+          community_high = community_low << 16;
+          community_low = 0;
+        }
+      }
+      else
+      {
+        digit = 1;
+        community_low *= 10;
+        community_low += (*p - '0');
+      }
+      p++;
+    }
+    if (! digit)
+    {
+      *token = community_token_unknown;
+      return NULL;
+    }
+    *val = community_high + community_low;
+    *token = community_token_val;
+    return p;
+  }
+}
+#endif
+
+
+
 /* convert string to community structure */
 struct community *
 community_str2com (const char *str)
diff --git a/quaggasrx/bgpd/bgp_community.h b/quaggasrx/bgpd/bgp_community.h
index df144a7..4b2637f 100644
--- a/quaggasrx/bgpd/bgp_community.h
+++ b/quaggasrx/bgpd/bgp_community.h
@@ -71,4 +71,8 @@ extern void community_del_val (struct community *, u_int32_t *);
 extern unsigned long community_count (void);
 extern struct hash *community_hash (void);
 
+#ifdef USE_SRX
+#define SRX_COMM
+#endif
+
 #endif /* _QUAGGA_BGP_COMMUNITY_H */
diff --git a/quaggasrx/bgpd/bgp_ecommunity.c b/quaggasrx/bgpd/bgp_ecommunity.c
index bc8f345..34160f4 100644
--- a/quaggasrx/bgpd/bgp_ecommunity.c
+++ b/quaggasrx/bgpd/bgp_ecommunity.c
@@ -40,6 +40,15 @@ ecommunity_new (void)
 					sizeof (struct ecommunity));
 }
 
+#ifdef SRX_COMM
+/* Return extended communities hash.  */
+struct hash *
+ecommunity_hash (void)
+{
+  return ecomhash;
+}
+#endif
+
 
 /* Allocate ecommunities.  */
 void
@@ -223,10 +232,18 @@ ecommunity_unintern (struct ecommunity **ecom)
     {
       /* Extended community must be in the hash.  */
       ret = (struct ecommunity *) hash_release (ecomhash, *ecom);
+#ifdef SRX_COMM
+      zlog_debug("--ee-- ret:%p ecom:%p \n", ret, *ecom);
+#endif
       assert (ret != NULL);
 
       ecommunity_free (ecom);
     }
+#ifdef SRX_COMM
+  if(*ecom)
+    zlog_debug(" --ee-- [%s] %p com->refcnt: %d str:%s \n" ,__func__,
+        *ecom, (*ecom)->refcnt, (*ecom)->str);
+#endif
 }
 
 /* Utinity function to make hash key.  */
diff --git a/quaggasrx/bgpd/bgp_open.c b/quaggasrx/bgpd/bgp_open.c
index 7bf3501..54ef991 100644
--- a/quaggasrx/bgpd/bgp_open.c
+++ b/quaggasrx/bgpd/bgp_open.c
@@ -500,6 +500,9 @@ bgp_capability_parse (struct peer *peer, size_t length, int *mp_capability,
           case CAPABILITY_CODE_RESTART:
           case CAPABILITY_CODE_AS4:
           case CAPABILITY_CODE_DYNAMIC:
+#ifdef USE_SRX
+          case CAPABILITY_CODE_BGPSEC:
+#endif
               /* Check length. */
               if (caphdr.length < cap_minsizes[caphdr.code])
                 {
@@ -569,6 +572,15 @@ bgp_capability_parse (struct peer *peer, size_t length, int *mp_capability,
               if (!bgp_capability_as4 (peer, &caphdr))
                 return -1;
               break;            
+#ifdef USE_SRX
+          case CAPABILITY_CODE_BGPSEC:
+              SET_FLAG (peer->cap, PEER_CAP_BGPSEC_ADV);
+              zlog_debug(" -------------------- BGPSEC section----------");
+              zlog_debug ("%s capability code: %d length:%d",
+                  peer->host, caphdr.code, caphdr.length);
+              // TODO: Do bgpsec work if there is
+              break;
+#endif
           default:
             if (caphdr.code > 128)
               {
@@ -763,6 +775,13 @@ bgp_open_option_parse (struct peer *peer, u_char length, int *mp_capability)
 	  ret = -1;
 	  break;
 	}
+#if 0
+      /* Notification is sending to neighbor : type 2/99 */
+      if(ret < 0 && ret == -2)
+        bgp_notify_send (peer,
+                         BGP_NOTIFY_OPEN_ERR,
+                         BGP_NOTIFY_OPEN_UNSUP_BGPSEC);
+#endif
 
       /* Parse error.  To accumulate all unsupported capability codes,
          bgp_capability_parse does not return -1 when encounter
@@ -1031,6 +1050,20 @@ bgp_open_capability (struct stream *s, struct peer *peer)
       stream_putw (s, peer->bgp->restart_time);
      }
 
+#ifdef USE_SRX
+  /* BGPSEC Capability */
+  if (CHECK_FLAG (peer->flags, PEER_FLAG_BGPSEC_CAPABILITY))
+  {
+    SET_FLAG (peer->cap, PEER_CAP_BGPSEC_ADV);
+    stream_putc (s, BGP_OPEN_OPT_CAP);
+    stream_putc (s, CAPABILITY_CODE_BGPSEC_LEN + 2);
+    stream_putc (s, CAPABILITY_CODE_BGPSEC);
+    stream_putc (s, CAPABILITY_CODE_BGPSEC_LEN);
+    stream_putw (s, 0xABEF); // test
+    stream_putw (s, 0xCDDA); // test
+  }
+#endif
+
   /* Total Opt Parm Len. */
   len = stream_get_endp (s) - cp - 1;
   stream_putc_at (s, cp, len);
diff --git a/quaggasrx/bgpd/bgp_open.h b/quaggasrx/bgpd/bgp_open.h
index 2b1382d..65912f9 100644
--- a/quaggasrx/bgpd/bgp_open.h
+++ b/quaggasrx/bgpd/bgp_open.h
@@ -53,6 +53,13 @@ struct capability_as4
   uint32_t as4;
 };
 
+#ifdef USE_SRX
+struct capability_bgpsec
+{
+  uint32_t bgpsec_data;
+};
+#endif
+
 struct graceful_restart_af
 {
   afi_t afi;
@@ -75,6 +82,9 @@ struct capability_gr
 #define CAPABILITY_CODE_DYNAMIC        66 /* Dynamic Capability */
 #define CAPABILITY_CODE_REFRESH_OLD   128 /* Route Refresh Capability(cisco) */
 #define CAPABILITY_CODE_ORF_OLD       130 /* Cooperative Route Filtering Capability(cisco) */
+#ifdef USE_SRX
+#define CAPABILITY_CODE_BGPSEC         99 /* BGPSEC capability code in accordance with BRID */
+#endif /* USE_SRX */
 
 /* Capability Length */
 #define CAPABILITY_CODE_MP_LEN          4
@@ -82,6 +92,9 @@ struct capability_gr
 #define CAPABILITY_CODE_DYNAMIC_LEN     0
 #define CAPABILITY_CODE_RESTART_LEN     2 /* Receiving only case */
 #define CAPABILITY_CODE_AS4_LEN         4
+#ifdef USE_SRX
+#define CAPABILITY_CODE_BGPSEC_LEN      4
+#endif /* USE_SRX */
 
 /* Cooperative Route Filtering Capability.  */
 
diff --git a/quaggasrx/bgpd/bgp_packet.c b/quaggasrx/bgpd/bgp_packet.c
index f8a9c40..b2d359c 100644
--- a/quaggasrx/bgpd/bgp_packet.c
+++ b/quaggasrx/bgpd/bgp_packet.c
@@ -155,6 +155,11 @@ bgp_update_packet (struct peer *peer, afi_t afi, safi_t safi)
 
   adv = FIFO_HEAD (&peer->sync[afi][safi]->update);
 
+#ifdef __SRX_COMM
+  if (adv) printf(" -------- peer:%p adv : %p\n", peer, adv);
+  else printf(" adv --------- not exist \n");
+#endif
+
   while (adv)
     {
       assert (adv->rn);
@@ -163,6 +168,19 @@ bgp_update_packet (struct peer *peer, afi_t afi, safi_t safi)
       if (adv->binfo)
         binfo = adv->binfo;
 
+#ifdef SRX_COMM
+    printf(" ---[%s]----- adjacent:%p adj_peer:%p  adj_attr:%p \n",
+        __FUNCTION__,  adj, adj->peer, adj->attr);
+    printf(" adv->baa->attr:%p \n", adv->baa->attr );
+    if(adv->baa->attr->community) printf(" comm: %s \n", adv->baa->attr->community->str);
+    printf(" peer->af_flags:%x attr->flags: %x\n", peer->af_flags[AFI_IP][SAFI_UNICAST], adv->baa->attr->flag);
+
+    if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY))
+      printf("peer af flags is true\n");
+    if (adv->baa->attr->flag & ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES))
+      printf("attr flags is true as well\n");
+
+#endif
       /* When remaining space can't include NLRI and it's length.  */
       if (STREAM_REMAIN (s) <= BGP_NLRI_LENGTH + PSIZE (rn->p.prefixlen))
 	break;
@@ -187,6 +205,77 @@ bgp_update_packet (struct peer *peer, afi_t afi, safi_t safi)
 	  stream_putw (s, 0);
 	  pos = stream_get_endp (s);
 	  stream_putw (s, 0);
+#ifdef __SRX_COMM
+          //TODO: here make community values here
+          //
+          /* community new */
+          struct community *com_tmp = NULL;
+          com_tmp = (struct community *) XCALLOC (MTYPE_COMMUNITY,
+              sizeof (struct community));
+
+          /* Community token enum. */
+          enum community_token
+          {
+            community_token_val,
+            community_token_no_export,
+            community_token_no_advertise,
+            community_token_local_as,
+            community_token_unknown
+          };
+          enum community_token token = community_token_unknown;
+          u_int32_t val = 0;
+
+          /* community add value */
+          community_getvalue_from_str ("100:200", &token, &val);
+          com_tmp->size++;
+          if (com_tmp->val)
+            com_tmp->val = XREALLOC (MTYPE_COMMUNITY_VAL, com_tmp->val, com_length (com_tmp));
+          else
+            com_tmp->val = XMALLOC (MTYPE_COMMUNITY_VAL, com_length (com_tmp));
+          val = htonl (val);
+          memcpy (com_lastval (com_tmp), &val, sizeof (u_int32_t));
+
+          /* community add str */
+          com_tmp->str = community_com2str_mod (com_tmp);
+
+          /* test print */
+          printf ("(tmp com_:%p)  str: %s  val:0x%x \n", com_tmp, com_tmp->str, *com_tmp->val );
+
+#if 0
+          /* re-create a new backet for registering into comm_hash */
+          void * hash_alloc_intern (void *arg);
+          void *ret;
+          ret = hash_get (community_hash (), com_tmp, hash_alloc_intern);
+          struct community *com_old = adv->baa->attr->community;
+
+          if(ret)
+            adv->baa->attr->community = (struct community*) ret;
+#endif
+
+          struct hash *attr_hash = attribute_hash();
+          struct attr *attr_tmp = adv->baa->attr;
+          struct attr attr_old;
+          memset (&attr_old, 0x0, sizeof(struct attr));
+
+          memcpy(&attr_old, attr_tmp, sizeof(struct attr));
+          attr_old.community = com_tmp;
+
+          /* release attr hash and hash-get again */
+          bgp_attr_unintern(&adv->baa->attr);
+          //hash_release(attr_hash, attr_tmp);
+
+          /* RELEASE & GET ATTR-HASH PART2 : get-hash attribute hash */
+          extern void * bgp_attr_hash_alloc_mod (void *p);
+          struct attr *attr_ret;
+          attr_ret = (struct attr *) hash_get(attr_hash, &attr_old, bgp_attr_hash_alloc_mod);
+
+          if(attr_ret)
+          {
+            adv->baa->attr = attr_ret;
+            bgp_attr_intern(adv->baa->attr);
+          }
+
+#endif
 	  total_attr_len = bgp_packet_attribute (NULL, peer, s,
 	                                         adv->baa->attr,
 	                                         &rn->p, afi, safi,
@@ -194,6 +283,15 @@ bgp_update_packet (struct peer *peer, afi_t afi, safi_t safi)
 	  stream_putw_at (s, pos, total_attr_len);
 	}
 
+#ifdef SRX_COMM
+      printf(" total length:%d\n", total_attr_len);
+      //char tmpbuf[1024];
+      //memcpy(tmpbuf, s->data[pos+2], total_attr_len );
+      unsigned long tpos= pos;
+      for(int ti=0; ti < total_attr_len+2; ti++)
+        printf(" %02x", stream_getc_from(s, tpos++));
+      printf("\n");
+#endif
       if (afi == AFI_IP && safi == SAFI_UNICAST)
 	stream_put_prefix (s, &rn->p);
 
@@ -210,6 +308,9 @@ bgp_update_packet (struct peer *peer, afi_t afi, safi_t safi)
       /* Synchnorize attribute.  */
       if (adj->attr)
       {
+#ifdef SRX_COMM
+        printf(" why here calling 'bgp_attr-unintern(*) attr:%p'\n", adj->attr);
+#endif
         bgp_attr_unintern (&adj->attr);
       }
       else
@@ -225,6 +326,9 @@ bgp_update_packet (struct peer *peer, afi_t afi, safi_t safi)
 
   if (! stream_empty (s))
     {
+#ifdef SRX_COMM
+      printf(" ----- here duplicate packet and add to peer->out and SEND update \n");
+#endif
       bgp_packet_set_size (s);
       packet = stream_dup (s);
       bgp_packet_add (peer, packet);
@@ -542,6 +646,9 @@ bgp_write_packet (struct peer *peer)
 	adv = FIFO_HEAD (&peer->sync[afi][safi]->update);
 	if (adv)
 	  {
+#ifdef SRX_COMM
+            printf("-----update packet test, peer:%p adv:%p \n", peer, adv);
+#endif
             if (adv->binfo && adv->binfo->uptime < peer->synctime)
 	      {
 		if (CHECK_FLAG (adv->binfo->peer->cap, PEER_CAP_RESTART_RCV)
@@ -709,6 +816,113 @@ bgp_write (struct thread *thread)
 }
 
 
+#ifdef SRX_COMM
+/* Write packet to the peer. */
+int
+bgp_write_srx (struct thread *thread)
+{
+  struct peer *peer;
+  u_char type;
+  struct stream *s;
+  int num;
+  unsigned int count = 0;
+
+  /* Yes first of all get peer pointer. */
+  peer = THREAD_ARG (thread);
+  peer->t_write = NULL;
+
+  /* For non-blocking IO check. */
+  if (peer->status == Connect)
+    {
+      bgp_connect_check (peer);
+      return 0;
+    }
+
+  s = bgp_write_packet (peer);
+  if (!s)
+    return 0;	/* nothing to send */
+
+  sockopt_cork (peer->fd, 1);
+
+  /* Nonblocking write until TCP output buffer is full.  */
+  do
+    {
+      int writenum;
+
+      /* Number of bytes to be sent.  */
+      writenum = stream_get_endp (s) - stream_get_getp (s);
+
+      /* Call write() system call.  */
+      num = write (peer->fd, STREAM_PNT (s), writenum);
+      if (num < 0)
+	{
+	  /* write failed either retry needed or error */
+	  if (ERRNO_IO_RETRY(errno))
+		break;
+
+          BGP_EVENT_ADD (peer, TCP_fatal_error);
+	  return 0;
+	}
+
+      if (num != writenum)
+	{
+	  /* Partial write */
+	  stream_forward_getp (s, num);
+	  break;
+	}
+
+      /* Retrieve BGP packet type. */
+      stream_set_getp (s, BGP_MARKER_SIZE + 2);
+      type = stream_getc (s);
+
+      switch (type)
+	{
+	case BGP_MSG_OPEN:
+	  peer->open_out++;
+	  break;
+	case BGP_MSG_UPDATE:
+	  peer->update_out++;
+	  break;
+	case BGP_MSG_NOTIFY:
+	  peer->notify_out++;
+	  /* Double start timer. */
+	  peer->v_start *= 2;
+
+	  /* Overflow check. */
+	  if (peer->v_start >= (60 * 2))
+	    peer->v_start = (60 * 2);
+
+	  /* Flush any existing events */
+	  BGP_EVENT_ADD (peer, BGP_Stop);
+	  goto done;
+
+	case BGP_MSG_KEEPALIVE:
+	  peer->keepalive_out++;
+	  break;
+	case BGP_MSG_ROUTE_REFRESH_NEW:
+	case BGP_MSG_ROUTE_REFRESH_OLD:
+	  peer->refresh_out++;
+	  break;
+	case BGP_MSG_CAPABILITY:
+	  peer->dynamic_cap_out++;
+	  break;
+	}
+
+      /* OK we send packet so delete it. */
+      bgp_packet_delete (peer);
+    }
+  while (++count < BGP_WRITE_PACKET_MAX &&
+	 (s = bgp_write_packet (peer)) != NULL);
+
+  if (bgp_write_proceed (peer))
+    BGP_WRITE_ON (peer->t_write, bgp_write_srx, peer->fd);
+
+ done:
+  sockopt_cork (peer->fd, 0);
+  return 0;
+}
+#endif
+
 /* This is only for sending NOTIFICATION message to neighbor. */
 static int
 bgp_write_notify (struct peer *peer)
@@ -2441,10 +2655,6 @@ bgp_read (struct thread *thread)
   if (peer->packet_size == 0)
     peer->packet_size = BGP_HEADER_SIZE;
 
-#ifdef USE_SRX
-  BGP_READ_ON (peer->t_read, bgp_read2, peer->fd);
-#endif /* USE_SRX */
-
   if (stream_get_endp (peer->ibuf) < BGP_HEADER_SIZE)
     {
       ret = bgp_read_packet (peer);
diff --git a/quaggasrx/bgpd/bgp_packet.h b/quaggasrx/bgpd/bgp_packet.h
index a24e024..67b4a17 100644
--- a/quaggasrx/bgpd/bgp_packet.h
+++ b/quaggasrx/bgpd/bgp_packet.h
@@ -43,6 +43,9 @@ extern int bgp_read (struct thread *);
 extern int bgp_read2 (struct thread *);
 #endif /* USE_SRX */
 extern int bgp_write (struct thread *);
+#ifdef SRX_COMM
+extern int bgp_write_srx (struct thread *);
+#endif
 
 extern void bgp_keepalive_send (struct peer *);
 extern void bgp_open_send (struct peer *);
diff --git a/quaggasrx/bgpd/bgp_route.c b/quaggasrx/bgpd/bgp_route.c
index 249612a..7167934 100644
--- a/quaggasrx/bgpd/bgp_route.c
+++ b/quaggasrx/bgpd/bgp_route.c
@@ -448,7 +448,15 @@ static void
 bgp_info_free (struct bgp_info *binfo)
 {
   if (binfo->attr)
+#ifdef SRX_COMM
+  {
+    zlog_debug("[%s] --> binfo:%p binfo->attr:%p comm:%p\n",
+        __FUNCTION__, binfo, binfo->attr, binfo->attr->community);
     bgp_attr_unintern (&binfo->attr);
+  }
+#else
+    bgp_attr_unintern (&binfo->attr);
+#endif
 
   bgp_info_extra_free (&binfo->extra);
   bgp_info_mpath_free (&binfo->mpath);
@@ -884,6 +892,164 @@ int checkEcomSRxValid(struct attr* attr)
   return ret;
 }
 
+#ifdef SRX_COMM
+/**
+ * @brief
+ *
+ * @param attr
+ * @param comm
+ * @param ecomm
+ *
+ * @return
+ */
+struct attr *
+regenAttribute(struct attr *attr, struct community *comm, struct ecommunity *ecomm )
+{
+
+  struct attr *new_attr;
+
+  /*  part 1 */
+
+  struct community *com_tmp = NULL;
+  com_tmp = (struct community *) XCALLOC (MTYPE_COMMUNITY,
+      sizeof (struct community));
+
+  /* Community token enum. */
+  enum community_token {
+    community_token_val,
+    community_token_no_export,
+    community_token_no_advertise,
+    community_token_local_as,
+    community_token_unknown } token = community_token_unknown;
+  u_int32_t val = 0;
+
+  /* community add value */
+  // TODO: Later, comm string should be replaced with the argument
+  //
+  community_getvalue_from_str ("100:200", &token, &val);
+  com_tmp->size++;
+  if (com_tmp->val)
+    com_tmp->val = XREALLOC (MTYPE_COMMUNITY_VAL, com_tmp->val, com_length (com_tmp));
+  else
+    com_tmp->val = XMALLOC (MTYPE_COMMUNITY_VAL, com_length (com_tmp));
+  val = htonl (val);
+  memcpy (com_lastval (com_tmp), &val, sizeof (u_int32_t));
+
+  /* community add str */
+  com_tmp->str = community_com2str_mod (com_tmp);
+
+  /* test print */
+  printf ("(tmp com_:%p) str: %s val:0x%x cnt:%d\n",
+      com_tmp, com_tmp->str, *com_tmp->val, com_tmp->refcnt );
+
+
+  /*  part 2 */
+
+  /* attribute value add */
+  struct hash *attr_hash = attribute_hash();
+  struct attr attr_old;
+  struct attr attr_tmp;
+  struct attr_extra extra;
+
+
+  memcpy(&attr_old, attr, sizeof(struct attr));
+
+  /*
+  attr_tmp.community = com_tmp;
+  attr_tmp.flag |= ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES);
+  attr_tmp.flag |= ATTR_FLAG_BIT (BGP_ATTR_SRX_COMMUNITY);
+  attr_tmp.local_pref = peer->bgp->default_local_pref;
+  memcpy (&attr_tmp.nexthop, &peer->nexthop.v4, IPV4_MAX_BYTELEN);
+  */
+
+  /* 2. here make extended community values here */
+
+  /* extended community intern */
+  struct ecommunity *new_ecom;
+  struct ecommunity *ecom = (struct ecommunity *) XCALLOC (MTYPE_ECOMMUNITY,
+					sizeof (struct ecommunity));
+  //attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES);
+  memset(&extra, 0x0, sizeof(struct attr_extra));
+  //SET_FLAG (peer->af_flags[AFI_IP][SAFI_UNICAST], PEER_FLAG_SEND_EXT_COMMUNITY);
+
+  // TODO: Later, extended comm string should be replaced with the argument
+  //
+  ecom = ecommunity_str2com ("999:2", ECOMMUNITY_ROUTE_TARGET, 0);
+  if (ecom)
+  {
+    new_ecom = ecommunity_intern (ecom);
+    //ecom->str = ecommunity_ecom2str (ecom, ECOMMUNITY_FORMAT_DISPLAY);
+    printf ("(ecom_:%p) str: %s val:0x%x refcnt:%d\n",
+      new_ecom, new_ecom->str, *new_ecom->val, new_ecom->refcnt );
+  }
+
+  extra.ecommunity = new_ecom;
+  //attr.extra = &extra;
+
+
+
+  return new_attr;
+}
+
+/**
+ * @brief   Utility function
+ *
+ * @return  new community pointer
+ */
+struct community * community_regen()
+{
+  struct community *com_tmp = NULL;
+  com_tmp = (struct community *) XCALLOC (MTYPE_COMMUNITY,
+      sizeof (struct community));
+
+  /* Community token enum. */
+  enum community_token {
+    community_token_val,
+    community_token_no_export,
+    community_token_no_advertise,
+    community_token_local_as,
+    community_token_unknown } token = community_token_unknown;
+  u_int32_t val = 0;
+
+  /* community add value */
+  // TODO: Later, comm string should be replaced with the argument
+  //
+  community_getvalue_from_str ("800:900", &token, &val);
+  com_tmp->size++;
+  if (com_tmp->val)
+    com_tmp->val = XREALLOC (MTYPE_COMMUNITY_VAL, com_tmp->val, com_length (com_tmp));
+  else
+    com_tmp->val = XMALLOC (MTYPE_COMMUNITY_VAL, com_length (com_tmp));
+  val = htonl (val);
+  memcpy (com_lastval (com_tmp), &val, sizeof (u_int32_t));
+
+  /* community add str */
+  com_tmp->str = community_com2str_mod (com_tmp);
+
+  /* test print */
+  printf ("(tmp com_:%p) str: %s val:0x%x cnt:%d\n",
+      com_tmp, com_tmp->str, *com_tmp->val, com_tmp->refcnt );
+  return com_tmp;
+}
+
+
+/**
+ * @brief
+ *
+ * @param as_old
+ */
+struct aspath *
+aspath_regen(struct aspath *as_old)
+{
+
+  struct aspath *as;
+
+
+
+  return as;
+}
+#endif // end of SRX_COMM
+
 /**
  * Modifies the BGP update information according to the SRX settings.
  * This will be done using the bgp_info data structure.
@@ -916,6 +1082,198 @@ void bgp_info_set_validation_result (struct bgp_info *info,
     {
       info->val_res_BGPSEC = roaResult;
     }
+#ifdef SRX_COMM
+    printf("info:%p info-peer:%s attr:%p\n", info, info->peer->host, info->attr );
+
+    static int stRefCnt=0;
+
+    struct community com_old;
+    if(info->attr->community)
+    {
+      struct community *pcom_old = info->attr->community;
+      //printf("community:%s\n", info->attr->community->str);
+      memcpy( &com_old, info->attr->community, sizeof(struct community));
+    }
+
+    if (info->attr->extra)
+      if (info->attr->extra->ecommunity)
+      {
+        stRefCnt++;
+        struct attr_extra *attre = info->attr->extra;
+        struct ecommunity old_ecom = *info->attr->extra->ecommunity;
+
+        printf("-1-[%s] attr:%p(%d) comm:%p(%d) ext:%p \n", __func__,
+            info->attr, info->attr->refcnt, info->attr->community,
+            info->attr->community->refcnt, info->attr->extra);
+        printf ("-1-(ecom_:%p) str: %s val:0x%x refcnt:%d\n",
+            info->attr->extra->ecommunity, info->attr->extra->ecommunity->str,
+            *info->attr->extra->ecommunity->val, info->attr->extra->ecommunity->refcnt );
+
+#define BASIC_TEST
+#ifdef BASIC_TEST
+        struct attr attr_tmp, attr_old;
+        struct attr new_attr;
+        struct attr_extra new_extra;
+        struct attr *attr_new;
+
+        attr_old = *info->attr;
+
+        /* making a new attr  */
+        memset (&attr_tmp, 0, sizeof (struct attr));
+        attr_tmp.community = community_regen();
+        //attr_tmp.aspath = attr_old.aspath; // maybe no good because aspath will be wiped out when attr-unintern
+        attr_tmp.nexthop = attr_old.nexthop;
+        attr_tmp.local_pref = attr_old.local_pref;
+        attr_tmp.med = attr_old.med;
+        attr_tmp.aspath = aspath_regen(&attr_tmp);
+
+        /* exchange */
+        new_attr.extra = &new_extra;
+        bgp_attr_dup (&new_attr, &attr_tmp);
+
+        /* intern process */
+        attr_new = bgp_attr_intern (&new_attr);
+        info->attr = attr_new;
+
+        /// ------------> should the previous attr(info->attr) be uninterned here??
+
+        //info->attr = bgp_attr_intern(&attr_old);
+
+        struct ecommunity *ecom_prt = info->attr->extra->ecommunity;
+        printf("-3- [%s]  attr:%p(%d) comm:%p(%d) ext:%p \n", __func__, \
+            info->attr, info->attr->refcnt, info->attr->community,\
+            info->attr->community? info->attr->community->refcnt:NULL, info->attr->extra);
+        printf ("-3- (ecom_:%p) str: %s val:0x%x refcnt:%d\n",\
+            info->attr->extra->ecommunity, ecom_prt?info->attr->extra->ecommunity->str:NULL, \
+            ecom_prt?*info->attr->extra->ecommunity->val:NULL, ecom_prt?info->attr->extra->ecommunity->refcnt:NULL );
+#endif
+
+
+#define DO_EXCHANGE false
+#if DO_EXCHANGE
+        // TODO: if val_res_ROA or BGPSEC == validated, --> new ext comm values
+        //
+        /* Assuming Validated Valueds need a new ext comm */
+        if(info->attr->extra->ecommunity->refcnt == 1)
+        {
+          //hash_release (ecommunity_hash(), info->attr->extra->ecommunity);
+          hash_release (community_hash (), info->attr->community);  // release the backet itself
+
+#if 0
+          /* community new */
+          struct community *com_tmp = NULL;
+          com_tmp = (struct community *) XCALLOC (MTYPE_COMMUNITY,
+              sizeof (struct community));
+
+          com_tmp->refcnt = com_old.refcnt = stRefCnt;
+          com_tmp->size = com_old.size;
+          com_tmp->str = community_com2str_mod (&com_old);
+          com_tmp->val = com_old.val;
+          //memcpy (com_lastval (com_tmp), com_old.val, sizeof (u_int32_t));
+          printf(" [%s] com_old.val:0x%x str:%s\n", __func__,
+              *com_tmp->val, com_tmp->str);
+#endif
+
+          info->attr->community->refcnt = com_old.refcnt = stRefCnt;
+          info->attr->community->size = com_old.size;
+          info->attr->community->str = community_com2str_mod (&com_old);
+          info->attr->community->val = com_old.val;
+
+          void * hash_alloc_intern (void *arg);
+          struct community *com_ret =
+            hash_get (community_hash (), info->attr->community, hash_alloc_intern);
+#if 0
+          if(com_ret)
+          {
+            com_ret->refcnt = stRefCnt;
+            info->attr->community = com_ret;
+          }
+#endif
+
+          struct hash *attr_hash = attribute_hash();
+          struct attr attr_old;
+          memcpy(&attr_old, info->attr, sizeof(struct attr));
+          hash_release(attr_hash, info->attr);
+
+          attr_old.extra = attre;
+
+#define NEW_ECOM false   // using a newly created ecomm object
+#if NEW_ECOM
+          struct ecommunity *new_ecom=NULL;
+          struct ecommunity *ecom = (struct ecommunity *) XCALLOC (MTYPE_ECOMMUNITY,
+              sizeof (struct ecommunity));
+          ecom = ecommunity_str2com ("222:2", ECOMMUNITY_ROUTE_TARGET, 0);
+          if (ecom)
+          {
+            new_ecom = ecommunity_intern (ecom);
+            new_ecom->refcnt = old_ecom.refcnt = stRefCnt;
+            //new_ecom->size = old_ecom.size;
+            printf("newly created 'new_ecom':%p\n", new_ecom);
+          }
+          attr_old.extra->ecommunity = new_ecom;
+#else
+          old_ecom.refcnt = stRefCnt;
+          *attr_old.extra->ecommunity = old_ecom;
+#endif // NEW_ECOM
+
+          attr_old.refcnt = stRefCnt;
+          memcpy(info->attr, &attr_old, sizeof(struct attr));
+          extern void * bgp_attr_hash_alloc_mod (void *p);
+          struct attr *attr_ret=NULL;
+
+#define DO_OR_NOT true
+#if DO_OR_NOT
+          //attr_ret = hash_get(attr_hash, info->attr, bgp_attr_hash_alloc_mod);
+          info->attr = bgp_attr_intern(&attr_old);
+#endif
+
+          printf("-2- [%s] attr_ret:%p attr:%p(%d) comm:%p(%d) ext:%p \n", __func__,
+              attr_ret, info->attr, info->attr->refcnt, info->attr->community,
+              info->attr->community->refcnt, info->attr->extra);
+          printf ("-2- (ecom_:%p) str: %s val:0x%x refcnt:%d\n",
+              info->attr->extra->ecommunity, info->attr->extra->ecommunity->str,
+              *info->attr->extra->ecommunity->val, info->attr->extra->ecommunity->refcnt );
+
+          stRefCnt =0;
+        }
+        else
+        {
+          bgp_attr_unintern(&info->attr);
+          //ecommunity_unintern (&info->attr->extra->ecommunity);
+        }
+#endif // DO_EXCHANGE
+
+        // TODO: below block should be enabled
+#if 0
+        /* Extended Community Unintern Operation */
+        struct ecommunity *new_ecom;
+        struct ecommunity *ecom = (struct ecommunity *) XCALLOC (MTYPE_ECOMMUNITY,
+            sizeof (struct ecommunity));
+        ecom = ecommunity_str2com ("777:3", ECOMMUNITY_ROUTE_TARGET, 0);
+
+        if (ecom)
+        {
+          //bgp_attr_unintern(&info->attr);
+          new_ecom = ecommunity_intern (ecom);
+          ecommunity_unintern (&info->attr->extra->ecommunity);
+
+          if(!info->attr->extra->ecommunity)
+            info->attr->extra->ecommunity = new_ecom;
+
+          //ecom->str = ecommunity_ecom2str (ecom, ECOMMUNITY_FORMAT_DISPLAY);
+          printf ("(ecom_:%p) str: %s val:0x%x refcnt:%d\n",
+              new_ecom, new_ecom->str, *new_ecom->val, new_ecom->refcnt );
+        }
+#endif
+
+      }
+      else // in case 'extra' field is not exist
+      {
+        // TODO: attr unintern - intern code is necessary
+
+      }
+
+#endif // SRX_COMM
 
     // Check if it is fully valid and if not decide if the update has to be
     // ignored
@@ -3102,7 +3460,14 @@ bgp_update_main (struct peer *peer, struct prefix *p, struct attr *attr,
     }
 
   attr_new = bgp_attr_intern (&new_attr);
+#ifdef SRX_COMM
+  zlog_debug("-xoxoxo--- [%s] attr:%p  peer[%p]->host:%s\n", __func__, \
+      attr_new, peer, peer?peer->host:NULL);
 
+  if (ri)
+    zlog_debug("-xoxoxo--- [%s] ri:%p  ri->peer[%p]->host:%s\n", __func__,
+        ri, ri->peer, ri->peer->host);
+#endif
   /* If the update is implicit withdraw. */
   if (ri)
     {
@@ -3193,6 +3558,10 @@ bgp_update_main (struct peer *peer, struct prefix *p, struct attr *attr,
 	    bgp_damp_withdraw (ri, rn, afi, safi, 1);
 	}
 
+#ifdef SRX_COMM
+      zlog_debug("xxxxxx out of while, HERE stale attr will be uninterned \n \
+          and substituted ri-attr:%p --> attr-new:%p xxxxx\n", ri->attr, attr_new );
+#endif
       /* Update to new attribute.  */
       bgp_attr_unintern (&ri->attr);
       ri->attr = attr_new;
@@ -3274,6 +3643,11 @@ bgp_update_main (struct peer *peer, struct prefix *p, struct attr *attr,
       defRes->result.roaResult    = bgp->srx_default_roaVal;
       defRes->result.bgpsecResult = bgp->srx_default_bgpsecVal;
 
+#ifdef SRX_COMM
+      // TODO: extended community info need to be added
+      if(ri)
+        zlog_debug("AAAA [%s] ri-attr:%p  host:%s\n\n", __func__, ri->attr, (ri->peer)? ri->peer->host: NULL);
+#endif
       verify_update (bgp, ri, defRes, true);
       free(defRes);
 #endif /* USE_SRX */
@@ -3344,6 +3718,12 @@ bgp_update_main (struct peer *peer, struct prefix *p, struct attr *attr,
   defRes->result.roaResult    = bgp->srx_default_roaVal;
   defRes->result.bgpsecResult = bgp->srx_default_bgpsecVal;
 
+#ifdef SRX_COMM
+  // TODO: extended community info need to be added
+  if(ri)
+    zlog_debug("BBBB [%s] ri-attr:%p  host:%s\n", __func__,
+        new->attr, (new->peer)? new->peer->host: NULL);
+#endif
   verify_update (bgp, new, defRes, true);
   free(defRes);
 #endif /* USE_SRX */
@@ -4489,6 +4869,9 @@ bgp_static_update_main (struct bgp *bgp, struct prefix *p,
   else
   {
     attr_new = bgp_attr_intern (&attr);
+#ifdef SRX_COMM
+    zlog_debug(" [%s] &attr:%p attr_new:%p \n", __func__, &attr, attr_new );
+#endif
   }
 
   for (ri = rn->info; ri; ri = ri->next)
diff --git a/quaggasrx/bgpd/bgp_routemap.c b/quaggasrx/bgpd/bgp_routemap.c
index 8ed0d15..cc2cae8 100644
--- a/quaggasrx/bgpd/bgp_routemap.c
+++ b/quaggasrx/bgpd/bgp_routemap.c
@@ -3513,6 +3513,7 @@ DEFUN (set_ecommunity_bgpsec,
   ret = bgp_route_set_add (vty, vty->index, "extcommunity bgpsec", str);
   XFREE (MTYPE_TMP, str);
 
+  //bgp_flag_set (bgp, PEER_FLAG_BGPSEC_CAPABILITY);
   return ret;
 }
 
@@ -3524,6 +3525,7 @@ DEFUN (no_set_ecommunity_bgpsec,
        "BGP extended community attribute\n"
        "BGPSEC extended community\n")
 {
+  //bgp_flag_unset (bgp, PEER_FLAG_BGPSEC_CAPABILITY);
   return bgp_route_set_delete (vty, vty->index, "extcommunity bgpsec", NULL);
 }
 #endif
diff --git a/quaggasrx/bgpd/bgp_vty.c b/quaggasrx/bgpd/bgp_vty.c
index 491895c..44efbe6 100644
--- a/quaggasrx/bgpd/bgp_vty.c
+++ b/quaggasrx/bgpd/bgp_vty.c
@@ -2578,6 +2578,31 @@ DEFUN (no_neighbor_dont_capability_negotiate,
   return peer_flag_unset_vty (vty, argv[0], PEER_FLAG_DONT_CAPABILITY);
 }
 
+#ifdef USE_SRX
+/* bgpsec neighbor capability */
+DEFUN (neighbor_capability_bgpsec,
+       neighbor_capability_bgpsec_cmd,
+       NEIGHBOR_CMD2 "bgpsec",
+       NEIGHBOR_STR
+       NEIGHBOR_ADDR_STR2
+       "bgpsec capability to the peer\n")
+{
+  return peer_flag_set_vty(vty, argv[0], PEER_FLAG_BGPSEC_CAPABILITY);
+}
+
+DEFUN (no_neighbor_capability_bgpsec,
+       no_neighbor_capability_bgpsec_cmd,
+       NO_NEIGHBOR_CMD2 "bgpsec",
+       NO_STR
+       NEIGHBOR_STR
+       NEIGHBOR_ADDR_STR2
+       "bgpsec capability to the peer\n")
+{
+  return peer_flag_unset_vty(vty, argv[0], PEER_FLAG_BGPSEC_CAPABILITY);
+}
+#endif /* USE_SRX */
+
+
 static int
 peer_af_flag_modify_vty (struct vty *vty, const char *peer_str, afi_t afi,
 			 safi_t safi, u_int32_t flag, int set)
@@ -8807,10 +8832,160 @@ community_show_all_iterator (struct hash_backet *backet, struct vty *vty)
   struct community *com;
 
   com = (struct community *) backet->data;
+#ifdef SRX_COMM
+  vty_out (vty, "[backet:%p][com:%p] (%ld) %s%s", backet, com, com->refcnt,
+      community_str (com), VTY_NEWLINE);
+#else
   vty_out (vty, "[%p] (%ld) %s%s", backet, com->refcnt,
       community_str (com), VTY_NEWLINE);
+#endif
 }
 
+#ifdef SRX_COMM
+static void
+community_show_all_iterator_mod (struct hash_backet *backet, struct vty *vty, int argc, const char**argv)
+{
+  struct community *com;
+  struct community old;
+  struct community *testcom;
+  struct community *find;
+  u_int32_t old_val = 0;
+  void *ret;
+
+  /* debugging info */
+  vty_out(vty, "argv[0]:%s argv[1]:%s %s",argv[0], argv[1], VTY_NEWLINE);
+
+  /*  */
+  com = (struct community *) backet->data;
+  if (strcmp(community_str(com),argv[0]) ==0)
+  {
+    memcpy( &old, com, sizeof(struct community));
+    old_val = *old.val;
+    vty_out(vty, "FOUND in backet%p, com: %p %s",backet, com, VTY_NEWLINE);
+    vty_out(vty, "val: %08x %s", *com->val, VTY_NEWLINE);
+    vty_out(vty, "str: %s %s", community_str(com), VTY_NEWLINE);
+    vty_out(vty, "size: %d %s", com->size, VTY_NEWLINE);
+    vty_out(vty, "old val: %x str: %s %s", *old.val, community_str(&old), VTY_NEWLINE);
+
+#if 1// RELEASE & GET ATTR-HASH PART1 : trying to release attribute hash
+
+    int retAttr=0;
+    struct hash *attr_hash = attribute_hash();
+    vty_out(vty, "hash-size:%d com:%p %s", attr_hash->size, com, VTY_NEWLINE);
+
+    attr_show_all(vty);
+    struct attr *attr = NULL;
+    struct attr attr_old;
+
+    /* find attr which contains the community pointer */
+    retAttr = find_attr (&attr, (void*)com);
+    if(retAttr)
+    {
+      memcpy(&attr_old, attr, sizeof(struct attr));
+      vty_out(vty, "<Match found> attr:%p attr-community: %p attr-refcnt:%d  %s", \
+          attr, attr->community, attr->refcnt, VTY_NEWLINE);
+    }
+
+    /* release attr hash and hash-get again */
+    hash_release(attr_hash, attr);
+
+#endif
+
+    if(argv[1] != NULL)
+    {
+      vty_out(vty, "com->refcnt: %d %s", com->refcnt, VTY_NEWLINE);
+      hash_release(community_hash (), com);  // release the backet itself
+
+#if 1
+      /* community new */
+      struct community *com_tmp = NULL;
+      com_tmp = (struct community *) XCALLOC (MTYPE_COMMUNITY,
+          sizeof (struct community));
+      /* Community token enum. */
+      enum community_token
+      {
+        community_token_val,
+        community_token_no_export,
+        community_token_no_advertise,
+        community_token_local_as,
+        community_token_unknown
+      };
+      enum community_token token = community_token_unknown;
+      u_int32_t val = 0;
+
+      /* community add value */
+      community_getvalue_from_str (argv[1], &token, &val);
+
+      com_tmp->size++;
+      if (com_tmp->val)
+        com_tmp->val = XREALLOC (MTYPE_COMMUNITY_VAL, com_tmp->val, com_length (com_tmp));
+      else
+        com_tmp->val = XMALLOC (MTYPE_COMMUNITY_VAL, com_length (com_tmp));
+      val = htonl (val);
+      memcpy (com_lastval (com_tmp), &val, sizeof (u_int32_t));
+
+      /* community add str */
+      com_tmp->str = community_com2str_mod (com_tmp);
+
+      /* test print */
+      vty_out (vty, "(tmp com_)  str: %s  val:0x%x %s ", com_tmp->str, *com_tmp->val, VTY_NEWLINE);
+
+      /* community free */
+      community_free(com_tmp);
+#endif
+
+      com->refcnt = old.refcnt;
+      com->size = old.size;
+      //*com->val = 0x5802bc02;
+      //*com->val = 0xc8009001;
+      memcpy (com_lastval (com), &val, sizeof (u_int32_t));
+      com->str = community_com2str_mod (com);
+
+      /* re-create a new backet for registering into comm_hash */
+      ret = hash_get (community_hash (), com, hash_alloc_intern);
+
+      vty_out (vty, "new> (com)  str: %s  val:0x%x  ret:%p %s ", \
+          com->str, *com->val, ret, VTY_NEWLINE);
+
+      //
+      //TODO: HERE doing SRx job
+      //
+      vty_out (vty, "---- HERE Do SRx Community string job ----%s ", VTY_NEWLINE);
+
+
+#if 1 // RELEASE & GET ATTR-HASH PART2 : get-hash attribute hash
+      extern void * bgp_attr_hash_alloc_mod (void *p);
+
+      struct attr *attr_ret;
+      memcpy(attr, &attr_old, sizeof(struct attr));
+      attr_ret = (struct attr *) hash_get(attr_hash, attr, bgp_attr_hash_alloc_mod);
+      vty_out (vty, "ret(%p)-refcnt: %d  %s", attr_ret, attr_ret->refcnt, VTY_NEWLINE);
+      vty_out (vty, "attr(%p)-refcnt: %d  %s", attr, attr->refcnt, VTY_NEWLINE);
+
+      //bgp_attr_extra_free (attr);
+#endif
+
+#if 0// REVERT COMMUNITY HASH
+      /* revert for attr hash */
+      /*  otherwise attrhash_key_make() in attrhash_init
+       *  has inconsistancy with the previous hash data.
+       *  Because hash_key will be different with original one.
+       */
+      hash_release(community_hash (), com);  // release the backet itself
+      memcpy( com, &old, sizeof(struct community));
+      *com->val = old_val;
+      //memcpy (com_lastval (com), &old.val, sizeof (u_int32_t));
+      ret = hash_get (community_hash (), com, hash_alloc_intern);
+      vty_out (vty, "returned> (com)  str: %s  val:0x%x  ret:%p %s \n", \
+          com->str, *com->val, ret, VTY_NEWLINE);
+#endif
+
+    }
+  }
+
+}
+#endif
+
 /* Show BGP's community internal data. */
 DEFUN (show_ip_bgp_community_info,
        show_ip_bgp_community_info_cmd,
@@ -8830,6 +9005,657 @@ DEFUN (show_ip_bgp_community_info,
   return CMD_SUCCESS;
 }
 
+#ifdef SRX_COMM
+extern void hash_iterate_mod (struct hash *,
+    void (*) (struct hash_backet *, void *, int, const char**), void *, int, const char **);
+/* Show BGP's community internal data. */
+// substitute the original community string with the user request value
+DEFUN (show_ip_bgp_community_info_chg,
+    show_ip_bgp_community_info_chg_cmd,
+    "show ip bgp community-info chg (<1-65536:1-65536>|WORD) (<1-65536:1-65536>|WORD)",
+    SHOW_STR
+    IP_STR
+    BGP_STR
+    "List all bgp community information chg specified \n")
+{
+
+  vty_out (vty, "SRx user defined param:%s  %s", argv[0], VTY_NEWLINE);
+
+  hash_iterate_mod (community_hash (),
+      (void (*) (struct hash_backet *, void *, int, const char**))
+      community_show_all_iterator_mod,
+      vty, argc, argv);
+
+  return CMD_SUCCESS;
+}
+
+
+/* bgp community set */
+ int
+bgp_commset(struct vty *vty, struct bgp *bgp,  afi_t afi, safi_t safi,
+            const char *arg)
+{
+  int ret;
+  struct peer *peer, *peer_tmp;
+  struct listnode *node, *nnode;
+  struct bgp *peer_bgp;
+
+  struct bgp_info *binfo = NULL;
+  struct bgp_advertise *adv;
+  struct bgp_advertise_attr *baa;
+  struct attr *attr_tmp;
+
+
+  vty_out (vty, " bgp_commset called BGP %s", VTY_NEWLINE);
+
+  for (ALL_LIST_ELEMENTS (bgp->peer, node, nnode, peer))
+  {
+    peer_bgp = peer->bgp;
+    //binfo = peer_bgp->binfo;
+    if(strcmp(peer->host, arg) ==0)
+    {
+      peer_tmp = peer;
+      vty_out (vty, "arg: %s peer:%p", peer->host, peer);
+      break;
+    }
+    vty_out (vty, "%s", VTY_NEWLINE);
+  }
+
+  if(peer)
+  {
+    vty_out (vty, "%s", VTY_NEWLINE);
+    vty_out (vty, "after arg: %s peer:%p", peer->host, peer);
+    vty_out (vty, "%s", VTY_NEWLINE);
+
+    //struct hash *attr_hash = attribute_hash();
+    //hash_release(attr_hash, attr_tmp);
+
+    //struct bgp_advertise_fifo *baf;
+
+    adv= peer_tmp->sync[afi][safi]->update.next;
+
+    if(adv)
+      vty_out(vty, " -------- adv : %p %s", adv, VTY_NEWLINE);
+    else
+      vty_out(vty, " adv --------- not exist %s", VTY_NEWLINE);
+
+    baa = adv->baa;
+    /*
+       if(baa)
+       attr_tmp = baa->attr;
+       else
+       return -1;
+       */
+  }
+
+  attr_show_all(vty);
+
+  vty_out (vty, " bgp_commset ---- using bnode %s", VTY_NEWLINE);
+  //struct bgp_info *binfo;
+  struct bgp_node *bnode;
+  struct bgp_table* table= bgp->rib[AFI_IP][SAFI_UNICAST];
+
+
+  vty_out(vty, "rip table:%p %s", table, VTY_NEWLINE);
+
+  for (bnode = bgp_table_top(table); bnode; bnode = bgp_route_next(bnode))
+  {
+    if (bnode->info != NULL)
+    {
+      binfo  = (struct bgp_info*)bnode->info;
+      vty_out(vty, "bnode[%p]_binfo[%p]_peer_host:%s attr: %p %s", bnode,binfo,
+          binfo->peer->host,binfo->attr, VTY_NEWLINE);
+
+      if(binfo->attr && binfo->attr->community)
+        vty_out(vty, "comm: %p cnt: %ld comm_str:%s %s", binfo->attr->community,
+            binfo->attr->community->refcnt, binfo->attr->community->str, VTY_NEWLINE);
+
+      if((strcmp(binfo->peer->host, arg) ==0) && binfo->attr && binfo->attr->community)
+      {
+        vty_out(vty, " --- match --- %s", VTY_NEWLINE);
+        vty_out(vty, "cnt: %ld comm_str:%s %s", binfo->attr->community->refcnt,
+            binfo->attr->community->str, VTY_NEWLINE);
+
+        //hash_release(community_hash (), binfo->attr->community);
+        //community_unintern (&binfo->attr->community);
+        UNSET_FLAG(binfo->attr->flag, BGP_ATTR_COMMUNITIES);
+        bgp_attr_unintern(&binfo->attr);
+        binfo->attr = NULL;
+      }
+      else
+        vty_out (vty, "%s", VTY_NEWLINE);
+    }
+  }
+
+  //if(strcmp(adv->adj->peer->host, peer->host))
+  //  vty_out(vty, "adv->adj->peer->host:%s %s", adv->adj->peer->host, VTY_NEWLINE);
+
+
+#if 0
+    struct peer *from = NULL;
+    struct bgp_advertise *next = NULL;
+    //struct bgp_advertise_attr *baa;
+    //baa = adv->baa;
+
+    if (adv->binfo)
+      binfo = adv->binfo;
+
+    if (binfo)
+    {
+      from = binfo->peer;
+      vty_out (vty, "from_host: %s %s", from->host, VTY_NEWLINE);
+    }
+#endif
+
+
+  return CMD_SUCCESS;
+}
+
+static int
+bgp_commset_vty(struct vty *vty, const char *name, afi_t afi, safi_t safi,
+                const char *arg)
+{
+  struct bgp *bgp;
+
+  /* BGP structure lookup. */
+  if (name)
+    {
+      bgp = bgp_lookup_by_name (name);
+      if (bgp == NULL)
+        {
+          vty_out (vty, "Can't find BGP view %s%s", name, VTY_NEWLINE);
+          return CMD_WARNING;
+        }
+    }
+  else
+    {
+      bgp = bgp_get_default ();
+      if (bgp == NULL)
+        {
+          vty_out (vty, "No BGP process is configured%s", VTY_NEWLINE);
+          return CMD_WARNING;
+        }
+      vty_out (vty, "default BGP process is configured%s", VTY_NEWLINE);
+    }
+
+  return bgp_commset(vty, bgp, afi, safi, arg);
+}
+
+
+/* tset for comm set */
+DEFUN (show_ip_bgp_commset,
+    show_ip_bgp_commset_cmd,
+    //"show ip bgp commset (<1-65536:1-65536>|WORD) (<1-65536:1-65536>|WORD)",
+    "show ip bgp commset (WORD)",
+    SHOW_STR
+    IP_STR
+    BGP_STR
+    "community set \n")
+{
+
+  vty_out (vty, "SRx user defined param:%s  %s", argv[0], VTY_NEWLINE);
+
+  //if (argc == 1)
+    //return bgp_commset_vty (vty, argv[0], 0, 0, NULL);
+    return bgp_commset_vty (vty, NULL, 1, 1, argv[0]);
+
+  //BGP_WRITE_ON()
+
+  return CMD_SUCCESS;
+}
+
+DEFUN (show_ip_bgp_rt_peer,
+    show_ip_bgp_rt_peer_cmd,
+    "show ip bgp rt",
+    SHOW_STR
+    IP_STR
+    BGP_STR
+    "route table  \n")
+{
+
+  struct bgp *bgp;
+  struct bgp_info *binfo;
+  struct bgp_node *bnode;
+  struct bgp_table* table;
+
+  /* BGP structure lookup. */
+
+  bgp = bgp_get_default ();
+  table = bgp->rib[AFI_IP][SAFI_UNICAST];
+  vty_out(vty, " bgp: %p rip table:%p %s", bgp, table, VTY_NEWLINE);
+  if (bgp == NULL)
+  {
+    vty_out (vty, "No BGP process is configured%s", VTY_NEWLINE);
+    return CMD_WARNING;
+  }
+  vty_out (vty, "default BGP process is configured%s", VTY_NEWLINE);
+
+
+  for (bnode = bgp_table_top(table); bnode; bnode = bgp_route_next(bnode))
+  {
+    if (bnode->info != NULL)
+    {
+      binfo  = (struct bgp_info*)bnode->info;
+      vty_out(vty, "bnode[%p]_binfo[%p] peer_host:%s attr:%p ", bnode,binfo,
+          binfo->peer->host,binfo->attr );
+
+      if(binfo->attr && binfo->attr->community)
+      {
+        //vty_out(vty, "comm: %p cnt: %ld comm_str:%s %s", binfo->attr->community,
+        vty_out(vty, "comm: %p ", binfo->attr->community);
+      }
+
+      vty_out (vty, "%s", VTY_NEWLINE);
+    }
+  }
+
+  struct bgp_node *rn;
+  struct bgp_info *ri;
+  struct bgp_adj_out *adj = NULL;
+  struct bgp_advertise *adv;
+
+  for (rn = bgp_table_top (table); rn; rn = bgp_route_next(rn))
+    for (ri = rn->info; ri; ri = ri->next)
+    {
+      //if (CHECK_FLAG (ri->flags, BGP_INFO_SELECTED) && ri->peer != peer)
+      vty_out (vty, "rn:%p ri->peer->host:%s ", rn, ri->peer->host );
+      //bgp_adj_out_set (rn, peer, &rn->p, &attr, afi, safi, ri);
+      if (rn)
+      {
+        for (adj = rn->adj_out; adj; adj = adj->next)
+        {
+          vty_out (vty, "adj:%p adj->peer->host:%s adj->adv:%p ",
+              adj, adj->peer->host, adj->adv);
+          adv = adj->adv;
+          if(adv)
+            vty_out (vty, " adv->baa:%p adv->baa->attr:%p", adv->baa, adv->baa->attr);
+          vty_out (vty, "%s", VTY_NEWLINE);
+          //if (adj->peer == peer)
+          // break;
+        }
+      }
+      vty_out (vty, "%s", VTY_NEWLINE);
+    }
+  return CMD_SUCCESS;
+}
+
+DEFUN (show_ip_bgp_rt,
+    show_ip_bgp_rt_cmd,
+    "show ip bgp rt (WORD)",
+    SHOW_STR
+    IP_STR
+    BGP_STR
+    "route table  \n")
+{
+  struct bgp *bgp;
+  struct bgp_info *binfo;
+  struct bgp_node *bnode;
+  struct bgp_table* table;
+
+  /* BGP structure lookup. */
+
+  bgp = bgp_get_default ();
+  table = bgp->rib[AFI_IP][SAFI_UNICAST];
+  vty_out(vty, " bgp: %p rip table:%p %s", bgp, table, VTY_NEWLINE);
+  if (bgp == NULL)
+  {
+    vty_out (vty, "No BGP process is configured%s", VTY_NEWLINE);
+    return CMD_WARNING;
+  }
+  vty_out (vty, "default BGP process is configured%s", VTY_NEWLINE);
+
+
+  for (bnode = bgp_table_top(table); bnode; bnode = bgp_route_next(bnode))
+  {
+    if (bnode->info != NULL)
+    {
+      binfo  = (struct bgp_info*)bnode->info;
+      vty_out(vty, "bnode[%p]_binfo[%p]_peer_host:%s attr:%p ", bnode,binfo,
+          binfo->peer->host,binfo->attr );
+
+      if(binfo->attr && binfo->attr->community)
+      {
+        //vty_out(vty, "comm: %p cnt: %ld comm_str:%s %s", binfo->attr->community,
+        vty_out(vty, "comm: %p ", binfo->attr->community);
+      }
+
+      /*
+      if((strcmp(binfo->peer->host, arg) ==0) && binfo->attr && binfo->attr->community)
+      {
+        vty_out(vty, " --- match --- %s", VTY_NEWLINE);
+        vty_out(vty, "cnt: %ld comm_str:%s %s", binfo->attr->community->refcnt,
+            binfo->attr->community->str, VTY_NEWLINE);
+      }
+      */
+
+      vty_out (vty, "%s", VTY_NEWLINE);
+    }
+  }
+
+  struct bgp_node *rn;
+  struct bgp_info *ri;
+  struct bgp_adj_out *adj = NULL;
+  struct bgp_advertise *adv;
+
+  for (rn = bgp_table_top (table); rn; rn = bgp_route_next(rn))
+    for (ri = rn->info; ri; ri = ri->next)
+    {
+      //if (CHECK_FLAG (ri->flags, BGP_INFO_SELECTED) && ri->peer != peer)
+      vty_out (vty, "ri->peer->host:%s %s", ri->peer->host, VTY_NEWLINE);
+      //bgp_adj_out_set (rn, peer, &rn->p, &attr, afi, safi, ri);
+      if (rn)
+      {
+        for (adj = rn->adj_out; adj; adj = adj->next)
+        {
+          vty_out (vty, "adj: %p adj->peer->host:%s adj->adv:%p ",
+              adj, adj->peer->host, adj->adv);
+          adv = adj->adv;
+          if(adv)
+            vty_out (vty, " adv->baa:%p adv->baa->attr:%p", adv->baa, adv->baa->attr);
+          vty_out (vty, "%s", VTY_NEWLINE);
+          //if (adj->peer == peer)
+           // break;
+        }
+        vty_out (vty, "%s", VTY_NEWLINE);
+      }
+    }
+
+
+  /*
+  if(strcmp(peer->host, arg) ==0)
+    {
+      peer_tmp = peer;
+      vty_out (vty, "arg: %s peer:%p", peer->host, peer);
+      break;
+    }
+    vty_out (vty, "%s", VTY_NEWLINE);
+    */
+
+  return CMD_SUCCESS;
+}
+
+
+/**
+ * @brief Manually Send BGP Update with Extcommunity value
+ *
+ * @param vty
+ * @param rn
+ * @param peer
+ * @param p
+ * @param afi
+ * @param safi
+ * @param ri
+ */
+void bgp_adv_out_vty (struct vty *vty, struct bgp_node *rn, struct peer *peer, struct prefix *p,
+		 afi_t afi, safi_t safi,
+		 struct bgp_info *ri)
+{
+  struct bgp_adj_out *adj = NULL;
+  struct bgp_advertise *adv;
+
+  if (rn)
+  {
+    for (adj = rn->adj_out; adj; adj = adj->next)
+      if (adj->peer == peer)
+        break;
+  }
+
+  /* make packet for BGP advertisement - part 1 */
+  if (! adj)
+  {
+    adj = XCALLOC (MTYPE_BGP_ADJ_OUT, sizeof (struct bgp_adj_out));
+    adj->peer = peer_lock (peer); /* adj_out peer reference */
+
+    if (rn)
+    {
+      BGP_ADJ_OUT_ADD (rn, adj);
+      bgp_lock_node (rn);
+    }
+  }
+
+  vty_out (vty, " rn: %p ri:%p ", rn, ri);
+  vty_out (vty, " adj->peer:%p  peer:%p %s", adj->peer, peer, VTY_NEWLINE);
+
+  if (adj->adv)
+    bgp_advertise_clean (peer, adj, AFI_IP, SAFI_UNICAST);
+
+  /* bgp_advertise_new () */
+  adj->adv =  (struct bgp_advertise *)
+    XCALLOC (MTYPE_BGP_ADVERTISE, sizeof (struct bgp_advertise));
+
+  adv = adj->adv;
+  adv->rn = rn;
+
+  assert (adv->binfo == NULL);
+  adv->binfo = bgp_info_lock (ri); /* bgp_info adj_out reference */
+
+  /* 1. here make community values here */
+
+  /* community new */
+  struct community *com_tmp = NULL;
+  com_tmp = (struct community *) XCALLOC (MTYPE_COMMUNITY,
+      sizeof (struct community));
+
+  /* Community token enum. */
+  enum community_token {
+    community_token_val,
+    community_token_no_export,
+    community_token_no_advertise,
+    community_token_local_as,
+    community_token_unknown } token = community_token_unknown;
+  u_int32_t val = 0;
+
+  /* community add value */
+  // TODO: Later, comm string should be replaced with the argument
+  //
+  community_getvalue_from_str ("100:200", &token, &val);
+  com_tmp->size++;
+  if (com_tmp->val)
+    com_tmp->val = XREALLOC (MTYPE_COMMUNITY_VAL, com_tmp->val, com_length (com_tmp));
+  else
+    com_tmp->val = XMALLOC (MTYPE_COMMUNITY_VAL, com_length (com_tmp));
+  val = htonl (val);
+  memcpy (com_lastval (com_tmp), &val, sizeof (u_int32_t));
+
+  /* community add str */
+  com_tmp->str = community_com2str_mod (com_tmp);
+
+  /* test print */
+  printf ("(tmp com_:%p) str: %s val:0x%x cnt:%d\n",
+      com_tmp, com_tmp->str, *com_tmp->val, com_tmp->refcnt );
+
+
+  /*  BGP advertisement - part 2 */
+
+  /* attribute value add */
+  struct hash *attr_hash = attribute_hash();
+  struct attr attr_old;
+  struct attr attr;
+  struct attr_extra extra;
+
+  /* generate an attribute whether or not using ''bgp_announce_check' func */
+  //
+  bgp_attr_default_set (&attr, BGP_ORIGIN_IGP);
+  //bgp_default_originate (peer, AFI_IP, SAFI_UNICAST, 0);
+  attr.community = com_tmp;
+  //bgp_announce_check (ri, peer, &rn->p, &attr, AFI_IP, SAFI_UNICAST);
+  attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES);
+  attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_SRX_COMMUNITY);
+  attr.local_pref = peer->bgp->default_local_pref;
+  memcpy (&attr.nexthop, &peer->nexthop.v4, IPV4_MAX_BYTELEN);
+
+  /* 2. here make extended community values here */
+
+  /* extended community intern */
+  struct ecommunity *new_ecom;
+  struct ecommunity *ecom = (struct ecommunity *) XCALLOC (MTYPE_ECOMMUNITY,
+					sizeof (struct ecommunity));
+  attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES);
+  memset(&extra, 0x0, sizeof(struct attr_extra));
+  SET_FLAG (peer->af_flags[AFI_IP][SAFI_UNICAST], PEER_FLAG_SEND_EXT_COMMUNITY);
+
+  // TODO: Later, extended comm string should be replaced with the argument
+  //
+  //ecom = ecommunity_str2com ("999:2", ECOMMUNITY_ROUTE_TARGET, 0);
+  ecom = ecommunity_bgpsec_str2com (ECOMMUNITY_BGPSEC_SUB, ECOMMUNITY_BGPSEC_VALID);
+  if (ecom)
+  {
+    new_ecom = ecommunity_intern (ecom);
+    //ecom->str = ecommunity_ecom2str (ecom, ECOMMUNITY_FORMAT_DISPLAY);
+    printf ("(ecom_:%p) str: %s val:0x%x refcnt:%d\n",
+      new_ecom, new_ecom->str, *new_ecom->val, new_ecom->refcnt );
+  }
+
+  extra.ecommunity = new_ecom;
+  attr.extra = &extra;
+
+  /* also attr intern */
+  if (&attr)
+    adv->baa = bgp_advertise_intern_mod (peer->hash[AFI_IP][SAFI_UNICAST], &attr);
+  else
+    adv->baa = (struct bgp_advertise_attr *)  // baa_new()
+      XCALLOC (MTYPE_BGP_ADVERTISE_ATTR, sizeof (struct bgp_advertise_attr));
+
+  adv->adj = adj;
+  printf(" ATTR ------ %p \n", adv->baa->attr);
+
+  /* Add new advertisement to advertisement attribute list. */
+  //bgp_advertise_add (adv->baa, adv);
+  adv->next = adv->baa->adv;
+  if (adv->baa->adv)
+    adv->baa->adv->prev = adv;
+  adv->baa->adv = adv;
+
+  /* Add to synchronization entry for update announcement.  */
+  FIFO_ADD (&peer->sync[AFI_IP][SAFI_UNICAST]->update, &adv->fifo);
+}
+
+
+/**
+ * @brief Send bgp update message to A.B.C.D
+ *
+ * @param bgp_adv_out
+ * @param bgp_adv_out_cmd
+ * @param A.B.C.D
+ * @param \n""
+ */
+DEFUN (bgp_adv_out,
+    bgp_adv_out_cmd,
+    "bgp adv-make (A.B.C.D)",
+    BGP_STR
+    "temporally make bgp advertisement  \n")
+{
+  struct bgp_adj_out *adj = NULL;
+  struct bgp_advertise *adv;
+  struct bgp *bgp;
+  struct bgp_table* table;
+  struct bgp_node *rn;
+  struct bgp_info *ri;
+  struct peer *peer;
+
+  bgp = bgp_get_default ();
+#if 0 // rt test
+  table = bgp->rib[AFI_IP][SAFI_UNICAST];
+  vty_out(vty, " bgp: %p rip table:%p %s", bgp, table, VTY_NEWLINE);
+
+  for (rn = bgp_table_top (table); rn; rn = bgp_route_next(rn))
+    for (ri = rn->info; ri; ri = ri->next)
+      vty_out (vty, " <test> rn:%p adj:%p ri->peer->host:%s %s", rn, rn->adj_out, ri->peer->host, VTY_NEWLINE);
+
+  vty_out (vty, "%s", VTY_NEWLINE);
+
+  /* route node and adjacnet structure lookup. */
+  for (rn = bgp_table_top (table); rn; rn = bgp_route_next(rn))
+  {
+    vty_out (vty, " -- rn:%p ri:%p %s", rn, rn->info, VTY_NEWLINE);
+    for (ri = rn->info; ri; ri = ri->next)
+    {
+      vty_out (vty, " <test> rn: %p ri:%p %s", rn, ri, VTY_NEWLINE);
+#if 0
+      for (adj = rn->adj_out; adj; adj = adj->next)
+      {
+        vty_out (vty, " adj:%p ", adj);
+        if (strcmp(adj->peer->host, argv[0]) == 0)
+        {
+          vty_out (vty, " rn:%p adj(%p).peer.host:%s", rn, adj, adj->peer->host );
+          break;
+        }
+      }
+#endif
+    }
+  }
+
+#endif
+
+  /* user arguemnt lookup */
+  if (argc == 1)
+  {
+    //peer = peer_lookup_in_view (vty, NULL, argv[0]);
+    vty_out (vty, " user defined param for argv:%s %s", argv[0], VTY_NEWLINE);
+
+    /* Get peer sockunion. */
+    union sockunion su;
+    int ret = str2sockunion (argv[0], &su);
+    if (ret < 0)
+    {
+      vty_out (vty, "Malformed address: %s%s", argv[0], VTY_NEWLINE);
+      peer = NULL;
+    }
+
+    /* Peer structure lookup. */
+    peer = peer_lookup (bgp, &su);
+    if (! peer)
+    {
+      vty_out (vty, "No such neighbor existed %s", VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+    if(peer->fd < 0)
+    {
+      vty_out (vty, "Neighbor is not being connected %s", VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+  }
+
+  /* peer lookup */
+  if (! peer)
+    return CMD_WARNING;
+  vty_out (vty, " peer(%p)->host:%s  peer rib table:%p %s",
+      peer, peer->host, peer->rib[AFI_IP][SAFI_UNICAST], VTY_NEWLINE);
+
+  /* BGP structure lookup. */
+  bgp = bgp_get_default ();
+  table = bgp->rib[AFI_IP][SAFI_UNICAST];
+  vty_out (vty, " bgp:%p table:%p %s", bgp, table, VTY_NEWLINE);
+
+  if (bgp == NULL)
+  {
+    vty_out (vty, "No BGP process is configured%s", VTY_NEWLINE);
+    return CMD_WARNING;
+  }
+
+  /* route node and adjacnet structure lookup. */
+  for (rn = bgp_table_top (table); rn; rn = bgp_route_next(rn))
+  {
+    //vty_out (vty, " rn:%p ", rn);
+    if(!rn->info) continue;
+    for (ri = rn->info; ri; ri = ri->next)
+    {
+      if (CHECK_FLAG (ri->flags, BGP_INFO_SELECTED) && ri->peer != peer)
+        bgp_adv_out_vty(vty, rn, peer, &rn->p, AFI_IP, SAFI_UNICAST, ri);
+    }
+
+  }
+
+  /*  bgp_write or BGP_WRITE_ON call for send update */
+  extern int bgp_write (struct thread *);
+  BGP_WRITE_ON (peer->t_write, bgp_write, peer->fd);
+  //BGP_TIMER_ON (peer->t_routeadv, bgp_routeadv_timer, 1);
+
+  return CMD_SUCCESS;
+}
+#endif
+
+
 DEFUN (show_ip_bgp_attr_info,
        show_ip_bgp_attr_info_cmd,
        "show ip bgp attribute-info",
@@ -10180,6 +11006,10 @@ bgp_vty_init (void)
   /* "neighbor capability dynamic" commands.*/
   install_element (BGP_NODE, &neighbor_capability_dynamic_cmd);
   install_element (BGP_NODE, &no_neighbor_capability_dynamic_cmd);
+#ifdef USE_SRX
+  install_element (BGP_NODE, &neighbor_capability_bgpsec_cmd);
+  install_element (BGP_NODE, &no_neighbor_capability_bgpsec_cmd);
+#endif
 
   /* "neighbor dont-capability-negotiate" commands. */
   install_element (BGP_NODE, &neighbor_dont_capability_negotiate_cmd);
@@ -10806,6 +11636,19 @@ bgp_vty_init (void)
   install_element (VIEW_NODE, &show_ip_bgp_community_info_cmd);
   install_element (ENABLE_NODE, &show_ip_bgp_community_info_cmd);
 
+#ifdef SRX_COMM
+  /* "show ip bgp community chg" commands. */
+  install_element (VIEW_NODE, &show_ip_bgp_community_info_chg_cmd);
+  install_element (ENABLE_NODE, &show_ip_bgp_community_info_chg_cmd);
+  install_element (VIEW_NODE, &show_ip_bgp_commset_cmd);
+  install_element (ENABLE_NODE, &show_ip_bgp_commset_cmd);
+  install_element (VIEW_NODE, &show_ip_bgp_rt_cmd);
+  install_element (ENABLE_NODE, &show_ip_bgp_rt_cmd);
+  install_element (VIEW_NODE, &show_ip_bgp_rt_peer_cmd);
+  install_element (ENABLE_NODE, &show_ip_bgp_rt_peer_cmd);
+  install_element (VIEW_NODE, &bgp_adv_out_cmd);
+  install_element (ENABLE_NODE, &bgp_adv_out_cmd);
+#endif
   /* "show ip bgp attribute-info" commands. */
   install_element (VIEW_NODE, &show_ip_bgp_attr_info_cmd);
   install_element (ENABLE_NODE, &show_ip_bgp_attr_info_cmd);
diff --git a/quaggasrx/bgpd/bgpd.c b/quaggasrx/bgpd/bgpd.c
index 6a27882..c348da3 100644
--- a/quaggasrx/bgpd/bgpd.c
+++ b/quaggasrx/bgpd/bgpd.c
@@ -2913,6 +2913,9 @@ static const struct peer_flag_action peer_flag_action_list[] =
     { PEER_FLAG_STRICT_CAP_MATCH,         0, peer_change_none },
     { PEER_FLAG_DYNAMIC_CAPABILITY,       0, peer_change_reset },
     { PEER_FLAG_DISABLE_CONNECTED_CHECK,  0, peer_change_reset },
+#ifdef USE_SRX
+    { PEER_FLAG_BGPSEC_CAPABILITY,        0, peer_change_none },
+#endif
     { 0, 0, 0 }
   };
 
diff --git a/quaggasrx/bgpd/bgpd.h b/quaggasrx/bgpd/bgpd.h
index cfc839c..b1778a5 100644
--- a/quaggasrx/bgpd/bgpd.h
+++ b/quaggasrx/bgpd/bgpd.h
@@ -220,6 +220,10 @@ Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
                               "with valid > any other\n"
 #endif /* USE_SRX */
 
+#ifdef USE_SRX
+#define SRX_COMM
+#endif
+
 /* Typedef BGP specific types.  */
 typedef u_int32_t as_t;
 typedef u_int16_t as16_t; /* we may still encounter 16 Bit asnums */
@@ -619,6 +623,9 @@ struct peer
 #define PEER_CAP_RESTART_RCV                (1 << 6) /* restart received */
 #define PEER_CAP_AS4_ADV                    (1 << 7) /* as4 advertised */
 #define PEER_CAP_AS4_RCV                    (1 << 8) /* as4 received */
+#ifdef USE_SRX
+#define PEER_CAP_BGPSEC_ADV                 (1 << 15)/* bgpsec advertised */
+#endif
 
   /* Capability flags (reset in bgp_stop) */
   u_int16_t af_cap[AFI_MAX][SAFI_MAX];
@@ -642,6 +649,7 @@ struct peer
 #define PEER_FLAG_DISABLE_CONNECTED_CHECK   (1 << 6) /* disable-connected-check */
 #define PEER_FLAG_LOCAL_AS_NO_PREPEND       (1 << 7) /* local-as no-prepend */
 #define PEER_FLAG_LOCAL_AS_REPLACE_AS       (1 << 8) /* local-as no-prepend replace-as */
+#define PEER_FLAG_BGPSEC_CAPABILITY         (1 << 15)/* bgpsec capability */
 
   /* NSF mode (graceful restart) */
   u_char nsf[AFI_MAX][SAFI_MAX];
@@ -896,6 +904,9 @@ struct bgp_nlri
 #define BGP_ATTR_AS4_PATH                       17
 #define BGP_ATTR_AS4_AGGREGATOR                 18
 #define BGP_ATTR_AS_PATHLIMIT                   21
+#ifdef SRX_COMM
+#define BGP_ATTR_SRX_COMMUNITY                  99
+#endif
 
 /* BGP update origin.  */
 #define BGP_ORIGIN_IGP                           0
@@ -928,7 +939,10 @@ struct bgp_nlri
 #define BGP_NOTIFY_OPEN_AUTH_FAILURE             5
 #define BGP_NOTIFY_OPEN_UNACEP_HOLDTIME          6
 #define BGP_NOTIFY_OPEN_UNSUP_CAPBL              7
-#define BGP_NOTIFY_OPEN_MAX                      8
+#ifdef USE_SRX
+#define BGP_NOTIFY_OPEN_UNSUP_BGPSEC             8
+#endif
+#define BGP_NOTIFY_OPEN_MAX                      9
 
 /* BGP_NOTIFY_UPDATE_ERR sub codes.  */
 #define BGP_NOTIFY_UPDATE_MAL_ATTR               1
diff --git a/quaggasrx/lib/hash.c b/quaggasrx/lib/hash.c
index 8c9f4c1..5410b54 100644
--- a/quaggasrx/lib/hash.c
+++ b/quaggasrx/lib/hash.c
@@ -166,6 +166,58 @@ hash_iterate (struct hash *hash,
       }
 }
 
+
+#ifdef SRX_COMM
+/* Iterator function for hash. for SRx function  */
+void hash_iterate_mod (struct hash *hash,
+    void (*func) (struct hash_backet *, void *, int, const char**), void *arg, int argc, const char **argv)
+{
+  unsigned int i;
+  struct hash_backet *hb;
+  struct hash_backet *hbnext;
+
+  for (i = 0; i < hash->size; i++)
+    for (hb = hash->index[i]; hb; hb = hbnext)
+    {
+      /* get pointer to next hash backet here, in case (*func)
+       * decides to delete hb by calling hash_release
+       */
+      hbnext = hb->next;
+      (*func) (hb, arg, argc, argv);
+    }
+}
+
+  int
+hash_iterate_once (struct hash *hash,
+    int (*func) (struct hash_backet *, void *, void *), void *arg, void *com)
+{
+  unsigned int i;
+  struct hash_backet *hb;
+  struct hash_backet *hbnext;
+  int ret=0;
+
+  for (i = 0; i < hash->size; i++)
+    for (hb = hash->index[i]; hb; hb = hbnext)
+    {
+      /* get pointer to next hash backet here, in case (*func)
+       * decides to delete hb by calling hash_release
+       */
+      printf(" index:%d  \n", i);
+      hbnext = hb->next;
+      ret = (*func) (hb, arg, com);
+
+      if(ret)
+      {
+        printf(" found the attribute(%p) which has the community pointer(%p) \n", \
+            hb->data, com);
+        return ret;
+      }
+    }
+  return ret;
+}
+#endif
+
+
 /* Clean up hash.  */
 void
 hash_clean (struct hash *hash, void (*free_func) (void *))
diff --git a/quaggasrx/lib/hash.h b/quaggasrx/lib/hash.h
index 29182af..404d195 100644
--- a/quaggasrx/lib/hash.h
+++ b/quaggasrx/lib/hash.h
@@ -67,6 +67,14 @@ extern void *hash_release (struct hash *, void *);
 extern void hash_iterate (struct hash *,
 		   void (*) (struct hash_backet *, void *), void *);
 
+#ifdef USE_SRX
+#define SRX_COMM
+#endif
+
+#ifdef SRX_COMM
+extern void hash_iterate_mod (struct hash *,
+    void (*) (struct hash_backet *, void *, int, const char**), void *, int, const char **);
+#endif
 extern void hash_clean (struct hash *, void (*) (void *));
 extern void hash_free (struct hash *);
 
diff --git a/quaggasrx/lib/version.h b/quaggasrx/lib/version.h
index 2c6196e..0f3722d 100644
--- a/quaggasrx/lib/version.h
+++ b/quaggasrx/lib/version.h
@@ -35,15 +35,9 @@
 #define GIT_INFO ""
 #endif
 
-#ifdef USE_SRX
 #define QUAGGA_PROGNAME   "QuaggaSrx"
 
 #define QUAGGA_VERSION     "0.3.0.2" GIT_SUFFIX
-#else /* USE_SRX */
-#define QUAGGA_PROGNAME   "Quagga"
-
-#define QUAGGA_VERSION     "0.99.22" GIT_SUFFIX
-#endif /* USE_SRX */
 
 #define ZEBRA_BUG_ADDRESS "https://bugzilla.quagga.net"
 
