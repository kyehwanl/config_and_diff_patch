--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ripd/rip_debug.c	2011-03-21 07:09:13.000000000 -0400
+++ ./ripd/rip_debug.c	2010-10-18 16:11:00.000000000 -0400
@@ -44,16 +44,19 @@
     {
       if (IS_RIP_DEBUG_SEND && IS_RIP_DEBUG_RECV)
 	{
-	  vty_out (vty, "  RIP packet debugging is on%s",
+	  vty_out (vty, "  RIP packet%s debugging is on%s",
+		   IS_RIP_DEBUG_DETAIL ? " detail" : "",
 		   VTY_NEWLINE);
 	}
       else
 	{
 	  if (IS_RIP_DEBUG_SEND)
-	    vty_out (vty, "  RIP packet send debugging is on%s",
+	    vty_out (vty, "  RIP packet send%s debugging is on%s",
+		     IS_RIP_DEBUG_DETAIL ? " detail" : "",
 		     VTY_NEWLINE);
 	  else
-	    vty_out (vty, "  RIP packet receive debugging is on%s",
+	    vty_out (vty, "  RIP packet receive%s debugging is on%s",
+		     IS_RIP_DEBUG_DETAIL ? " detail" : "",
 		     VTY_NEWLINE);
 	}
     }
@@ -102,12 +105,11 @@
     rip_debug_packet |= RIP_DEBUG_SEND;
   if (strncmp ("recv", argv[0], strlen (argv[0])) == 0)
     rip_debug_packet |= RIP_DEBUG_RECV;
+  rip_debug_packet &= ~RIP_DEBUG_DETAIL;
   return CMD_SUCCESS;
 }
 
-/* N.B. the "detail" modifier is a no-op.  we leave this command
-   for legacy compatibility. */
-DEFUN_DEPRECATED (debug_rip_packet_detail,
+DEFUN (debug_rip_packet_detail,
        debug_rip_packet_detail_cmd,
        "debug rip packet (recv|send) detail",
        DEBUG_STR
@@ -122,6 +124,7 @@
     rip_debug_packet |= RIP_DEBUG_SEND;
   if (strncmp ("recv", argv[0], strlen (argv[0])) == 0)
     rip_debug_packet |= RIP_DEBUG_RECV;
+  rip_debug_packet |= RIP_DEBUG_DETAIL;
   return CMD_SUCCESS;
 }
 
@@ -221,17 +224,20 @@
     {
       if (IS_RIP_DEBUG_SEND && IS_RIP_DEBUG_RECV)
 	{
-	  vty_out (vty, "debug rip packet%s",
+	  vty_out (vty, "debug rip packet%s%s",
+		   IS_RIP_DEBUG_DETAIL ? " detail" : "",
 		   VTY_NEWLINE);
 	  write++;
 	}
       else
 	{
 	  if (IS_RIP_DEBUG_SEND)
-	    vty_out (vty, "debug rip packet send%s",
+	    vty_out (vty, "debug rip packet send%s%s",
+		     IS_RIP_DEBUG_DETAIL ? " detail" : "",
 		     VTY_NEWLINE);
 	  else
-	    vty_out (vty, "debug rip packet recv%s",
+	    vty_out (vty, "debug rip packet recv%s%s",
+		     IS_RIP_DEBUG_DETAIL ? " detail" : "",
 		     VTY_NEWLINE);
 	  write++;
 	}
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ripd/rip_debug.h	2011-03-21 07:09:13.000000000 -0400
+++ ./ripd/rip_debug.h	2010-10-18 16:11:01.000000000 -0400
@@ -40,6 +40,7 @@
 #define IS_RIP_DEBUG_PACKET (rip_debug_packet & RIP_DEBUG_PACKET)
 #define IS_RIP_DEBUG_SEND   (rip_debug_packet & RIP_DEBUG_SEND)
 #define IS_RIP_DEBUG_RECV   (rip_debug_packet & RIP_DEBUG_RECV)
+#define IS_RIP_DEBUG_DETAIL (rip_debug_packet & RIP_DEBUG_DETAIL)
 
 #define IS_RIP_DEBUG_ZEBRA  (rip_debug_zebra & RIP_DEBUG_ZEBRA)
 
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./zebra/interface.c	2011-03-21 05:43:52.000000000 -0400
+++ ./zebra/interface.c	2010-10-18 16:13:13.000000000 -0400
@@ -477,10 +477,6 @@
 		}
 	    }
 #endif /* HAVE_IPV6 */
-	  else
-	    {
-	      last = node;
-	    }
 	}
     }
   zebra_interface_delete_update (ifp);
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./zebra/zserv.c	2011-03-21 05:43:52.000000000 -0400
+++ ./zebra/zserv.c	2010-10-18 16:13:28.000000000 -0400
@@ -451,7 +451,7 @@
     }
 
   /* Metric */
-  if (cmd == ZEBRA_IPV4_ROUTE_ADD || cmd == ZEBRA_IPV6_ROUTE_ADD)
+  if (cmd == ZEBRA_IPV4_ROUTE_ADD || ZEBRA_IPV6_ROUTE_ADD)
     {
       SET_FLAG (zapi_flags, ZAPI_MESSAGE_DISTANCE);
       stream_putc (s, rib->distance);
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./bgpd/bgp_nexthop.c	2011-03-21 09:43:34.000000000 -0400
+++ ./bgpd/bgp_nexthop.c	2010-10-18 16:11:24.000000000 -0400
@@ -276,8 +276,6 @@
 
 		  if (bnc->metric != oldbnc->metric)
 		    bnc->metricchanged = 1;
-
-                  bgp_unlock_node (oldrn);
 		}
 	    }
 	}
@@ -367,8 +365,6 @@
 
 		  if (bnc->metric != oldbnc->metric)
 		    bnc->metricchanged = 1;
-
-                  bgp_unlock_node (oldrn);
 		}
 	    }
 	}
@@ -575,7 +571,7 @@
 	}
       else
 	{
-	  bc = XCALLOC (MTYPE_BGP_CONN, sizeof (struct bgp_connected_ref));
+	  bc = XCALLOC (0, sizeof (struct bgp_connected_ref));
 	  bc->refcnt = 1;
 	  rn->info = bc;
 	}
@@ -600,7 +596,7 @@
 	}
       else
 	{
-	  bc = XCALLOC (MTYPE_BGP_CONN, sizeof (struct bgp_connected_ref));
+	  bc = XCALLOC (0, sizeof (struct bgp_connected_ref));
 	  bc->refcnt = 1;
 	  rn->info = bc;
 	}
@@ -640,7 +636,7 @@
       bc->refcnt--;
       if (bc->refcnt == 0)
 	{
-	  XFREE (MTYPE_BGP_CONN, bc);
+	  XFREE (0, bc);
 	  rn->info = NULL;
 	}
       bgp_unlock_node (rn);
@@ -666,7 +662,7 @@
       bc->refcnt--;
       if (bc->refcnt == 0)
 	{
-	  XFREE (MTYPE_BGP_CONN, bc);
+	  XFREE (0, bc);
 	  rn->info = NULL;
 	}
       bgp_unlock_node (rn);
@@ -1140,15 +1136,11 @@
   rn1 = bgp_node_match (bgp_connected_table[AFI_IP], &p1);
   if (! rn1)
     return 0;
-  bgp_unlock_node (rn1);
   
   rn2 = bgp_node_match (bgp_connected_table[AFI_IP], &p2);
   if (! rn2)
     return 0;
-  bgp_unlock_node (rn2);
 
-  /* This is safe, even with above unlocks, since we are just
-     comparing pointers to the objects, not the objects themselves. */
   if (rn1 == rn2)
     return 1;
 
@@ -1324,9 +1316,6 @@
 void
 bgp_scan_finish (void)
 {
-  /* Only the current one needs to be reset. */
-  bgp_nexthop_cache_reset (bgp_nexthop_cache_table[AFI_IP]);
-
   bgp_table_unlock (cache1_table[AFI_IP]);
   cache1_table[AFI_IP] = NULL;
 
@@ -1337,9 +1326,6 @@
   bgp_connected_table[AFI_IP] = NULL;
 
 #ifdef HAVE_IPV6
-  /* Only the current one needs to be reset. */
-  bgp_nexthop_cache_reset (bgp_nexthop_cache_table[AFI_IP6]);
-
   bgp_table_unlock (cache1_table[AFI_IP6]);
   cache1_table[AFI_IP6] = NULL;
 
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./bgpd/Makefile.am	2011-03-21 05:43:52.000000000 -0400
+++ ./bgpd/Makefile.am	2011-10-01 03:14:26.000000000 -0400
@@ -1,6 +1,6 @@
 ## Process this file with automake to produce Makefile.in.
 
-INCLUDES = @INCLUDES@ -I.. -I$(top_srcdir) -I$(top_srcdir)/lib @SNMP_INCLUDES@
+INCLUDES = @INCLUDES@ -I.. -I$(top_srcdir) -I$(top_srcdir)/lib @SNMP_INCLUDES@ -I$(top_srcdir)/$(SRX_DIR)
 DEFS = @DEFS@ -DSYSCONFDIR=\"$(sysconfdir)/\"
 INSTALL_SDATA=@INSTALL@ -m 600
 
@@ -15,17 +15,17 @@
 	bgp_debug.c bgp_route.c bgp_zebra.c bgp_open.c bgp_routemap.c \
 	bgp_packet.c bgp_network.c bgp_filter.c bgp_regex.c bgp_clist.c \
 	bgp_dump.c bgp_snmp.c bgp_ecommunity.c bgp_mplsvpn.c bgp_nexthop.c \
-	bgp_damp.c bgp_table.c bgp_advertise.c bgp_vty.c
+	bgp_damp.c bgp_table.c bgp_advertise.c bgp_vty.c bgp_info_hash.c
 
 noinst_HEADERS = \
 	bgp_aspath.h bgp_attr.h bgp_community.h bgp_debug.h bgp_fsm.h \
 	bgp_network.h bgp_open.h bgp_packet.h bgp_regex.h bgp_route.h \
 	bgpd.h bgp_filter.h bgp_clist.h bgp_dump.h bgp_zebra.h \
 	bgp_ecommunity.h bgp_mplsvpn.h bgp_nexthop.h bgp_damp.h bgp_table.h \
-	bgp_advertise.h bgp_snmp.h bgp_vty.h
+	bgp_advertise.h bgp_snmp.h bgp_vty.h bgp_info_hash.h
 
 bgpd_SOURCES = bgp_main.c
-bgpd_LDADD = libbgp.a ../lib/libzebra.la @LIBCAP@ @LIBM@
+bgpd_LDADD = libbgp.a ../lib/libzebra.la $(SRX_CLI_LIB) @LIBCAP@ @LIBM@
 
 examplesdir = $(exampledir)
 dist_examples_DATA = bgpd.conf.sample bgpd.conf.sample2
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./bgpd/bgp_attr.c	2011-03-21 10:32:49.000000000 -0400
+++ ./bgpd/bgp_attr.c	2010-10-18 16:11:25.000000000 -0400
@@ -28,7 +28,6 @@
 #include "stream.h"
 #include "log.h"
 #include "hash.h"
-#include "jhash.h"
 
 #include "bgpd/bgpd.h"
 #include "bgpd/bgp_attr.h"
@@ -117,9 +116,18 @@
 static unsigned int
 cluster_hash_key_make (void *p)
 {
-  const struct cluster_list *cluster = p;
+  struct cluster_list * cluster = (struct cluster_list *) p;
+  unsigned int key = 0;
+  int length;
+  caddr_t pnt;
 
-  return jhash(cluster->list, cluster->length, 0);
+  length = cluster->length;
+  pnt = (caddr_t) cluster->list;
+  
+  while (length)
+    key += pnt[--length];
+
+  return key;
 }
 
 static int
@@ -250,9 +258,18 @@
 static unsigned int
 transit_hash_key_make (void *p)
 {
-  const struct transit * transit = p;
+  struct transit * transit = (struct transit *) p;
+  unsigned int key = 0;
+  int length;
+  caddr_t pnt;
+
+  length = transit->length;
+  pnt = (caddr_t) transit->val;
 
-  return jhash(transit->val, transit->length, 0);
+  while (length)
+    key += pnt[--length];
+
+  return key;
 }
 
 static int
@@ -335,46 +352,51 @@
 unsigned int
 attrhash_key_make (void *p)
 {
-  const struct attr * attr = (struct attr *) p;
-  uint32_t key = 0;
-#define MIX(val)	key = jhash_1word(val, key)
-
-  MIX(attr->origin);
-  MIX(attr->nexthop.s_addr);
-  MIX(attr->med);
-  MIX(attr->local_pref);
+  struct attr * attr = (struct attr *) p;
+  unsigned int key = 0;
 
   key += attr->origin;
   key += attr->nexthop.s_addr;
   key += attr->med;
   key += attr->local_pref;
+  if (attr->pathlimit.as)
+    {
+      key += attr->pathlimit.ttl;
+      key += attr->pathlimit.as;
+    }
   
   if (attr->extra)
     {
-      MIX(attr->extra->aggregator_as);
-      MIX(attr->extra->aggregator_addr.s_addr);
-      MIX(attr->extra->weight);
-      MIX(attr->extra->mp_nexthop_global_in.s_addr);
+      key += attr->extra->aggregator_as;
+      key += attr->extra->aggregator_addr.s_addr;
+      key += attr->extra->weight;
+      key += attr->extra->mp_nexthop_global_in.s_addr;
     }
   
   if (attr->aspath)
-    MIX(aspath_key_make (attr->aspath));
+    key += aspath_key_make (attr->aspath);
   if (attr->community)
-    MIX(community_hash_make (attr->community));
+    key += community_hash_make (attr->community);
   
   if (attr->extra)
     {
       if (attr->extra->ecommunity)
-        MIX(ecommunity_hash_make (attr->extra->ecommunity));
+        key += ecommunity_hash_make (attr->extra->ecommunity);
       if (attr->extra->cluster)
-        MIX(cluster_hash_key_make (attr->extra->cluster));
+        key += cluster_hash_key_make (attr->extra->cluster);
       if (attr->extra->transit)
-        MIX(transit_hash_key_make (attr->extra->transit));
+        key += transit_hash_key_make (attr->extra->transit);
 
 #ifdef HAVE_IPV6
-      MIX(attr->extra->mp_nexthop_len);
-      key = jhash2(attr->extra->mp_nexthop_global.s6_addr32, 4, key);
-      key = jhash2(attr->extra->mp_nexthop_local.s6_addr32, 4, key);
+      {
+        int i;
+        
+        key += attr->extra->mp_nexthop_len;
+        for (i = 0; i < 16; i++)
+          key += attr->extra->mp_nexthop_global.s6_addr[i];
+        for (i = 0; i < 16; i++)
+          key += attr->extra->mp_nexthop_local.s6_addr[i];
+      }
 #endif /* HAVE_IPV6 */
     }
 
@@ -393,7 +415,9 @@
       && attr1->aspath == attr2->aspath
       && attr1->community == attr2->community
       && attr1->med == attr2->med
-      && attr1->local_pref == attr2->local_pref)
+      && attr1->local_pref == attr2->local_pref
+      && attr1->pathlimit.ttl == attr2->pathlimit.ttl
+      && attr1->pathlimit.as == attr2->pathlimit.as)
     {
       const struct attr_extra *ae1 = attr1->extra;
       const struct attr_extra *ae2 = attr2->extra;
@@ -680,6 +704,43 @@
     }
 }
 
+/* Parse AS_PATHLIMIT attribute in an UPDATE */
+static int
+bgp_attr_aspathlimit (struct peer *peer, bgp_size_t length,
+                      struct attr *attr, u_char flag, u_char *startp)
+{
+  bgp_size_t total;
+  
+  total = length + (CHECK_FLAG (flag, BGP_ATTR_FLAG_EXTLEN) ? 4 : 3);
+  
+  if (!CHECK_FLAG(flag, BGP_ATTR_FLAG_TRANS)
+       || !CHECK_FLAG(flag, BGP_ATTR_FLAG_OPTIONAL))
+    {
+      zlog (peer->log, LOG_ERR, 
+	    "AS-Pathlimit attribute flag isn't transitive %d", flag);
+      bgp_notify_send_with_data (peer, 
+				 BGP_NOTIFY_UPDATE_ERR, 
+				 BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,
+				 startp, total);
+      return -1;
+    }
+  
+  if (length != 5)
+    {
+      zlog (peer->log, LOG_ERR, 
+	    "AS-Pathlimit length, %u, is not 5", length);
+      bgp_notify_send_with_data (peer, 
+				 BGP_NOTIFY_UPDATE_ERR, 
+				 BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,
+				 startp, total);
+      return -1;
+    }
+  
+  attr->pathlimit.ttl = stream_getc (BGP_INPUT(peer));
+  attr->pathlimit.as = stream_getl (BGP_INPUT(peer));
+  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_AS_PATHLIMIT);
+  return 0;
+}
 /* Get origin attribute of the update message. */
 static int
 bgp_attr_origin (struct peer *peer, bgp_size_t length, 
@@ -746,78 +807,54 @@
 
   return 0;
 }
-/* Parse AS path information.  This function is wrapper of aspath_parse.
- *
- * Parses AS_PATH or AS4_PATH.
- *
- * Returns: if valid: address of struct aspath in the hash of known aspaths,
- *                    with reference count incremented.
- *              else: NULL
- *
- * NB: empty AS path (length == 0) is valid.  The returned struct aspath will
- *     have segments == NULL and str == zero length string (unique).
- */
-static struct aspath *
-bgp_attr_aspath (struct peer *peer, bgp_size_t length, 
-		 struct attr *attr, u_char flag, u_char *startp, int as4_path)
-{
-  u_char require ;
-  struct aspath *asp ;
-
-  /* Check the attribute flags                                          */
-  require = as4_path ? BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS
-                     :                          BGP_ATTR_FLAG_TRANS ;
 
-  if ((flag & (BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS)) != require)
+/* Parse AS path information.  This function is wrapper of
+   aspath_parse. */
+static int
+bgp_attr_aspath (struct peer *peer, bgp_size_t length, 
+		 struct attr *attr, u_char flag, u_char *startp)
     {
-      const char* path_type ;
       bgp_size_t total;
 
-      path_type = as4_path ? "AS4_PATH" : "AS_PATH" ;
-
-      if (!CHECK_FLAG(flag, BGP_ATTR_FLAG_TRANS))
-      zlog (peer->log, LOG_ERR, 
-            "%s attribute flag isn't transitive %d", path_type, flag) ;
-
-      if ((flag & BGP_ATTR_FLAG_OPTIONAL) != (require & BGP_ATTR_FLAG_OPTIONAL))
-        zlog (peer->log, LOG_ERR,
-            "%s attribute flag must %sbe optional %d", path_type,
-            (flag & BGP_ATTR_FLAG_OPTIONAL) ? "not " : "", flag) ;
-
       total = length + (CHECK_FLAG (flag, BGP_ATTR_FLAG_EXTLEN) ? 4 : 3);
 
+  /* Flag check. */
+  if (CHECK_FLAG (flag, BGP_ATTR_FLAG_OPTIONAL)
+      || ! CHECK_FLAG (flag, BGP_ATTR_FLAG_TRANS))
+    {
+      zlog (peer->log, LOG_ERR, 
+	    "As-Path attribute flag isn't transitive %d", flag);
       bgp_notify_send_with_data (peer, 
 				 BGP_NOTIFY_UPDATE_ERR, 
 				 BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,
 				 startp, total);
+      return -1;
+    }
 
-      return NULL ;
-    } ;
-
-  /* Parse the AS_PATH/AS4_PATH body.
-   *
-   * For AS_PATH  peer with AS4 => 4Byte ASN otherwise 2Byte ASN
-   *     AS4_PATH 4Byte ASN
+  /*
+   * peer with AS4 => will get 4Byte ASnums
+   * otherwise, will get 16 Bit
    */
-  asp = aspath_parse (peer->ibuf, length,
-               as4_path || CHECK_FLAG (peer->cap, PEER_CAP_AS4_RCV), as4_path) ;
+  attr->aspath = aspath_parse (peer->ibuf, length, 
+                               CHECK_FLAG (peer->cap, PEER_CAP_AS4_RCV));
 
-  if (asp != NULL)
-    {
-      attr->flag |= ATTR_FLAG_BIT (as4_path ? BGP_ATTR_AS4_PATH
-                                            : BGP_ATTR_AS_PATH) ;
-    }
-  else
+  /* In case of IBGP, length will be zero. */
+  if (! attr->aspath)
     {
       zlog (peer->log, LOG_ERR, "Malformed AS path length is %d", length);
-
-      /* TODO: should BGP_NOTIFY_UPDATE_MAL_AS_PATH be sent for AS4_PATH ??  */
       bgp_notify_send (peer, 
 		       BGP_NOTIFY_UPDATE_ERR, 
 		       BGP_NOTIFY_UPDATE_MAL_AS_PATH);
-    } ;
+      return -1;
+    }
+
+  /* Forward pointer. */
+/*  stream_forward_getp (peer->ibuf, length);*/
+
+  /* Set aspath attribute flag. */
+  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_AS_PATH);
 
-  return asp ;
+  return 0;
 }
 
 static int bgp_attr_aspath_check( struct peer *peer, 
@@ -875,6 +912,21 @@
 
 }
 
+/* Parse AS4 path information.  This function is another wrapper of
+   aspath_parse. */
+static int
+bgp_attr_as4_path (struct peer *peer, bgp_size_t length, 
+		 struct attr *attr, struct aspath **as4_path)
+{
+  *as4_path = aspath_parse (peer->ibuf, length, 1);
+
+  /* Set aspath attribute flag. */
+  if (as4_path)
+    attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_AS4_PATH);
+
+  return 0;
+}
+
 /* Nexthop attribute. */
 static int
 bgp_attr_nexthop (struct peer *peer, bgp_size_t length, 
@@ -1174,15 +1226,12 @@
       attr->community = NULL;
       return 0;
     }
-  
+  else
+    {
   attr->community =
     community_parse ((u_int32_t *)stream_pnt (peer->ibuf), length);
-  
-  /* XXX: fix community_parse to use stream API and remove this */
   stream_forward_getp (peer->ibuf, length);
-
-  if (!attr->community)
-    return -1;
+    }
   
   attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES);
 
@@ -1243,8 +1292,8 @@
 bgp_mp_reach_parse (struct peer *peer, bgp_size_t length, struct attr *attr,
 		    struct bgp_nlri *mp_update)
 {
-  afi_t afi;
-  safi_t safi;
+  u_int16_t afi;
+  u_char safi;
   bgp_size_t nlri_len;
   size_t start;
   int ret;
@@ -1378,8 +1427,8 @@
 		      struct bgp_nlri *mp_withdraw)
 {
   struct stream *s;
-  afi_t afi;
-  safi_t safi;
+  u_int16_t afi;
+  u_char safi;
   u_int16_t withdraw_len;
   int ret;
 
@@ -1420,18 +1469,13 @@
     {
       if (attr->extra)
         attr->extra->ecommunity = NULL;
-      /* Empty extcomm doesn't seem to be invalid per se */
-      return 0;
     }
-
+  else
+    {
   (bgp_attr_extra_get (attr))->ecommunity =
     ecommunity_parse ((u_int8_t *)stream_pnt (peer->ibuf), length);
-  /* XXX: fix ecommunity_parse to use stream API */
   stream_forward_getp (peer->ibuf, length);
-  
-  if (!attr->extra->ecommunity)
-    return -1;
-  
+    }
   attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES);
 
   return 0;
@@ -1613,12 +1657,10 @@
 	  ret = bgp_attr_origin (peer, length, attr, flag, startp);
 	  break;
 	case BGP_ATTR_AS_PATH:
-          attr->aspath = bgp_attr_aspath (peer, length, attr, flag, startp, 0);
-          ret = attr->aspath ? 0 : -1 ;
+	  ret = bgp_attr_aspath (peer, length, attr, flag, startp);
 	  break;
 	case BGP_ATTR_AS4_PATH:
-          as4_path = bgp_attr_aspath (peer, length, attr, flag, startp, 1);
-          ret = as4_path  ? 0 : -1 ;
+	  ret = bgp_attr_as4_path (peer, length, attr, &as4_path );
 	  break;
 	case BGP_ATTR_NEXT_HOP:	
 	  ret = bgp_attr_nexthop (peer, length, attr, flag, startp);
@@ -1656,6 +1698,9 @@
 	case BGP_ATTR_EXT_COMMUNITIES:
 	  ret = bgp_attr_ext_communities (peer, length, attr, flag);
 	  break;
+        case BGP_ATTR_AS_PATHLIMIT:
+          ret = bgp_attr_aspathlimit (peer, length, attr, flag, startp);
+          break;
 	default:
 	  ret = bgp_attr_unknown (peer, attr, flag, type, length, startp);
 	  break;
@@ -2210,6 +2255,24 @@
       stream_put_ipv4 (s, attr->extra->aggregator_addr.s_addr);
     }
   
+  /* AS-Pathlimit */
+  if (attr->pathlimit.ttl)
+    {
+      u_int32_t as = attr->pathlimit.as;
+      
+      /* should already have been done in announce_check(), 
+       * but just in case..
+       */
+      if (!as)
+        as = peer->local_as;
+      
+      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);
+      stream_putc (s, BGP_ATTR_AS_PATHLIMIT);
+      stream_putc (s, 5);
+      stream_putc (s, attr->pathlimit.ttl);
+      stream_putl (s, as);
+    }
+  
   /* Unknown transit attribute. */
   if (attr->extra && attr->extra->transit)
     stream_put (s, attr->extra->transit->val, attr->extra->transit->length);
@@ -2421,6 +2484,16 @@
     }
 #endif /* HAVE_IPV6 */
 
+  /* AS-Pathlimit */
+  if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_AS_PATHLIMIT))
+    {
+      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);
+      stream_putc (s, BGP_ATTR_AS_PATHLIMIT);
+      stream_putc (s, 5);
+      stream_putc (s, attr->pathlimit.ttl);
+      stream_putl (s, attr->pathlimit.as);
+    }
+
   /* Return total size of attribute. */
   len = stream_get_endp (s) - cp - 2;
   stream_putw_at (s, cp, len);
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./bgpd/bgp_packet.c	2011-03-21 09:52:26.000000000 -0400
+++ ./bgpd/bgp_packet.c	2010-10-18 16:11:18.000000000 -0400
@@ -177,11 +177,10 @@
 	  
 	  if (rn->prn)
 	    prd = (struct prefix_rd *) &rn->prn->p;
-          if (binfo)
+          if (binfo && binfo->extra)
             {
-              from = binfo->peer;
-              if (binfo->extra)
                 tag = binfo->extra->tag;
+              from = binfo->peer;
             }
           
 	  bgp_packet_set_marker (s, BGP_MSG_UPDATE);
@@ -1885,6 +1884,12 @@
       bgp_notify.subcode == BGP_NOTIFY_OPEN_UNSUP_PARAM )
     UNSET_FLAG (peer->sflags, PEER_STATUS_CAPABILITY_OPEN);
 
+  /* Also apply to Unsupported Capability until remote router support
+     capability. */
+  if (bgp_notify.code == BGP_NOTIFY_OPEN_ERR &&
+      bgp_notify.subcode == BGP_NOTIFY_OPEN_UNSUP_CAPBL)
+    UNSET_FLAG (peer->sflags, PEER_STATUS_CAPABILITY_OPEN);
+
   BGP_EVENT_ADD (peer, Receive_NOTIFICATION_message);
 }
 
@@ -2011,14 +2016,8 @@
 
 	      while (p_pnt < p_end)
 		{
-                  /* If the ORF entry is malformed, want to read as much of it
-                   * as possible without going beyond the bounds of the entry,
-                   * to maximise debug information.
-                   */
-		  int ok ;
 		  memset (&orfp, 0, sizeof (struct orf_prefix));
 		  common = *p_pnt++;
-		  /* after ++: p_pnt <= p_end */
 		  if (common & ORF_COMMON_PART_REMOVE_ALL)
 		    {
 		      if (BGP_DEBUG (normal, NORMAL))
@@ -2026,56 +2025,31 @@
 		      prefix_bgp_orf_remove_all (name);
 		      break;
 		    }
-		  ok = ((p_end - p_pnt) >= sizeof(u_int32_t)) ;
-		  if (ok)
-		    {
 		  memcpy (&seq, p_pnt, sizeof (u_int32_t));
 		  p_pnt += sizeof (u_int32_t);
 		  orfp.seq = ntohl (seq);
-		    }
-		  else
-		    p_pnt = p_end ;
-
-		  if ((ok = (p_pnt < p_end)))
-		    orfp.ge = *p_pnt++ ;      /* value checked in prefix_bgp_orf_set() */
-		  if ((ok = (p_pnt < p_end)))
-		    orfp.le = *p_pnt++ ;      /* value checked in prefix_bgp_orf_set() */
-		  if ((ok = (p_pnt < p_end)))
+		  orfp.ge = *p_pnt++;
+		  orfp.le = *p_pnt++;
 		    orfp.p.prefixlen = *p_pnt++ ;
-		  orfp.p.family = afi2family (afi);   /* afi checked already  */
-
-		  psize = PSIZE (orfp.p.prefixlen);   /* 0 if not ok          */
-		  if (psize > prefix_blen(&orfp.p))   /* valid for family ?   */
-		    {
-		      ok = 0 ;
-		      psize = prefix_blen(&orfp.p) ;
-		    }
-		  if (psize > (p_end - p_pnt))        /* valid for packet ?   */
-		    {
-		      ok = 0 ;
-		      psize = p_end - p_pnt ;
-		    }
-
-		  if (psize > 0)
+		  orfp.p.family = afi2family (afi);
+		  psize = PSIZE (orfp.p.prefixlen);
 		    memcpy (&orfp.p.u.prefix, p_pnt, psize);
 		  p_pnt += psize;
 
 		  if (BGP_DEBUG (normal, NORMAL))
-		    zlog_debug ("%s rcvd %s %s seq %u %s/%d ge %d le %d%s",
+		    zlog_debug ("%s rcvd %s %s seq %u %s/%d ge %d le %d",
 			       peer->host,
 			       (common & ORF_COMMON_PART_REMOVE ? "Remove" : "Add"), 
 			       (common & ORF_COMMON_PART_DENY ? "deny" : "permit"),
 			       orfp.seq, 
 			       inet_ntop (orfp.p.family, &orfp.p.u.prefix, buf, BUFSIZ),
-			       orfp.p.prefixlen, orfp.ge, orfp.le,
-			       ok ? "" : " MALFORMED");
+			       orfp.p.prefixlen, orfp.ge, orfp.le);
 
-		  if (ok)
 		  ret = prefix_bgp_orf_set (name, afi, &orfp,
 				 (common & ORF_COMMON_PART_DENY ? 0 : 1 ),
 				 (common & ORF_COMMON_PART_REMOVE ? 0 : 1));
 
-		  if (!ok || (ret != CMD_SUCCESS))
+		  if (ret != CMD_SUCCESS)
 		    {
 		      if (BGP_DEBUG (normal, NORMAL))
 			zlog_debug ("%s Received misformatted prefixlist ORF. Remove All pfxlist", peer->host);
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./bgpd/bgp_main.c	2011-03-21 09:43:34.000000000 -0400
+++ ./bgpd/bgp_main.c	2011-07-14 09:40:00.000000000 -0400
@@ -243,15 +243,7 @@
   if (retain_mode)
     if_add_hook (IF_DELETE_HOOK, NULL);
   for (ALL_LIST_ELEMENTS (iflist, node, nnode, ifp))
-    {
-      struct listnode *c_node, *c_nnode;
-      struct connected *c;
-
-      for (ALL_LIST_ELEMENTS (ifp->connected, c_node, c_nnode, c))
-        bgp_connected_delete (c);
-
       if_delete (ifp);
-    }
   list_free (iflist);
 
   /* reverse bgp_attr_init */
@@ -445,7 +437,12 @@
   vty_serv_sock (vty_addr, vty_port, BGP_VTYSH_PATH);
 
   /* Print banner. */
-  zlog_notice ("BGPd %s starting: vty@%d, bgp@%s:%d", QUAGGA_VERSION,
+#ifdef USE_SRX
+  #define BANNER_FMT "BGPd (+SRx) %s starting: vty@%d, bgp@%s:%d"
+#else
+  #define BANNER_FMT "BGPd %s starting: vty@%d, bgp@%s:%d"
+#endif
+  zlog_notice (BANNER_FMT, QUAGGA_VERSION,
 	       vty_port, 
 	       (bm->address ? bm->address : "<all>"),
 	       bm->port);
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./bgpd/bgp_dump.c	2011-03-21 07:09:13.000000000 -0400
+++ ./bgpd/bgp_dump.c	2010-10-18 16:11:28.000000000 -0400
@@ -356,11 +356,7 @@
           stream_putw(obuf, info->peer->table_dump_index);
 
           /* Originated */
-#ifdef HAVE_CLOCK_MONOTONIC
-          stream_putl (obuf, time(NULL) - (bgp_clock() - info->uptime));
-#else
           stream_putl (obuf, info->uptime);
-#endif /* HAVE_CLOCK_MONOTONIC */
 
           /* Dump attribute. */
           /* Skip prefix & AFI/SAFI for MP_NLRI */
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./bgpd/bgp_info_hash.c	1969-12-31 19:00:00.000000000 -0500
+++ ./bgpd/bgp_info_hash.c	2011-09-28 14:23:36.000000000 -0400
@@ -0,0 +1,264 @@
+#include <zebra.h>
+
+#ifdef USE_SRX
+
+#include "command.h"
+#include "linklist.h"
+#include "memory.h"
+#include "prefix.h"
+#include "vty.h"
+
+#include "bgpd/bgpd.h"
+#include "bgpd/bgp_aspath.h"
+#include "bgpd/bgp_attr.h"
+#include "bgpd/bgp_info_hash.h"
+#include "bgpd/bgp_route.h"
+#include "bgpd/bgp_table.h"
+
+#define SHOW_SCODE_HEADER "Validation code: v valid, u unknown, i invalid, ? undefined%s%s"
+#define SHOW_HEADER "         Ident          Network       I LocPrf Path%s"
+
+static int show_info_hash (struct vty* vty, struct bgp* bgp, 
+                           struct bgp_info_hash *hash)
+{
+  static const char RES_CODE_CHAR[] = { 'v', 'u', 'i', '?' };
+
+  struct bgp_info_hash_item* curr;
+  char pbuf[INET6_ADDRSTRLEN];
+  struct attr* attr;
+  int valState;
+  
+  if (HASH_COUNT (hash->table) == 0)
+  {
+    vty_out (vty, "   (No entries)%s%s", VTY_NEWLINE, VTY_NEWLINE);
+    return 0;
+  }
+
+  vty_out (vty, SHOW_HEADER, VTY_NEWLINE);
+  for (curr = hash->table; curr != NULL; curr = curr->hh.next)
+  {
+    valState = srx_calc_validation_state(bgp, curr->info);
+    vty_out (vty, "   %c(%c%c) %08X ", 
+        RES_CODE_CHAR[valState],             
+        RES_CODE_CHAR[curr->info->val_res_ROA],
+        RES_CODE_CHAR[curr->info->val_res_BGPSEC],
+        curr->identifier);
+
+    /* Node - identified by its prefix */
+    if (curr->info->node)
+    {
+      vty_out (vty, "%15s/%-2d  ",
+               inet_ntop (curr->info->node->p.family, 
+                          &curr->info->node->p.u.prefix, 
+                          pbuf, INET6_ADDRSTRLEN),
+        curr->info->node->p.prefixlen);
+    }
+    else
+    {
+      vty_out (vty, "(NULL node)         ");
+    }
+
+    /* Ignore flag */
+    if (CHECK_FLAG (curr->info->flags, BGP_INFO_IGNORE))
+    {
+      vty_out (vty, "x ");
+    }
+    else
+    {
+      vty_out (vty, "  ");
+    }
+
+    attr = curr->info->attr;
+
+    /* Local-preference and adjustment */
+    if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF))
+    {
+      vty_out (vty, "%d", attr->local_pref);
+    }
+    else
+    {
+      vty_out (vty, "D:%d", bgp->default_local_pref);
+    }
+
+    switch (valState)
+    {
+      case SRx_RESULT_VALID:
+        valState = VAL_LOCPRF_VALID;
+        break;
+      case SRx_RESULT_UNKNOWN:
+        valState = VAL_LOCPRF_UNKNOWN;
+        break;
+      case SRx_RESULT_INVALID:
+        valState = VAL_LOCPRF_INVALID;
+        break;
+      case SRx_RESULT_UNDEFINED:
+      default:
+        valState = -1;
+    }
+    if (valState != -1)
+    {
+      if (bgp->srx_val_local_pref[valState].is_set)
+      {
+        if (bgp->srx_val_local_pref[valState].relative)
+        {
+          vty_out (vty, "%c%4d", 
+                   (bgp->srx_val_local_pref[valState].relative == 1) ? '+' 
+                                                                     : '-' ,
+                    bgp->srx_val_local_pref[valState].value);
+        }
+        else
+        {
+          vty_out (vty, "->%4d", bgp->srx_val_local_pref[valState].value);
+        }        
+      }
+    }
+    else
+    {
+      vty_out (vty, "      ");
+    }        
+
+    /* AS-Path */
+    if (attr->aspath)
+    {
+      aspath_print_vty (vty, " \"%s\"", attr->aspath, " ");
+    }
+ 
+    vty_out (vty, "%s", VTY_NEWLINE);
+  }
+  vty_out (vty, "%s", VTY_NEWLINE);
+
+  return 1;
+}
+
+/** Is not available in terminal session. */
+DEFUN (show_bgp_info_hashes,
+       show_bgp_info_hashes_cmd,
+       "show bgp info-hashes",
+       SHOW_STR
+       BGP_STR
+       "Display all info hashes\n")
+{
+  struct listnode* curr;
+  struct bgp* bgp;
+
+  vty_out (vty, SHOW_SCODE_HEADER, VTY_NEWLINE, VTY_NEWLINE);
+  for (ALL_LIST_ELEMENTS_RO(bm->bgp, curr, bgp))
+  {
+    vty_out (vty, "BGP info hash of AS %d%s", bgp->as, VTY_NEWLINE);
+    show_info_hash (vty, bgp, bgp->info_hash);
+  }
+
+  return CMD_SUCCESS;
+}
+
+void bgp_all_info_hashes_init (void)
+{
+// remove this debug command!
+// install_element (VIEW_NODE, &show_bgp_info_hashes_cmd);
+}
+
+struct bgp_info_hash* bgp_info_hash_init (void)
+{
+  struct bgp_info_hash* new;
+  
+  new = XCALLOC(MTYPE_BGP_INFO_HASH, sizeof(struct bgp_info_hash));
+  if (new)
+  {
+    new->table = NULL;
+  }
+  return new;
+}
+
+void bgp_info_hash_finish (struct bgp_info_hash** hash)
+{
+  struct bgp_info_hash_item* curr;
+
+  while ((*hash)->table)
+  {
+    curr = (*hash)->table;
+    HASH_DEL ((*hash)->table, curr);
+    XFREE (MTYPE_BGP_INFO_HASH_ITEM, curr);
+  }
+
+  XFREE (MTYPE_BGP_INFO_HASH, *hash);
+  *hash = NULL;
+}
+
+/**
+ * 
+ * @param hash
+ * @param info
+ * @param identifier
+ * 
+ * @return 1 if the registration was successfull, 0 if the update identifier was
+ *         already known to the system and -1 if an error occured.
+ */
+int bgp_info_register (struct bgp_info_hash* hash, struct bgp_info* info, 
+                       uint32_t identifier)
+{
+  if (identifier ==0)
+      return 0;
+  struct bgp_info_hash_item *new;
+
+  /* Check if a known identifier */
+  if (bgp_info_fetch(hash, identifier) != NULL)
+  {
+    return 0;
+  }
+
+  /* Add to the hash */
+  new = XCALLOC (MTYPE_BGP_INFO_HASH_ITEM, sizeof(struct bgp_info_hash_item));
+  if (new == NULL) 
+  {
+    zlog_err("Not enough memory to store update [0x%80X]", identifier);
+    return -1;
+  }
+
+  new->identifier = identifier;
+  new->info       = info;
+
+  HASH_ADD(hh, hash->table, identifier, sizeof(uint32_t), new);
+
+  /* Removing the node also unregisters it */
+  bgp_info_set_identifier(info, hash, identifier);
+
+  return 1;
+}
+
+/**
+ * Remove the update id <-> update relation from the hash table.
+ * 
+ * @param hash The hash table
+ * @param identifier the update identifier who has to be removed.
+ */
+void bgp_info_unregister(struct bgp_info_hash* hash, uint32_t identifier)
+{
+  struct bgp_info_hash_item* entry;
+
+  HASH_FIND(hh, hash->table, &identifier, sizeof(uint32_t), entry);
+  if (entry)
+  {
+    HASH_DEL(hash->table, entry);
+    XFREE(MTYPE_BGP_INFO_HASH, entry);
+  }
+}
+
+/**
+ * Retrieve the bgp update associated with the update id or NULL
+ * 
+ * @param hash the info hash table
+ * @param identifier the update identifier
+ * 
+ * @return the bgp update or NULL
+ */
+struct bgp_info* bgp_info_fetch (struct bgp_info_hash* hash, 
+                                 uint32_t identifier)
+{
+  struct bgp_info_hash_item* entry;
+
+  HASH_FIND (hh, hash->table, &identifier, sizeof(uint32_t), entry);
+  return (entry ? entry->info : NULL);
+}
+
+#endif /* USE_SRX */
+
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./bgpd/bgpd.h	2011-03-21 09:36:46.000000000 -0400
+++ ./bgpd/bgpd.h	2011-10-01 04:25:41.000000000 -0400
@@ -24,6 +24,138 @@
 /* For union sockunion.  */
 #include "sockunion.h"
 
+#ifdef USE_SRX
+#include "bgp_info_hash.h"
+// TEMP from <srx/srx_api.h> to "srx/srx_api.h"
+#include <srx/srx_api.h>
+//#include "srx/srx_api.h"
+
+#define SRX_VTY_HLP_STR         "SRx configuration setting\n"
+
+#define SRX_VTY_EVAL_ORIGIN_ONLY "origin_only"
+#define SRX_VTY_EVAL_BGPSEC      "bgpsec"
+
+#define SRX_VTY_PARAM_CONNECT_SRV  0
+#define SRX_VTY_PARAM_CONNECT_PORT 1
+#define SRX_VTY_CMD_CONNECT_SHORT "srx connect"
+#define SRX_VTY_HLP_CONNECT_SHORT SRX_VTY_HLP_STR \
+                                  "Connect the router with SRx server\n"
+#define SRX_VTY_CMD_CONNECT   SRX_VTY_CMD_CONNECT_SHORT " .LINE <0..65535>"
+#define SRX_VTY_OUT_CONNECT   "srx connect %s %d%s"
+#define SRX_VTY_HLP_CONNECT   SRX_VTY_HLP_CONNECT_SHORT \
+                              "Specifies SRx server host name or IP address\n" \
+                              "Specifies SRx server port\n"
+
+#define SRX_VTY_CMD_DISCONNECT  "srx disconnect"
+#define SRX_VTY_HLP_DISCONNECT  SRX_VTY_HLP_STR \
+                                "Disconnect from the SRx server\n"
+                                  
+#define SRX_VTY_CMD_DISPLAY     "srx display"
+#define SRX_VTY_OUT_DISPLAY     "srx diaplay%s"
+#define SRX_VTY_HLP_DISPLAY     SRX_VTY_HLP_STR \
+                                "Add SRx related output to the \"show\"" \
+                                " commands\n"
+#define SRX_VTY_HLP_DISPLAY_NO  SRX_VTY_HLP_STR \
+                                "Hide SRx related output from the \"show\"" \
+                                " commands\n"
+                                   
+#define SRX_VTY_CMD_EVALUATE    "srx evaluation (" SRX_VTY_EVAL_ORIGIN_ONLY \
+                                                 "|" SRX_VTY_EVAL_BGPSEC ")"
+#define SRX_VTY_OUT_EVALUATE    "srx evaluation %s%s"
+#define SRX_VTY_HLP_EVALUATE    SRX_VTY_HLP_STR \
+                                "Activate the policy processing\n" \
+                                "Only perform prefix origin validation using " \
+                                  "ROAs\n" \
+                                "Perform both, prefix origin validation using" \
+                                  " ROA's and path validation\n"
+#define SRX_VTY_CMD_NO_EVALUATE "no srx evaluation"
+#define SRX_VTY_HLP_NO_EVALUATE  NO_STR SRX_VTY_HLP_STR \
+                                "Deactivate the policy processing.\n" \
+
+#define SRX_VTY_CMD_KEEPWINDOW  "srx keep-window <0-65535>"
+#define SRX_VTY_HLP_KEEPWINDOW  SRX_VTY_HLP_STR \
+                                "Configure amount of time in seconds the SRx is" \
+                                " requested to hold information after it "\
+                                " is deleted!\n" \
+                                "Time in seconds \'0\' disables this feature!\n"
+
+                                   
+#define SRX_VTY_CMD_SHOW_CONFIG "show srx-config"
+#define SRX_VTY_HLP_SHOW_CONFIG SHOW_STR "SRx-BGP Router configuration\n"
+
+// APPLY POLICY CHANGE
+#define SRX_VTY_CMD_APPLY_POLICY "srx apply-policy"
+#define SRX_VTY_HLP_APPLY_POLICY SRX_VTY_HLP_STR \
+                                 "Apply SRx policy changes to all updates in" \
+                                 " the RIB.\n"
+
+// POLICY 
+#define SRX_VTY_HLP_POLICY      "Evaluation policy command\n"
+#define SRX_VTY_HLP_POLICY_ROA  "Prefix-origin validation using ROA's\n"
+#define SRX_VTY_HLP_POLICY_PATH "Path validation (NOT IMPLEMENTED YET)\n"
+#define SRX_VTY_HLP_ORIGIN_ONLY "(" SRX_VTY_EVAL_ORIGIN_ONLY ") "
+
+// POLICY IGNORE UNKNOWN / INVALID 
+#define SRX_VTY_CMD_POL_IGNORE_UNKNOWN   "srx policy ignore-unknown"
+#define SRX_VTY_HLP_POL_IGNORE_UNKNOWN   SRX_VTY_HLP_STR SRX_VTY_HLP_POLICY \
+                                         SRX_VTY_HLP_ORIGIN_ONLY \
+                                         "Ignore updates with validation " \
+                                         "result = UNKNOWN.\n"
+
+#define SRX_VTY_CMD_POL_IGNORE_INVALID   "srx policy ignore-invalid"
+#define SRX_VTY_HLP_POL_IGNORE_INVALID   SRX_VTY_HLP_STR SRX_VTY_HLP_POLICY \
+                                         "Ignore updates with validation" \
+                                         " result = INVALID.\n"
+
+#define SRX_VTY_CMD_POL_IGNORE_UNDEFINED "srx policy ignore-undefined"
+#define SRX_VTY_HLP_POL_IGNORE_UNDEFINED SRX_VTY_HLP_STR SRX_VTY_HLP_POLICY \
+                                         "Ignore updates with no complete" \
+                                         " validation result available.\n"
+
+// POLICY LOCAL-PREF ADJUSTMENT
+#define SRX_VTY_HLP_POL_LOCP   "Manipulate local preference\n"
+#define SRX_VTY_HLP_POL_LOCP_V "Policy for validation result  = VALID\n"
+#define SRX_VTY_HLP_POL_LOCP_U SRX_VTY_HLP_ORIGIN_ONLY "Policy for " \
+                               "validation result = UNKNOWN\n"
+#define SRX_VTY_HLP_POL_LOCP_I "Policy for validation result = INVALID\n"
+
+#define SRX_VTY_HLP_POL_LOCP_A "To be added to the given local pref\n"
+#define SRX_VTY_HLP_POL_LOCP_S "To be subtracted from the given local pref\n"
+
+#define SRX_VTY_CMD_POL_LOCP      "srx policy local-preference"
+#define SRX_VTY_CMD_POL_LOCP_FIX  SRX_VTY_CMD_POL_LOCP \
+                                  " (valid|unknown|invalid) <0-4294967295>"
+#define SRX_VTY_HLP_POL_LOCP_FIX  SRX_VTY_HLP_STR SRX_VTY_HLP_POLICY \
+                                  SRX_VTY_HLP_POL_LOCP \
+                                  SRX_VTY_HLP_POL_LOCP_V \
+                                  SRX_VTY_HLP_POL_LOCP_U \
+                                  SRX_VTY_HLP_POL_LOCP_I \
+                                  "The local preference value.\n"
+
+#define SRX_VTY_CMD_POL_LOCP_VAR  SRX_VTY_CMD_POL_LOCP_FIX \
+                                  " (add|subtract)"
+#define SRX_VTY_HLP_POL_LOCP_VAR  SRX_VTY_HLP_POL_LOCP_FIX \
+                                  SRX_VTY_HLP_POL_LOCP_A \
+                                  SRX_VTY_HLP_POL_LOCP_S
+
+#define SRX_VTY_CMD_NO_POL_LOCP   "no " SRX_VTY_CMD_POL_LOCP \
+                                  " (valid|unknown|invalid)"
+#define SRX_VTY_HLP_NO_POL_LOCP   NO_STR SRX_VTY_HLP_STR SRX_VTY_HLP_POLICY \
+                                  SRX_VTY_HLP_POL_LOCP \
+                                  SRX_VTY_HLP_POL_LOCP_V \
+                                  SRX_VTY_HLP_POL_LOCP_U \
+                                  SRX_VTY_HLP_POL_LOCP_I \
+
+
+
+// POLICY PREFER-VALID
+#define SRX_VTY_CMD_POL_PREFV "srx policy prefer-valid"
+#define SRX_VTY_OUT_POL_PREFV SRX_VTY_CMD_POL_PREFV "%s"
+#define SRX_VTY_HLP_POL_PREFV SRX_VTY_HLP_STR SRX_VTY_HLP_POLICY \
+                              "Use the validation state as tie breaker " \
+                              "with valid > any other\n" 
+#endif
+
 /* Typedef BGP specific types.  */
 typedef u_int32_t as_t;
 typedef u_int16_t as16_t; /* we may still encounter 16 Bit asnums */
@@ -61,6 +193,20 @@
 #define BGP_OPT_CONFIG_CISCO             (1 << 2)
 };
 
+#ifdef USE_SRX
+/** Data stored in this structure defines how the local pref has to be 
+ * manipulated. 
+ */
+struct srx_local_pref {
+  // Indicated if the local pref has to be manipulated.
+  int      is_set;
+  // If set then add or delete the given value from the the local pref.
+  int      relative;
+  // the local pref value
+  uint32_t value;
+};
+#endif
+
 /* BGP instance structure.  */
 struct bgp 
 {
@@ -91,6 +237,20 @@
 #define BGP_CONFIG_CLUSTER_ID             (1 << 1)
 #define BGP_CONFIG_CONFEDERATION          (1 << 2)
 
+#ifdef USE_SRX
+#define BGP_CONFIG_SRX                    (1 << 3)
+  
+  /* SRX Configuration */
+  u_int16_t srx_config;
+#define SRX_CONFIG_EVAL_ORIGIN   (1 << 1)
+// Below must be set in combination with VALORIGIN
+#define SRX_CONFIG_EVAL_PATH     (1 << 2)
+#define SRX_CONFIG_EVALUATE      (SRX_CONFIG_EVAL_ORIGIN | SRX_CONFIG_EVAL_PATH)
+  
+#define SRX_CONFIG_DISPLAY_INFO  (1 << 3)
+#endif
+
+  
   /* BGP router identifier.  */
   struct in_addr router_id;
   struct in_addr router_id_static;
@@ -162,6 +322,42 @@
   /* BGP graceful restart */
   u_int32_t restart_time;
   u_int32_t stalepath_time;
+
+#ifdef USE_SRX
+  /* Configuration */
+  // All the default configuration is set in the method srx_set_default
+  
+  char *srx_host;
+  int  srx_port;
+#define SRX_HANDHAKE_TIMEOUT  30
+#define SRX_KEEP_WINDOW      900
+#define SRX_PROXYID            1
+ 
+  // The timeout during the session establishment
+  int  srx_handshakeTimeout;
+  // Time in seconds the SRx server is requested to keep data after a delete
+  int  srx_keepWindow;
+  int  srx_proxyID;
+  /** The local pref values for [0]valid, [1]unknown, and [2]invalid*/
+  struct srx_local_pref  srx_val_local_pref[3];
+#define VAL_LOCPRF_VALID     0
+#define VAL_LOCPRF_UNKNOWN   1
+#define VAL_LOCPRF_INVALID   2
+
+  /** Contains the bit coded polixy setting*/
+  uint16_t srx_val_policy;
+#define SRX_VAL_POLICY_PREFER_VALID     (1 << 0)
+#define SRX_VAL_POLICY_IGNORE_UNKNOWN   (1 << 1) 
+#define SRX_VAL_POLICY_IGNORE_INVALID   (1 << 2)
+#define SRX_VAL_POLICY_IGNORE_UNDEFINED (1 << 3)
+
+  uint16_t srx_default_roaVal;
+  uint16_t srx_default_bgpsecVal;
+  
+  /* Instance variables */
+  SRxProxy* srxProxy;
+  struct bgp_info_hash *info_hash;
+#endif /* USE_SRX */
 };
 
 /* BGP peer-group support. */
@@ -868,6 +1064,22 @@
 extern int bgp_default_local_preference_set (struct bgp *, u_int32_t);
 extern int bgp_default_local_preference_unset (struct bgp *);
 
+#ifdef USE_SRX
+extern int bgp_srx_set (struct bgp *, const char *, int);
+extern int bgp_srx_unset (struct bgp *bgp);
+
+// does both, set and unset
+extern int bgp_srx_evaluation (struct bgp *, int);
+extern int bgp_srx_display (struct bgp *bgp, int);
+
+extern int srx_val_local_preference_set (struct bgp *, int, int, uint32_t);
+extern int srx_val_local_preference_unset (struct bgp *, int);
+extern int srx_val_policy_set (struct bgp *, uint16_t);
+extern int srx_val_policy_unset (struct bgp *, uint16_t);
+
+extern int srx_config_check (struct bgp *, uint16_t);
+#endif /* USE_SRX */
+
 extern int peer_rsclient_active (struct peer *);
 
 extern int peer_remote_as (struct bgp *, union sockunion *, as_t *, afi_t, safi_t);
@@ -952,5 +1164,4 @@
 
 extern int peer_clear (struct peer *);
 extern int peer_clear_soft (struct peer *, afi_t, safi_t, enum bgp_clear_type);
-
 #endif /* _QUAGGA_BGPD_H */
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./bgpd/bgp_route.c	2011-03-21 10:32:49.000000000 -0400
+++ ./bgpd/bgp_route.c	2011-10-06 12:15:57.000000000 -0400
@@ -55,6 +55,12 @@
 #include "bgpd/bgp_zebra.h"
 #include "bgpd/bgp_vty.h"
 
+#ifdef USE_SRX
+#include "srx/srx_defs.h"
+#include "srx/srx_api.h"
+
+#endif
+
 /* Extern from bgp_dump.c */
 extern const char *bgp_origin_str[];
 extern const char *bgp_origin_long_str[];
@@ -129,7 +135,21 @@
 static struct bgp_info *
 bgp_info_new (void)
 {
+#ifdef USE_SRX
+  struct bgp_info *new = XCALLOC (MTYPE_BGP_ROUTE, sizeof (struct bgp_info));
+  if (new)
+  {
+    new->node = NULL;
+    new->info_hash = NULL;
+    
+    new->updateID        = 0; // not specified yet  
+    new->val_res_ROA     = SRx_RESULT_UNDEFINED;
+    new->val_res_BGPSEC  = SRx_RESULT_UNDEFINED;
+  } 
+  return new;
+#else
   return XCALLOC (MTYPE_BGP_ROUTE, sizeof (struct bgp_info));
+#endif
 }
 
 /* Free bgp route information. */
@@ -143,6 +163,13 @@
 
   peer_unlock (binfo->peer); /* bgp_info peer reference */
 
+#ifdef USE_SRX
+  if (binfo->info_hash)
+  {
+    bgp_info_unregister (binfo->info_hash, binfo->updateID);
+  }
+#endif
+
   XFREE (MTYPE_BGP_ROUTE, binfo);
 }
 
@@ -193,6 +220,10 @@
     top->prev = ri;
   rn->info = ri;
   
+#ifdef USE_SRX
+  ri->node = rn;
+#endif
+  
   bgp_info_lock (ri);
   bgp_lock_node (rn);
   peer_lock (ri->peer); /* bgp_info peer reference */
@@ -298,6 +329,262 @@
   bgp_pcount_adjust (rn, ri);
 }
 
+#ifdef USE_SRX
+void bgp_info_set_identifier (struct bgp_info *info, 
+                              struct bgp_info_hash *info_hash, 
+                              SRxUpdateID updateID)
+{
+  info->info_hash = info_hash;
+  info->updateID  = updateID;
+}
+
+/** This method sets or frees the ignore flag depending on the system 
+ * configuration and the update validation state.
+ * 
+ * @param info the bgp update information
+ * 
+ * @return 0 if the ignore flag is not set.
+ *         1 if the ignore flag is set.
+ */
+int bgp_info_set_ignore_flag (struct bgp_info* info)
+{
+  int ignore;
+  struct bgp *bgp;
+  int valRes;
+  
+  ignore = 0;
+  bgp = info->peer->bgp;
+  valRes = srx_calc_validation_state(bgp, info);
+  
+  // check the setting ignore-invalid according to the result value
+  if (bgp->srx_config & SRX_CONFIG_EVALUATE)
+  {
+    switch (valRes)
+    {
+      case SRx_RESULT_INVALID:
+        if (bgp->srx_val_policy & SRX_VAL_POLICY_IGNORE_INVALID)
+        {
+          ignore = 1;
+        }
+        break;
+      case SRx_RESULT_UNKNOWN:
+        if (bgp->srx_val_policy & SRX_VAL_POLICY_IGNORE_UNKNOWN)
+        {
+          ignore = 1;
+        }
+        break;
+      case SRx_RESULT_UNDEFINED:
+        if (bgp->srx_val_policy & SRX_VAL_POLICY_IGNORE_UNDEFINED)
+        {
+          ignore = 1;
+        }
+      default:
+        break;          
+    }
+  }
+  else
+  {
+    if (ignore)
+    {
+      zlog_debug ("Evaluation disabled do not set ignore flag for update "
+                  "[0x%08X]!", info->updateID);
+      ignore = 0;
+    }
+  }
+    
+  /* Adjust 'ignore' flag */
+  // Is this flag an original Quagga flag? if so is it possible that we 
+  // overwrite a set flag by un-setting it? Should we use 
+  if (CHECK_FLAG (info->flags, BGP_INFO_IGNORE))
+  {
+    if (ignore == 0) 
+    {
+     // zlog_debug ("Remove 'Ignore' flag for update [0x%08X]!",
+     //             info->updateID);
+      bgp_info_unset_flag (info->node, info, BGP_INFO_IGNORE);
+    }
+  }
+  else if (ignore == 1)
+  {
+    //zlog_debug ("Setting 'Ignore' flag for update [0x%08X]!", 
+    //            info->updateID);
+    bgp_info_set_flag (info->node, info, BGP_INFO_IGNORE);
+  }
+  
+  return ignore;
+}
+
+/**
+ * This method determines the outcome of the validation result. Depending on the
+ * evaluation mode (no srx evaluation, srx evaluation bgpsec, or 
+ * srx evaluation origin_only the result of this method might change.
+ * 
+ * Possible results:
+ *   no srx evaluation:          SRx_RESULT_DONOTUSE
+ * 
+ *   srx evaluation bgpsec:      SRx_RESULT_VALID, SRx_RESULT_INVALID, 
+ *                               SRx_RESULT_UNDEFINED
+ *                               (valid requires path and origin validation to
+ *                               be valid, otherwise invalid!)
+ * 
+ *   srx evaluation origin_only: SRx_RESULT_VALID, SRx_RESULT_UNKNOWN, 
+ *                               SRx_RESULT_INVALID, SRx_RESULT_UNDEFINED
+ * 
+ * Result table for bgpsec:
+ * 
+ *   ORIGIN | V | U | i | ? |
+ * PATH     |   |   |   |   |
+ * ---------+---+---+---+---|
+ *  v       | v | i | i | ? |
+ * ---------+---+---+---+---|
+ *  i       | i | i | i | ? |
+ * ---------+---+---+---+---|
+ *  ?       | ? | ? | ? | ? |
+ * ---------+---+---+---+---+
+ * 
+ * @param bgp
+ * @param info
+ * 
+ * @return SRx_RESULT_VALID, SRx_RESULT_UNKNOWN, or SRx_RESULT_INVALID
+ */
+int srx_calc_validation_state(struct bgp *bgp, struct bgp_info *info)
+{
+  int result;
+  
+  result = SRx_RESULT_DONOTUSE;
+  
+  if (srx_config_check(bgp, SRX_CONFIG_EVAL_PATH))
+  { // BGPSEC validation is selected!
+    if (info->val_res_BGPSEC == SRx_RESULT_UNDEFINED)
+    {
+      result = SRx_RESULT_UNDEFINED;
+    }
+    else
+    {
+      switch (info->val_res_ROA)
+      {
+        case SRx_RESULT_VALID:
+          result = info->val_res_BGPSEC;
+          break;
+        case SRx_RESULT_UNKNOWN:
+        case SRx_RESULT_INVALID:
+          result = SRx_RESULT_INVALID;
+          break;
+        case SRx_RESULT_UNDEFINED:
+        default:
+          result = SRx_RESULT_INVALID;
+      }
+    }
+  }
+  else if (srx_config_check(bgp, SRX_CONFIG_EVAL_ORIGIN))
+  { // Prefix origin validation only!
+    result = info->val_res_ROA;
+  }
+  
+  return result;  
+}
+
+/**
+ * Add the given update back into the process queue.
+ * 
+ * @param info the BGP update.
+ */
+void srx_bgp_requeue_update(struct bgp_info *info)
+{
+  bgp_process (info->peer->bgp, info->node, info->node->table->afi, 
+               info->node->table->safi);  
+}
+
+/**
+ * Requeue all updates associated with this router. this method is used for the
+ * terminal command "srx apply-policy"
+ * 
+ * @param The bgp router
+ */
+void srx_bgp_requeue_all(struct bgp *bgp)
+{
+  struct bgp_table* table;
+  struct bgp_node *bnode;
+  
+  if (bgp != NULL)
+  {
+    table = bgp->rib[AFI_IP][SAFI_MULTICAST];
+    for (bnode = bgp_table_top(table); bnode; bnode = bgp_route_next(bnode))
+    {
+      if (bnode->info != NULL)
+      {
+        srx_bgp_requeue_update(bnode->info);
+      }
+    }
+    
+    table = bgp->rib[AFI_IP][SAFI_UNICAST];
+    for (bnode = bgp_table_top(table); bnode; bnode = bgp_route_next(bnode))
+    {
+      if (bnode->info != NULL)
+      {
+        srx_bgp_requeue_update(bnode->info);
+      }
+    }
+  } 
+}
+
+
+/** 
+ * Modifies the BGP update information according to the SRX settings.
+ * This will be done using the bgp_info data structure. 
+ * This method is called by the SRx callback to update the validation result.
+ * 
+ * In case if one result ROA / BGPSEC is UNDEFINED the update will by default be
+ * ignored.
+ * 
+ */
+void bgp_info_set_validation_result (struct bgp_info *info,   
+                                     ValidationResultType resType, 
+                                     uint8_t roaResult, uint8_t bgpsecResult)
+{
+  /* An internal error occurred */
+  if ((resType & SRX_FLAG_ROA_AND_BGPSEC) == 0)
+  {
+    zlog_debug ("No SRx result provided! - Update [0x%08X]", info->updateID);
+  }
+  else
+  {
+    struct bgp *bgp         = info->peer->bgp;
+    int requeue             = 0;
+    uint8_t oldResult       = srx_calc_validation_state(bgp, info);
+    //struct bgp_table *tbl;
+    
+ 
+    if ((resType & SRX_FLAG_ROA) != 0)
+    {
+//      zlog_debug ("SRx Validation result (Origin): Update [0x%08X], %d", 
+//                  info->updateID, roaResult);
+      info->val_res_ROA = roaResult;
+    }
+    if ((resType & SRX_FLAG_BGPSEC) != 0)
+    {
+//      zlog_debug ("SRx Validation result (Path)..: Update [0x%08X], %d", 
+//                  info->updateID, bgpsecResult);    
+      info->val_res_BGPSEC = roaResult;
+    } 
+    
+    // Check if it is fully valid and if not decide if the update has to be 
+    // ignored     
+    requeue = ((bgp_info_set_ignore_flag(info) > 0) ? 1 : 0)
+              || (oldResult != srx_calc_validation_state(bgp, info));
+
+    /* Re-initiate best selection by re-queuing  */
+    //tbl = info->node->table;
+    
+    if (requeue)
+    {
+      srx_bgp_requeue_update(info);
+      // bgp_process (bgp, info->node, tbl->afi, tbl->safi);
+    }    
+  }
+}
+#endif
+
 /* Get MED value.  If MED value is missing and "bgp bestpath
    missing-as-worst" is specified, treat it as the worst value. */
 static u_int32_t
@@ -314,6 +601,62 @@
     }
 }
 
+#ifdef USE_SRX
+
+/**
+ * This method caclulated the new local pref.
+ * 
+ * @param prefPol The local preference policy for the given result value.
+ * @param locPref The current local pref that needs to be modified.
+ * 
+ * @return The modified local preference (0 in case of an underflow).
+ */
+static u_int32_t srx_loc_prev_value(struct bgp* bgp, u_int32_t locPref, 
+                                    int valResult)
+{
+  struct srx_local_pref* prefPolicy;
+  bool isSet;
+  
+  switch (valResult)
+  {
+    case SRx_RESULT_VALID:
+      prefPolicy = &bgp->srx_val_local_pref[VAL_LOCPRF_VALID];
+      isSet = prefPolicy->is_set > 0;
+      break;
+    case SRx_RESULT_UNKNOWN:
+      prefPolicy = &bgp->srx_val_local_pref[SRx_RESULT_UNKNOWN];
+      isSet = prefPolicy->is_set > 0;
+      break;
+    case SRx_RESULT_INVALID:
+      prefPolicy = &bgp->srx_val_local_pref[VAL_LOCPRF_INVALID];
+      isSet = prefPolicy->is_set > 0;
+      break;
+    default:
+      prefPolicy = NULL;
+      isSet = false;
+  }
+  
+  if (isSet)
+  {
+    if (prefPolicy->relative == 0)
+    {
+      locPref = prefPolicy->value;
+    }
+    else if (prefPolicy->relative == -1)
+    {
+      locPref = (locPref > prefPolicy->value) ? (locPref - prefPolicy->value) 
+                                              : 0; // underflow
+    }
+    else
+    {
+      locPref += prefPolicy->value;
+    }
+  }
+  
+  return locPref;
+}
+#endif
+
 /* Compare two bgp route entity.  br is preferable then return 1. */
 static int
 bgp_info_cmp (struct bgp *bgp, struct bgp_info *new, struct bgp_info *exist)
@@ -331,6 +674,11 @@
   int internal_as_route = 0;
   int confed_as_route = 0;
   int ret;
+#ifdef USE_SRX
+  int use_evaluation = srx_config_check(bgp, SRX_CONFIG_EVALUATE);
+  int new_result = 0;
+  int exist_result = 0;
+#endif
 
   /* 0. Null check. */
   if (new == NULL)
@@ -338,6 +686,25 @@
   if (exist == NULL)
     return 1;
 
+#ifdef USE_SRX
+  if (use_evaluation)
+  {
+    /* 0.25 stop if ignore flag is set*/
+    // In case an update was received and declared to be ignored it is put back 
+    // into the queue but still will be processed here. This is the reason why 
+    // we have to double check here to assure the ignore state.
+    if (CHECK_FLAG (new->flags, BGP_INFO_IGNORE))
+    {
+      zlog_debug("Ignore update [0x%08X] in decision process!", new->updateID);
+      return 0;
+    }
+  
+    // Retrieve Result
+    exist_result = srx_calc_validation_state(bgp, exist);
+    new_result   = srx_calc_validation_state(bgp, new);
+  }
+#endif
+  
   /* 1. Weight check. */
   if (new->attr->extra)
     new_weight = new->attr->extra->weight;
@@ -359,11 +726,38 @@
   else
     exist_pref = bgp->default_local_pref;
     
+#ifdef USE_SRX
+  if (use_evaluation)
+  {
+    /* Apply srx policy for local pref manipulation if applicable */
+    new_pref   = srx_loc_prev_value(bgp, new_pref, new_result);
+    exist_pref = srx_loc_prev_value(bgp, exist_pref, exist_result);    
+  }
+#endif
+   
   if (new_pref > exist_pref)
     return 1;
   if (new_pref < exist_pref)
     return 0;
 
+#ifdef USE_SRX
+  if (use_evaluation && CHECK_FLAG (bgp->srx_val_policy, 
+                                    SRX_VAL_POLICY_PREFER_VALID))
+  {        
+    /* 2.5. Prefer valid > everything else*/
+    
+    // Prefer VALID over Everything else!
+    if ((new_result == SRx_RESULT_VALID) && (exist_result != SRx_RESULT_VALID))
+    {
+      return 1;
+    }
+    if ((new_result != SRx_RESULT_VALID) && (exist_result == SRx_RESULT_VALID))
+    {
+      return 0;
+    }
+  }
+#endif  
+  
   /* 3. Local route check. */
   if (new->sub_type == BGP_ROUTE_STATIC)
     return 1;
@@ -910,6 +1304,19 @@
 	}
     }
   
+  /* AS-Pathlimit check */
+  if (ri->attr->pathlimit.ttl && peer_sort (peer) == BGP_PEER_EBGP)
+    /* Our ASN has not yet been pre-pended, that's done in packet_attribute
+     * on output. Hence the test here is for >=.
+     */
+    if (aspath_count_hops (ri->attr->aspath) >= ri->attr->pathlimit.ttl)
+      {
+        if (BGP_DEBUG (filter, FILTER))
+          zlog_info ("%s [Update:SEND] suppressed, AS-Pathlimit TTL %u exceeded",
+                     peer->host, ri->attr->pathlimit.ttl);
+        return 0;
+      }
+  
   /* For modify attribute, copy it to temporary structure. */
   bgp_attr_dup (attr, ri->attr);
   
@@ -1014,6 +1421,39 @@
     }
 #endif /* HAVE_IPV6 */
 
+  /* AS-Pathlimit: Check ASN for private/confed */
+  if (attr->pathlimit.ttl)
+    {
+      /* locally originated update */
+      if (!attr->pathlimit.as)
+        attr->pathlimit.as = peer->local_as;
+      
+      /* if the AS_PATHLIMIT attribute is attached to a prefix by a
+         member of a confederation, then when the prefix is advertised outside
+         of the confederation boundary, then the AS number of the
+         confederation member inside of the AS_PATHLIMIT attribute should be
+         replaced by the confederation's AS number. */
+      if (peer_sort (from) == BGP_PEER_CONFED 
+          && peer_sort (peer) != BGP_PEER_CONFED)
+        attr->pathlimit.as = peer->local_as;
+
+      /* Private ASN should be updated whenever announcement leaves
+       * private space. This is deliberately done after simple confed
+       * based update..
+       */
+      if (attr->pathlimit.as >= BGP_PRIVATE_AS_MIN
+          && attr->pathlimit.as <= BGP_PRIVATE_AS_MAX)
+        {
+          if (peer->local_as < BGP_PRIVATE_AS_MIN 
+              || peer->local_as > BGP_PRIVATE_AS_MAX)
+            attr->pathlimit.as = peer->local_as;
+          /* Ours is private, try using theirs.. */
+          else if (peer->as < BGP_PRIVATE_AS_MIN
+                   || peer->local_as > BGP_PRIVATE_AS_MAX)
+            attr->pathlimit.as = peer->as;
+        }
+    }
+  
   /* If this is EBGP peer and remove-private-AS is set.  */
   if (peer_sort (peer) == BGP_PEER_EBGP
       && peer_af_flag_check (peer, afi, safi, PEER_FLAG_REMOVE_PRIVATE_AS)
@@ -1568,13 +2008,14 @@
     }
   
   bm->process_main_queue->spec.workfunc = &bgp_process_main;
-  bm->process_main_queue->spec.del_item_data = &bgp_processq_del;
-  bm->process_main_queue->spec.max_retries = 0;
-  bm->process_main_queue->spec.hold = 50;
-  
-  memcpy (bm->process_rsclient_queue, bm->process_main_queue,
-          sizeof (struct work_queue *));
   bm->process_rsclient_queue->spec.workfunc = &bgp_process_rsclient;
+  bm->process_main_queue->spec.del_item_data = &bgp_processq_del;
+  bm->process_rsclient_queue->spec.del_item_data
+    =  bm->process_main_queue->spec.del_item_data;
+  bm->process_main_queue->spec.max_retries
+    = bm->process_main_queue->spec.max_retries = 0;
+  bm->process_rsclient_queue->spec.hold
+    = bm->process_main_queue->spec.hold = 50;
 }
 
 void
@@ -1973,69 +2414,286 @@
   bgp_unlock_node (rn);
 }
 
-static int
-bgp_update_main (struct peer *peer, struct prefix *p, struct attr *attr,
-	    afi_t afi, safi_t safi, int type, int sub_type,
-	    struct prefix_rd *prd, u_char *tag, int soft_reconfig)
+#ifdef USE_SRX
+static void prefix_to_IPPrefix (struct prefix* src, IPPrefix* dst)
 {
-  int ret;
-  int aspath_loop_count = 0;
-  struct bgp_node *rn;
-  struct bgp *bgp;
-  struct attr new_attr = { 0 };
-  struct attr *attr_new;
-  struct bgp_info *ri;
-  struct bgp_info *new;
-  const char *reason;
-  char buf[SU_ADDRSTRLEN];
+  dst->length = src->prefixlen;
 
-  bgp = peer->bgp;
-  rn = bgp_afi_node_get (bgp->rib[afi][safi], afi, safi, p, prd);
+#ifdef HAVE_UPV6
+  dst->ip.version = GET_VERSION_OF_AF (src->family);
+  memcpy (&dst->ip.addr, &src->u, 16);
+#else
+  dst->ip.version = 4;
+  dst->ip.addr.v4.u32 = src->u.prefix4.s_addr;
+#endif
+}
   
-  /* When peer's soft reconfiguration enabled.  Record input packet in
-     Adj-RIBs-In.  */
-  if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SOFT_RECONFIG)
-      && peer != bgp->peer_self && ! soft_reconfig)
-    bgp_adj_in_set (rn, peer, attr);
+/**
+ * This method is responsible for filling the bgpsec data array.
+ * 
+ * CURRENTLY: This method does nothing.
+ * 
+ * @param info The bgp update 
+ * @param bgpsec The data object to be filled.
+ */
+static BGPSecData* srx_create_bgpsec_data (struct bgp_info* info)
+{
+  struct attr* attr = info->attr;
+  struct assegment* pathSeg;
+  BGPSecData* bgpsec = malloc(sizeof(BGPSecData));
+  int dataIdx, segIdx, val;
 
-  /* Check previously received route. */
-  for (ri = rn->info; ri; ri = ri->next)
-    if (ri->peer == peer && ri->type == type && ri->sub_type == sub_type)
-      break;
+  bgpsec->length = 0;
+  bgpsec->data = NULL;  
 
-  /* AS path local-as loop check. */
-  if (peer->change_local_as)
+  if (attr->aspath != NULL)
     {
-      if (! CHECK_FLAG (peer->flags, PEER_FLAG_LOCAL_AS_NO_PREPEND))
-	aspath_loop_count = 1;
+    dataIdx = 0;
 
-      if (aspath_loop_check (attr->aspath, peer->change_local_as) > aspath_loop_count) 
+    // take the last element in each segment. At the end the origin is 
+    // written in the oas value.
+    
+    for (pathSeg = attr->aspath->segments; pathSeg; pathSeg = pathSeg->next)
 	{
-	  reason = "as-path contains our own AS;";
-	  goto filtered;
+      if (pathSeg->type == AS_SEQUENCE)
+      {
+        // calculate size needed
+        bgpsec->length += (pathSeg->length*4);        
+        // Prepare memory
+        if (bgpsec->data == NULL)
+        {
+          bgpsec->data = malloc(bgpsec->length);          
 	}
+        else
+        {
+          bgpsec->data = realloc(bgpsec, bgpsec->length);          
     }
-
-  /* AS path loop check. */
-  if (aspath_loop_check (attr->aspath, bgp->as) > peer->allowas_in[afi][safi]
-      || (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION)
-	  && aspath_loop_check(attr->aspath, bgp->confed_id)
-	  > peer->allowas_in[afi][safi]))
+        // Fill array
+        for (segIdx = 0;segIdx < pathSeg->length; segIdx++)
     {
-      reason = "as-path contains our own AS;";
-      goto filtered;
+          val = htonl(pathSeg->as[segIdx]);
+          bgpsec->data[dataIdx++] = (uint8_t)(val >> 24);
+          bgpsec->data[dataIdx++] = (uint8_t)(val >> 16);
+          bgpsec->data[dataIdx++] = (uint8_t)(val >> 8);
+          bgpsec->data[dataIdx++] = (uint8_t)(val);
+        }        
+      }
+    }
     }
 
-  /* Route reflector originator ID check.  */
-  if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_ORIGINATOR_ID)
-      && IPV4_ADDR_SAME (&bgp->router_id, &attr->extra->originator_id))
-    {
-      reason = "originator is us;";
-      goto filtered;
+  return bgpsec;
     }
 
-  /* Route reflector cluster ID check.  */
-  if (bgp_cluster_filter (peer, attr))
+/**
+ * Frees the memory allocated by the bgpsec object.
+ * 
+ * @param bgpsec the object to be freed. Including the internal data structure.
+ */
+static void srx_free_bgpsec_data (BGPSecData* bgpsec)
+{
+  // First reset the inner data
+  if (bgpsec->data != NULL)
+  {
+    free(bgpsec->data);
+  }
+  bgpsec->length = 0;
+  // now free external data.  
+  free(bgpsec);
+}
+
+/** This method is called to start an update verification. If the update info
+ * contains an updateID different than zero "0" no receipt will be requested.
+ * Otherwise a receipt will be requested.
+ * 
+ * By default the result values are set to the default value excpet the default
+ * value uses the SRx_RESULT_DONOTUSE option.
+ * 
+ * @param bgp a pointer to the bgp configuration
+ * @param info pointer to the update information
+ * @param defResult The default result provided.
+ * @param forceReceipt if set a receipt will be requested, if not a receipt
+ *                     will only be requested for updates without a valid 
+ *                     update id (valid update > 0)
+ */
+void verify_update (struct bgp *bgp, struct bgp_info *info, 
+                    SRxDefaultResult* defResult, bool forceReceipt)
+{
+  // first use the default result value.
+  if (defResult->result.roaResult != SRx_RESULT_DONOTUSE)
+  {
+    info->val_res_ROA = defResult->result.roaResult;
+  }
+  if (defResult->result.bgpsecResult != SRx_RESULT_DONOTUSE)
+  {
+    info->val_res_BGPSEC = defResult->result.bgpsecResult;
+  }
+  
+  // Now let proxy change it if necessary
+  if (bgp->srxProxy != NULL)
+  {
+    as_t oas;
+    int useResult;
+    
+    useResult = 0;
+    
+    // let SRx proxy initiate validation and get the update id */
+    oas = aspath_origin_as (info->attr->aspath);
+    if (oas > 0)
+    {
+      // Prepare the prefix
+      IPPrefix* prefix = malloc(sizeof(IPPrefix));
+      prefix_to_IPPrefix (&info->node->p, prefix);
+
+      // Will be initialized and filled by SRx (proxy)
+      SRxValidationResult* valResult = malloc(sizeof(SRxValidationResult));
+      
+      // Generate BGPSEC data currently no data at all, here is a good place
+      // to add at least the AS path
+      BGPSecData* bgpsec = srx_create_bgpsec_data(info);
+      
+      SRxVerifyFlag method = SRX_FLAG_ROA_AND_BGPSEC;
+      
+      if (forceReceipt || (info->updateID == 0))
+      //if (forceReceipt)
+      {
+        // the update does not contain an id => receipt from srx is required.        
+        method |= SRX_FLAG_REQUEST_RECEIPT;
+      }
+      
+      if (verifyUpdate (bgp->srxProxy, valResult, method, defResult, prefix, 
+                        oas, bgpsec) == NULL)
+      {
+        // Validation was not successful!
+        if (isConnected(bgp->srxProxy))
+        {
+          // A fatal error occurred within SRx
+          zlog_err ("ERROR: SRx verify failed for to verify!!");
+        }
+//        else
+//        {
+//          // No connection to SRx
+//          zlog_debug("Verification not possible, not connected to SRx server!");
+//        }
+      }
+      else
+      {  
+        if (info->updateID != 0 )
+        {
+          if (info->updateID == valResult->updateID)
+          {
+            useResult = 1;
+          }
+          else
+          {
+            zlog_err ("Verification request for update id [0x%08X] returned "
+                      "update id [0x%08X]! Disregard result!", info->updateID,
+                      valResult->updateID);
+          }                    
+        }
+        else
+        {          
+          // Set the validation result
+          useResult = 1;
+          /* Register in info hash */
+          info->updateID = valResult->updateID;
+          bgp_info_register (bgp->info_hash, info,info->updateID);
+
+	  srx_api_sem_post(bgp->srxProxy, method);
+
+	  zlog_debug("Update [0x%08X] registered!", info->updateID);
+        }
+      }
+
+      // Check if the new proxy result has to be used
+      if (useResult == 1)
+      {
+        if (valResult->valResult.roaResult != SRx_RESULT_DONOTUSE)
+        {
+          info->val_res_ROA = valResult->valResult.roaResult;
+        }
+        if (valResult->valResult.bgpsecResult != SRx_RESULT_DONOTUSE)
+        {
+          info->val_res_BGPSEC = valResult->valResult.bgpsecResult;
+        }        
+      }
+      srx_free_bgpsec_data(bgpsec);
+      free(valResult);
+      free(prefix);
+    }
+  }
+  
+  // Check if update has to be ignored!
+  bgp_info_set_ignore_flag(info);
+//  if (bgp_info_set_ignore_flag (info) > 0)
+//  {
+//    zlog_debug ("Update [0x%08X] will be ignored!", info->updateID);
+//  }
+}
+#endif
+
+static int
+bgp_update_main (struct peer *peer, struct prefix *p, struct attr *attr,
+	    afi_t afi, safi_t safi, int type, int sub_type,
+	    struct prefix_rd *prd, u_char *tag, int soft_reconfig)
+{
+  int ret;
+  int aspath_loop_count = 0;
+  struct bgp_node *rn;
+  struct bgp *bgp;
+  struct attr new_attr = { 0 };
+  struct attr *attr_new;
+  struct bgp_info *ri;
+  struct bgp_info *new;
+  const char *reason;
+  char buf[SU_ADDRSTRLEN];
+
+  bgp = peer->bgp;
+  rn = bgp_afi_node_get (bgp->rib[afi][safi], afi, safi, p, prd);
+  
+  /* When peer's soft reconfiguration enabled.  Record input packet in
+     Adj-RIBs-In.  */
+  if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SOFT_RECONFIG)
+      && peer != bgp->peer_self && ! soft_reconfig)
+    bgp_adj_in_set (rn, peer, attr);
+
+  /* Check previously received route. */
+  for (ri = rn->info; ri; ri = ri->next)
+    if (ri->peer == peer && ri->type == type && ri->sub_type == sub_type)
+      break;
+
+  /* AS path local-as loop check. */
+  if (peer->change_local_as)
+    {
+      if (! CHECK_FLAG (peer->flags, PEER_FLAG_LOCAL_AS_NO_PREPEND))
+	aspath_loop_count = 1;
+
+      if (aspath_loop_check (attr->aspath, peer->change_local_as) > aspath_loop_count) 
+	{
+	  reason = "as-path contains our own AS;";
+	  goto filtered;
+	}
+    }
+
+  /* AS path loop check. */
+  if (aspath_loop_check (attr->aspath, bgp->as) > peer->allowas_in[afi][safi]
+      || (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION)
+	  && aspath_loop_check(attr->aspath, bgp->confed_id)
+	  > peer->allowas_in[afi][safi]))
+    {
+      reason = "as-path contains our own AS;";
+      goto filtered;
+    }
+
+  /* Route reflector originator ID check.  */
+  if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_ORIGINATOR_ID)
+      && IPV4_ADDR_SAME (&bgp->router_id, &attr->extra->originator_id))
+    {
+      reason = "originator is us;";
+      goto filtered;
+    }
+
+  /* Route reflector cluster ID check.  */
+  if (bgp_cluster_filter (peer, attr))
     {
       reason = "reflected from the same cluster;";
       goto  filtered;
@@ -2265,6 +2923,23 @@
   /* Register new BGP information. */
   bgp_info_add (rn, new);
   
+#ifdef USE_SRX
+  /* Verify */
+    
+  // Here use the value of community String
+  SRxDefaultResult* defRes = malloc(sizeof(SRxDefaultResult));
+  // Here fill with community string value if possible, the use as source 
+  // SRxRS_IGP or a source provided by community string.
+  
+  // TODO: Use Community String value if available
+  defRes->resSourceROA        = SRxRS_ROUTER;
+  defRes->resSourceBGPSEC     = SRxRS_ROUTER;
+  defRes->result.roaResult    = bgp->srx_default_roaVal;
+  defRes->result.bgpsecResult = bgp->srx_default_bgpsecVal;
+  verify_update (bgp, new, defRes, false);
+  free(defRes);
+#endif
+  
   /* route_node_get lock */
   bgp_unlock_node (rn);
   
@@ -2368,6 +3043,15 @@
     if (ri->peer == peer && ri->type == type && ri->sub_type == sub_type)
       break;
 
+#ifdef USE_SRX
+  if (ri->updateID != 0)
+  {
+    // Only remove the update if it is registered with SRx server.
+    zlog_debug("withdraw update [0x%08X] from SRx server!", ri->updateID);
+    deleteUpdate(bgp->srxProxy, bgp->srx_keepWindow, &ri->updateID);
+  }
+#endif   
+
   /* Withdraw specified route from routing table. */
   if (ri && ! CHECK_FLAG (ri->flags, BGP_INFO_HISTORY))
     bgp_rib_withdraw (rn, ri, peer, afi, safi);
@@ -3192,6 +3876,14 @@
   attr.med = bgp_static->igpmetric;
   attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);
   
+  if (bgp_static->ttl)
+    {
+      attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_AS_PATHLIMIT);
+      attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE);
+      attr.pathlimit.as = 0;
+      attr.pathlimit.ttl = bgp_static->ttl;
+    }
+  
   if (bgp_static->atomic)
     attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE);
   
@@ -3226,7 +3918,7 @@
   else
     attr_new = bgp_attr_intern (&attr);
   
-  bgp_attr_dup(&new_attr, attr_new);
+  new_attr = *attr_new;
   
   SET_FLAG (bgp->peer_self->rmap_type, PEER_RMAP_TYPE_NETWORK);
 
@@ -3255,7 +3947,6 @@
 
   bgp_attr_unintern (attr_new);
   attr_new = bgp_attr_intern (&new_attr);
-  bgp_attr_extra_free (&new_attr);
 
   for (ri = rn->info; ri; ri = ri->next)
     if (ri->peer == bgp->peer_self && ri->type == ZEBRA_ROUTE_BGP
@@ -3341,6 +4032,14 @@
   attr.med = bgp_static->igpmetric;
   attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);
 
+  if (bgp_static->ttl)
+    {
+      attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_AS_PATHLIMIT);
+      attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE);
+      attr.pathlimit.as = 0;
+      attr.pathlimit.ttl = bgp_static->ttl;
+    }
+
   if (bgp_static->atomic)
     attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE);
 
@@ -3456,8 +4155,8 @@
 }
 
 static void
-bgp_static_update_vpnv4 (struct bgp *bgp, struct prefix *p, afi_t afi,
-			 safi_t safi, struct prefix_rd *prd, u_char *tag)
+bgp_static_update_vpnv4 (struct bgp *bgp, struct prefix *p, u_int16_t afi,
+			 u_char safi, struct prefix_rd *prd, u_char *tag)
 {
   struct bgp_node *rn;
   struct bgp_info *new;
@@ -3537,8 +4236,8 @@
 }
 
 static void
-bgp_static_withdraw_vpnv4 (struct bgp *bgp, struct prefix *p, afi_t afi,
-			   safi_t safi, struct prefix_rd *prd, u_char *tag)
+bgp_static_withdraw_vpnv4 (struct bgp *bgp, struct prefix *p, u_int16_t afi,
+			   u_char safi, struct prefix_rd *prd, u_char *tag)
 {
   struct bgp_node *rn;
   struct bgp_info *ri;
@@ -3564,17 +4263,44 @@
   bgp_unlock_node (rn);
 }
 
+static void
+bgp_pathlimit_update_parents (struct bgp *bgp, struct bgp_node *rn,
+                              int ttl_edge)
+{
+  struct bgp_node *parent = rn;
+  struct bgp_static *sp;
+  
+  /* Existing static changed TTL, search parents and adjust their atomic */
+  while ((parent = parent->parent))
+    if ((sp = parent->info))
+      {
+        int sp_level = (sp->atomic ? 1 : 0);
+        ttl_edge ? sp->atomic++ : sp->atomic--;
+        
+        /* did we change state of parent whether atomic is set or not? */
+        if (sp_level != (sp->atomic ? 1 : 0))
+          {
+            bgp_static_update (bgp, &parent->p, sp,
+                               rn->table->afi, rn->table->safi);
+          }
+      }
+}
+
 /* Configure static BGP network.  When user don't run zebra, static
    route should be installed as valid.  */
 static int
 bgp_static_set (struct vty *vty, struct bgp *bgp, const char *ip_str, 
-                afi_t afi, safi_t safi, const char *rmap, int backdoor)
+                u_int16_t afi, u_char safi, const char *rmap, int backdoor,
+                u_char ttl)
 {
   int ret;
   struct prefix p;
   struct bgp_static *bgp_static;
   struct bgp_node *rn;
   u_char need_update = 0;
+  u_char ttl_change = 0;
+  u_char ttl_edge = (ttl ? 1 : 0);
+  u_char new = 0;
 
   /* Convert IP prefix string to struct prefix. */
   ret = str2prefix (ip_str, &p);
@@ -3603,10 +4329,21 @@
       bgp_static = rn->info;
 
       /* Check previous routes are installed into BGP.  */
-      if (bgp_static->valid && bgp_static->backdoor != backdoor)
+      if (bgp_static->valid)
+        {
+          if (bgp_static->backdoor != backdoor
+              || bgp_static->ttl != ttl)
         need_update = 1;
+        }
+      
+      /* need to catch TTL set/unset transitions for handling of
+       * ATOMIC_AGGREGATE 
+       */ 
+      if ((bgp_static->ttl ? 1 : 0) != ttl_edge)
+        ttl_change = 1;
       
       bgp_static->backdoor = backdoor;
+      bgp_static->ttl = ttl;
       
       if (rmap)
 	{
@@ -3633,6 +4370,9 @@
       bgp_static->valid = 0;
       bgp_static->igpmetric = 0;
       bgp_static->igpnexthop.s_addr = 0;
+      bgp_static->ttl = ttl;
+      ttl_change = ttl_edge;
+      new = 1;
       
       if (rmap)
 	{
@@ -3644,6 +4384,39 @@
       rn->info = bgp_static;
     }
 
+  /* ".. sites that choose to advertise the
+   *  AS_PATHLIMIT path attribute SHOULD advertise the ATOMIC_AGGREGATE on
+   *  all less specific covering prefixes as well as the more specific
+   *  prefixes."
+   *
+   * So:
+   * Prefix that has just had pathlimit set/unset:
+   * - Must bump ATOMIC refcount on all parents.
+   *
+   * To catch less specific prefixes:
+   * - Must search children for ones with TTL, bump atomic refcount
+   *   (we dont care if we're deleting a less specific prefix..)
+   */
+  if (ttl_change)
+    {
+      /* Existing static changed TTL, search parents and adjust their atomic */
+      bgp_pathlimit_update_parents (bgp, rn, ttl_edge);
+    }
+  
+  if (new)
+    {
+      struct bgp_node *child;
+      struct bgp_static *sc;
+      
+      /* New static, search children and bump this statics atomic.. */
+      child = bgp_lock_node (rn); /* route_next_until unlocks it.. */
+      while ((child = bgp_route_next_until (child, rn)))
+        {
+          if ((sc = child->info) && sc->ttl)
+            bgp_static->atomic++;
+        }
+    }
+  
   /* If BGP scan is not enabled, we should install this route here.  */
   if (! bgp_flag_check (bgp, BGP_FLAG_IMPORT_CHECK))
     {
@@ -3662,7 +4435,7 @@
 /* Configure static BGP network. */
 static int
 bgp_static_unset (struct vty *vty, struct bgp *bgp, const char *ip_str,
-		  afi_t afi, safi_t safi)
+		  u_int16_t afi, u_char safi)
 {
   int ret;
   struct prefix p;
@@ -3697,6 +4470,9 @@
 
   bgp_static = rn->info;
   
+  /* decrement atomic in parents, see bgp_static_set */
+  bgp_pathlimit_update_parents (bgp, rn, 0);
+  
   /* Update BGP RIB. */
   if (! bgp_static->backdoor)
     bgp_static_withdraw (bgp, &p, afi, safi);
@@ -3893,10 +4669,23 @@
        "Specify a network to announce via BGP\n"
        "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
 {
+  u_char ttl = 0;
+  
+  if (argc == 2)
+    VTY_GET_INTEGER_RANGE ("Pathlimit TTL", ttl, argv[1], 1, 255);
+  
   return bgp_static_set (vty, vty->index, argv[0],
-			 AFI_IP, bgp_node_safi (vty), NULL, 0);
+			 AFI_IP, bgp_node_safi (vty), NULL, 0, ttl);
 }
 
+ALIAS (bgp_network,
+       bgp_network_ttl_cmd,
+       "network A.B.C.D/M pathlimit <0-255>",
+       "Specify a network to announce via BGP\n"
+       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
+       "AS-Path hopcount limit attribute\n"
+       "AS-Pathlimit TTL, in number of AS-Path hops\n")
+
 DEFUN (bgp_network_route_map,
        bgp_network_route_map_cmd,
        "network A.B.C.D/M route-map WORD",
@@ -3906,7 +4695,7 @@
        "Name of the route map\n")
 {
   return bgp_static_set (vty, vty->index, argv[0],
-			 AFI_IP, bgp_node_safi (vty), argv[1], 0);
+			 AFI_IP, bgp_node_safi (vty), argv[1], 0, 0);
 }
 
 DEFUN (bgp_network_backdoor,
@@ -3916,10 +4705,24 @@
        "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
        "Specify a BGP backdoor route\n")
 {
+  u_char ttl = 0;
+  
+  if (argc == 2)
+    VTY_GET_INTEGER_RANGE ("Pathlimit TTL", ttl, argv[1], 1, 255);
+  
   return bgp_static_set (vty, vty->index, argv[0], AFI_IP, SAFI_UNICAST,
-                         NULL, 1);
+                         NULL, 1, ttl);
 }
 
+ALIAS (bgp_network_backdoor,
+       bgp_network_backdoor_ttl_cmd,
+       "network A.B.C.D/M backdoor pathlimit <0-255>",
+       "Specify a network to announce via BGP\n"
+       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
+       "Specify a BGP backdoor route\n"
+       "AS-Path hopcount limit attribute\n"
+       "AS-Pathlimit TTL, in number of AS-Path hops\n")
+
 DEFUN (bgp_network_mask,
        bgp_network_mask_cmd,
        "network A.B.C.D mask A.B.C.D",
@@ -3930,6 +4733,10 @@
 {
   int ret;
   char prefix_str[BUFSIZ];
+  u_char ttl = 0;
+  
+  if (argc == 3)
+    VTY_GET_INTEGER_RANGE ("Pathlimit TTL", ttl, argv[2], 1, 255);
   
   ret = netmask_str2prefix_str (argv[0], argv[1], prefix_str);
   if (! ret)
@@ -3939,9 +4746,19 @@
     }
 
   return bgp_static_set (vty, vty->index, prefix_str,
-			 AFI_IP, bgp_node_safi (vty), NULL, 0);
+			 AFI_IP, bgp_node_safi (vty), NULL, 0, ttl);
 }
 
+ALIAS (bgp_network_mask,
+       bgp_network_mask_ttl_cmd,
+       "network A.B.C.D mask A.B.C.D pathlimit <0-255>",
+       "Specify a network to announce via BGP\n"
+       "Network number\n"
+       "Network mask\n"
+       "Network mask\n"
+       "AS-Path hopcount limit attribute\n"
+       "AS-Pathlimit TTL, in number of AS-Path hops\n")
+
 DEFUN (bgp_network_mask_route_map,
        bgp_network_mask_route_map_cmd,
        "network A.B.C.D mask A.B.C.D route-map WORD",
@@ -3963,7 +4780,7 @@
     }
 
   return bgp_static_set (vty, vty->index, prefix_str,
-			 AFI_IP, bgp_node_safi (vty), argv[2], 0);
+			 AFI_IP, bgp_node_safi (vty), argv[2], 0, 0);
 }
 
 DEFUN (bgp_network_mask_backdoor,
@@ -3977,6 +4794,10 @@
 {
   int ret;
   char prefix_str[BUFSIZ];
+  u_char ttl = 0;
+  
+  if (argc == 3)
+    VTY_GET_INTEGER_RANGE ("Pathlimit TTL", ttl, argv[2], 1, 255);
   
   ret = netmask_str2prefix_str (argv[0], argv[1], prefix_str);
   if (! ret)
@@ -3986,9 +4807,20 @@
     }
 
   return bgp_static_set (vty, vty->index, prefix_str, AFI_IP, SAFI_UNICAST,
-                         NULL, 1);
+                         NULL, 1, ttl);
 }
 
+ALIAS (bgp_network_mask_backdoor,
+       bgp_network_mask_backdoor_ttl_cmd,
+       "network A.B.C.D mask A.B.C.D backdoor pathlimit <0-255>",
+       "Specify a network to announce via BGP\n"
+       "Network number\n"
+       "Network mask\n"
+       "Network mask\n"
+       "Specify a BGP backdoor route\n"
+       "AS-Path hopcount limit attribute\n"
+       "AS-Pathlimit TTL, in number of AS-Path hops\n")
+
 DEFUN (bgp_network_mask_natural,
        bgp_network_mask_natural_cmd,
        "network A.B.C.D",
@@ -3997,6 +4829,10 @@
 {
   int ret;
   char prefix_str[BUFSIZ];
+  u_char ttl = 0;
+  
+  if (argc == 2)
+    VTY_GET_INTEGER_RANGE ("Pathlimit TTL", ttl, argv[1], 1, 255);
 
   ret = netmask_str2prefix_str (argv[0], NULL, prefix_str);
   if (! ret)
@@ -4006,9 +4842,17 @@
     }
 
   return bgp_static_set (vty, vty->index, prefix_str,
-			 AFI_IP, bgp_node_safi (vty), NULL, 0);
+			 AFI_IP, bgp_node_safi (vty), NULL, 0, ttl);
 }
 
+ALIAS (bgp_network_mask_natural,
+       bgp_network_mask_natural_ttl_cmd,
+       "network A.B.C.D pathlimit <0-255>",
+       "Specify a network to announce via BGP\n"
+       "Network number\n"
+       "AS-Path hopcount limit attribute\n"
+       "AS-Pathlimit TTL, in number of AS-Path hops\n")
+
 DEFUN (bgp_network_mask_natural_route_map,
        bgp_network_mask_natural_route_map_cmd,
        "network A.B.C.D route-map WORD",
@@ -4028,7 +4872,7 @@
     }
 
   return bgp_static_set (vty, vty->index, prefix_str,
-			 AFI_IP, bgp_node_safi (vty), argv[1], 0);
+			 AFI_IP, bgp_node_safi (vty), argv[1], 0, 0);
 }
 
 DEFUN (bgp_network_mask_natural_backdoor,
@@ -4040,6 +4884,10 @@
 {
   int ret;
   char prefix_str[BUFSIZ];
+  u_char ttl = 0;
+  
+  if (argc == 2)
+    VTY_GET_INTEGER_RANGE ("Pathlimit TTL", ttl, argv[1], 1, 255);
 
   ret = netmask_str2prefix_str (argv[0], NULL, prefix_str);
   if (! ret)
@@ -4049,9 +4897,18 @@
     }
 
   return bgp_static_set (vty, vty->index, prefix_str, AFI_IP, SAFI_UNICAST,
-                         NULL, 1);
+                         NULL, 1, ttl);
 }
 
+ALIAS (bgp_network_mask_natural_backdoor,
+       bgp_network_mask_natural_backdoor_ttl_cmd,
+       "network A.B.C.D backdoor pathlimit (1-255>",
+       "Specify a network to announce via BGP\n"
+       "Network number\n"
+       "Specify a BGP backdoor route\n"
+       "AS-Path hopcount limit attribute\n"
+       "AS-Pathlimit TTL, in number of AS-Path hops\n")
+
 DEFUN (no_bgp_network,
        no_bgp_network_cmd,
        "no network A.B.C.D/M",
@@ -4064,6 +4921,15 @@
 }
 
 ALIAS (no_bgp_network,
+       no_bgp_network_ttl_cmd,
+       "no network A.B.C.D/M pathlimit <0-255>",
+       NO_STR
+       "Specify a network to announce via BGP\n"
+       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
+       "AS-Path hopcount limit attribute\n"
+       "AS-Pathlimit TTL, in number of AS-Path hops\n")
+
+ALIAS (no_bgp_network,
        no_bgp_network_route_map_cmd,
        "no network A.B.C.D/M route-map WORD",
        NO_STR
@@ -4080,6 +4946,16 @@
        "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
        "Specify a BGP backdoor route\n")
 
+ALIAS (no_bgp_network,
+       no_bgp_network_backdoor_ttl_cmd,
+       "no network A.B.C.D/M backdoor pathlimit <0-255>",
+       NO_STR
+       "Specify a network to announce via BGP\n"
+       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
+       "Specify a BGP backdoor route\n"
+       "AS-Path hopcount limit attribute\n"
+       "AS-Pathlimit TTL, in number of AS-Path hops\n")
+
 DEFUN (no_bgp_network_mask,
        no_bgp_network_mask_cmd,
        "no network A.B.C.D mask A.B.C.D",
@@ -4103,6 +4979,17 @@
 			   bgp_node_safi (vty));
 }
 
+ALIAS (no_bgp_network,
+       no_bgp_network_mask_ttl_cmd,
+       "no network A.B.C.D mask A.B.C.D pathlimit <0-255>",
+       NO_STR
+       "Specify a network to announce via BGP\n"
+       "Network number\n"
+       "Network mask\n"
+       "Network mask\n"
+       "AS-Path hopcount limit attribute\n"
+       "AS-Pathlimit TTL, in number of AS-Path hops\n")
+
 ALIAS (no_bgp_network_mask,
        no_bgp_network_mask_route_map_cmd,
        "no network A.B.C.D mask A.B.C.D route-map WORD",
@@ -4124,6 +5011,18 @@
        "Network mask\n"
        "Specify a BGP backdoor route\n")
 
+ALIAS (no_bgp_network_mask,
+       no_bgp_network_mask_backdoor_ttl_cmd,
+       "no network A.B.C.D mask A.B.C.D  backdoor pathlimit <0-255>",
+       NO_STR
+       "Specify a network to announce via BGP\n"
+       "Network number\n"
+       "Network mask\n"
+       "Network mask\n"
+       "Specify a BGP backdoor route\n"
+       "AS-Path hopcount limit attribute\n"
+       "AS-Pathlimit TTL, in number of AS-Path hops\n")
+
 DEFUN (no_bgp_network_mask_natural,
        no_bgp_network_mask_natural_cmd,
        "no network A.B.C.D",
@@ -4162,6 +5061,25 @@
        "Network number\n"
        "Specify a BGP backdoor route\n")
 
+ALIAS (no_bgp_network_mask_natural,
+       no_bgp_network_mask_natural_ttl_cmd,
+       "no network A.B.C.D pathlimit <0-255>",
+       NO_STR
+       "Specify a network to announce via BGP\n"
+       "Network number\n"
+       "AS-Path hopcount limit attribute\n"
+       "AS-Pathlimit TTL, in number of AS-Path hops\n")
+
+ALIAS (no_bgp_network_mask_natural,
+       no_bgp_network_mask_natural_backdoor_ttl_cmd,
+       "no network A.B.C.D backdoor pathlimit <0-255>",
+       NO_STR
+       "Specify a network to announce via BGP\n"
+       "Network number\n"
+       "Specify a BGP backdoor route\n"
+       "AS-Path hopcount limit attribute\n"
+       "AS-Pathlimit TTL, in number of AS-Path hops\n")
+
 #ifdef HAVE_IPV6
 DEFUN (ipv6_bgp_network,
        ipv6_bgp_network_cmd,
@@ -4169,10 +5087,23 @@
        "Specify a network to announce via BGP\n"
        "IPv6 prefix <network>/<length>\n")
 {
+  u_char ttl = 0;
+  
+  if (argc == 2)
+    VTY_GET_INTEGER_RANGE ("Pathlimit TTL", ttl, argv[1], 1, 255);
+
   return bgp_static_set (vty, vty->index, argv[0], AFI_IP6, SAFI_UNICAST,
-                         NULL, 0);
+                         NULL, 0, ttl);
 }
 
+ALIAS (ipv6_bgp_network,
+       ipv6_bgp_network_ttl_cmd,
+       "network X:X::X:X/M pathlimit <0-255>",
+       "Specify a network to announce via BGP\n"
+       "IPv6 prefix <network>/<length>\n"
+       "AS-Path hopcount limit attribute\n"
+       "AS-Pathlimit TTL, in number of AS-Path hops\n")
+
 DEFUN (ipv6_bgp_network_route_map,
        ipv6_bgp_network_route_map_cmd,
        "network X:X::X:X/M route-map WORD",
@@ -4182,7 +5113,7 @@
        "Name of the route map\n")
 {
   return bgp_static_set (vty, vty->index, argv[0], AFI_IP6,
-			 bgp_node_safi (vty), argv[1], 0);
+			 bgp_node_safi (vty), argv[1], 0, 0);
 }
 
 DEFUN (no_ipv6_bgp_network,
@@ -4204,6 +5135,15 @@
        "Route-map to modify the attributes\n"
        "Name of the route map\n")
 
+ALIAS (no_ipv6_bgp_network,
+       no_ipv6_bgp_network_ttl_cmd,
+       "no network X:X::X:X/M pathlimit <0-255>",
+       NO_STR
+       "Specify a network to announce via BGP\n"
+       "IPv6 prefix <network>/<length>\n"
+       "AS-Path hopcount limit attribute\n"
+       "AS-Pathlimit TTL, in number of AS-Path hops\n")
+
 ALIAS (ipv6_bgp_network,
        old_ipv6_bgp_network_cmd,
        "ipv6 bgp network X:X::X:X/M",
@@ -4222,127 +5162,6 @@
        "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n")
 #endif /* HAVE_IPV6 */
 
-/* stubs for removed AS-Pathlimit commands, kept for config compatibility */
-ALIAS_DEPRECATED (bgp_network,
-       bgp_network_ttl_cmd,
-       "network A.B.C.D/M pathlimit <0-255>",
-       "Specify a network to announce via BGP\n"
-       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
-       "AS-Path hopcount limit attribute\n"
-       "AS-Pathlimit TTL, in number of AS-Path hops\n")
-ALIAS_DEPRECATED (bgp_network_backdoor,
-       bgp_network_backdoor_ttl_cmd,
-       "network A.B.C.D/M backdoor pathlimit <0-255>",
-       "Specify a network to announce via BGP\n"
-       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
-       "Specify a BGP backdoor route\n"
-       "AS-Path hopcount limit attribute\n"
-       "AS-Pathlimit TTL, in number of AS-Path hops\n")
-ALIAS_DEPRECATED (bgp_network_mask,
-       bgp_network_mask_ttl_cmd,
-       "network A.B.C.D mask A.B.C.D pathlimit <0-255>",
-       "Specify a network to announce via BGP\n"
-       "Network number\n"
-       "Network mask\n"
-       "Network mask\n"
-       "AS-Path hopcount limit attribute\n"
-       "AS-Pathlimit TTL, in number of AS-Path hops\n")
-ALIAS_DEPRECATED (bgp_network_mask_backdoor,
-       bgp_network_mask_backdoor_ttl_cmd,
-       "network A.B.C.D mask A.B.C.D backdoor pathlimit <0-255>",
-       "Specify a network to announce via BGP\n"
-       "Network number\n"
-       "Network mask\n"
-       "Network mask\n"
-       "Specify a BGP backdoor route\n"
-       "AS-Path hopcount limit attribute\n"
-       "AS-Pathlimit TTL, in number of AS-Path hops\n")
-ALIAS_DEPRECATED (bgp_network_mask_natural,
-       bgp_network_mask_natural_ttl_cmd,
-       "network A.B.C.D pathlimit <0-255>",
-       "Specify a network to announce via BGP\n"
-       "Network number\n"
-       "AS-Path hopcount limit attribute\n"
-       "AS-Pathlimit TTL, in number of AS-Path hops\n")
-ALIAS_DEPRECATED (bgp_network_mask_natural_backdoor,
-       bgp_network_mask_natural_backdoor_ttl_cmd,
-       "network A.B.C.D backdoor pathlimit (1-255>",
-       "Specify a network to announce via BGP\n"
-       "Network number\n"
-       "Specify a BGP backdoor route\n"
-       "AS-Path hopcount limit attribute\n"
-       "AS-Pathlimit TTL, in number of AS-Path hops\n")
-ALIAS_DEPRECATED (no_bgp_network,
-       no_bgp_network_ttl_cmd,
-       "no network A.B.C.D/M pathlimit <0-255>",
-       NO_STR
-       "Specify a network to announce via BGP\n"
-       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
-       "AS-Path hopcount limit attribute\n"
-       "AS-Pathlimit TTL, in number of AS-Path hops\n")
-ALIAS_DEPRECATED (no_bgp_network,
-       no_bgp_network_backdoor_ttl_cmd,
-       "no network A.B.C.D/M backdoor pathlimit <0-255>",
-       NO_STR
-       "Specify a network to announce via BGP\n"
-       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
-       "Specify a BGP backdoor route\n"
-       "AS-Path hopcount limit attribute\n"
-       "AS-Pathlimit TTL, in number of AS-Path hops\n")
-ALIAS_DEPRECATED (no_bgp_network,
-       no_bgp_network_mask_ttl_cmd,
-       "no network A.B.C.D mask A.B.C.D pathlimit <0-255>",
-       NO_STR
-       "Specify a network to announce via BGP\n"
-       "Network number\n"
-       "Network mask\n"
-       "Network mask\n"
-       "AS-Path hopcount limit attribute\n"
-       "AS-Pathlimit TTL, in number of AS-Path hops\n")
-ALIAS_DEPRECATED (no_bgp_network_mask,
-       no_bgp_network_mask_backdoor_ttl_cmd,
-       "no network A.B.C.D mask A.B.C.D  backdoor pathlimit <0-255>",
-       NO_STR
-       "Specify a network to announce via BGP\n"
-       "Network number\n"
-       "Network mask\n"
-       "Network mask\n"
-       "Specify a BGP backdoor route\n"
-       "AS-Path hopcount limit attribute\n"
-       "AS-Pathlimit TTL, in number of AS-Path hops\n")
-ALIAS_DEPRECATED (no_bgp_network_mask_natural,
-       no_bgp_network_mask_natural_ttl_cmd,
-       "no network A.B.C.D pathlimit <0-255>",
-       NO_STR
-       "Specify a network to announce via BGP\n"
-       "Network number\n"
-       "AS-Path hopcount limit attribute\n"
-       "AS-Pathlimit TTL, in number of AS-Path hops\n")
-ALIAS_DEPRECATED (no_bgp_network_mask_natural,
-       no_bgp_network_mask_natural_backdoor_ttl_cmd,
-       "no network A.B.C.D backdoor pathlimit <0-255>",
-       NO_STR
-       "Specify a network to announce via BGP\n"
-       "Network number\n"
-       "Specify a BGP backdoor route\n"
-       "AS-Path hopcount limit attribute\n"
-       "AS-Pathlimit TTL, in number of AS-Path hops\n")
-ALIAS_DEPRECATED (ipv6_bgp_network,
-       ipv6_bgp_network_ttl_cmd,
-       "network X:X::X:X/M pathlimit <0-255>",
-       "Specify a network to announce via BGP\n"
-       "IPv6 prefix <network>/<length>\n"
-       "AS-Path hopcount limit attribute\n"
-       "AS-Pathlimit TTL, in number of AS-Path hops\n")
-ALIAS_DEPRECATED (no_ipv6_bgp_network,
-       no_ipv6_bgp_network_ttl_cmd,
-       "no network X:X::X:X/M pathlimit <0-255>",
-       NO_STR
-       "Specify a network to announce via BGP\n"
-       "IPv6 prefix <network>/<length>\n"
-       "AS-Path hopcount limit attribute\n"
-       "AS-Pathlimit TTL, in number of AS-Path hops\n")
-
 /* Aggreagete address:
 
   advertise-map  Set condition to advertise attribute
@@ -4804,8 +5623,9 @@
 #define AGGREGATE_AS_SET       1
 
 static int
-bgp_aggregate_unset (struct vty *vty, const char *prefix_str,
-                     afi_t afi, safi_t safi)
+bgp_aggregate_set (struct vty *vty, const char *prefix_str, 
+                   afi_t afi, safi_t safi,
+		   u_char summary_only, u_char as_set)
 {
   int ret;
   struct prefix p;
@@ -4826,33 +5646,34 @@
   bgp = vty->index;
 
   /* Old configuration check. */
-  rn = bgp_node_lookup (bgp->aggregate[afi][safi], &p);
-  if (! rn)
+  rn = bgp_node_get (bgp->aggregate[afi][safi], &p);
+
+  if (rn->info)
     {
-      vty_out (vty, "%% There is no aggregate-address configuration.%s",
-               VTY_NEWLINE);
+      vty_out (vty, "There is already same aggregate network.%s", VTY_NEWLINE);
+      bgp_unlock_node (rn);
       return CMD_WARNING;
     }
 
-  aggregate = rn->info;
-  if (aggregate->safi & SAFI_UNICAST)
-    bgp_aggregate_delete (bgp, &p, afi, SAFI_UNICAST, aggregate);
-  if (aggregate->safi & SAFI_MULTICAST)
-    bgp_aggregate_delete (bgp, &p, afi, SAFI_MULTICAST, aggregate);
+  /* Make aggregate address structure. */
+  aggregate = bgp_aggregate_new ();
+  aggregate->summary_only = summary_only;
+  aggregate->as_set = as_set;
+  aggregate->safi = safi;
+  rn->info = aggregate;
 
-  /* Unlock aggregate address configuration. */
-  rn->info = NULL;
-  bgp_aggregate_free (aggregate);
-  bgp_unlock_node (rn);
-  bgp_unlock_node (rn);
+  /* Aggregate address insert into BGP routing table. */
+  if (safi & SAFI_UNICAST)
+    bgp_aggregate_add (bgp, &p, afi, SAFI_UNICAST, aggregate);
+  if (safi & SAFI_MULTICAST)
+    bgp_aggregate_add (bgp, &p, afi, SAFI_MULTICAST, aggregate);
 
   return CMD_SUCCESS;
 }
 
 static int
-bgp_aggregate_set (struct vty *vty, const char *prefix_str,
-                   afi_t afi, safi_t safi,
-		   u_char summary_only, u_char as_set)
+bgp_aggregate_unset (struct vty *vty, const char *prefix_str, 
+                     afi_t afi, safi_t safi)
 {
   int ret;
   struct prefix p;
@@ -4873,33 +5694,25 @@
   bgp = vty->index;
 
   /* Old configuration check. */
-  rn = bgp_node_get (bgp->aggregate[afi][safi], &p);
-
-  if (rn->info)
-    {
-      vty_out (vty, "There is already same aggregate network.%s", VTY_NEWLINE);
-      /* try to remove the old entry */
-      ret = bgp_aggregate_unset (vty, prefix_str, afi, safi);
-      if (ret)
+  rn = bgp_node_lookup (bgp->aggregate[afi][safi], &p);
+  if (! rn)
         {
-          vty_out (vty, "Error deleting aggregate.%s", VTY_NEWLINE);
-	  bgp_unlock_node (rn);
+      vty_out (vty, "%% There is no aggregate-address configuration.%s",
+	       VTY_NEWLINE);
 	  return CMD_WARNING;
         }
-    }
 
-  /* Make aggregate address structure. */
-  aggregate = bgp_aggregate_new ();
-  aggregate->summary_only = summary_only;
-  aggregate->as_set = as_set;
-  aggregate->safi = safi;
-  rn->info = aggregate;
+  aggregate = rn->info;
+  if (aggregate->safi & SAFI_UNICAST)
+    bgp_aggregate_delete (bgp, &p, afi, SAFI_UNICAST, aggregate);
+  if (aggregate->safi & SAFI_MULTICAST)
+    bgp_aggregate_delete (bgp, &p, afi, SAFI_MULTICAST, aggregate);
 
-  /* Aggregate address insert into BGP routing table. */
-  if (safi & SAFI_UNICAST)
-    bgp_aggregate_add (bgp, &p, afi, SAFI_UNICAST, aggregate);
-  if (safi & SAFI_MULTICAST)
-    bgp_aggregate_add (bgp, &p, afi, SAFI_MULTICAST, aggregate);
+  /* Unlock aggregate address configuration. */
+  rn->info = NULL;
+  bgp_aggregate_free (aggregate);
+  bgp_unlock_node (rn);
+  bgp_unlock_node (rn);
 
   return CMD_SUCCESS;
 }
@@ -5468,6 +6281,147 @@
   normal_list,
 };
 
+#ifdef USE_SRX
+
+
+/**
+ * Print the validation result v,i,u,?, or - depending on the state.
+ * 
+ * @param vty the output terminal
+ * @param state the validation state to be printed
+ */
+static void srx_validation_vty_short_out(struct vty *vty, int state)
+{
+  switch (state)
+  {
+    case SRx_RESULT_VALID:
+      vty_out (vty, "v");
+      break;
+    case SRx_RESULT_UNKNOWN:
+      vty_out (vty, "u");
+      break;
+    case SRx_RESULT_INVALID:
+      vty_out (vty, "i");
+      break;
+    case SRx_RESULT_UNDEFINED:
+      vty_out (vty, "?");
+      break;
+    default:
+      vty_out (vty, "-");        
+  }  
+}
+
+/**
+ * Print the additional SRx validation information to the screen
+ * 
+ * @param vty the terminal
+ * @param binfo the update information.
+ */
+static void srx_route_vty_validation_out(struct vty *vty, 
+                                         struct bgp_info *binfo)
+{
+  struct bgp *bgp;
+  bgp = binfo->peer->bgp;
+  int valState = SRx_RESULT_UNDEFINED;
+  int locPrefPol = -1;
+  
+  if ((bgp->srx_config & SRX_CONFIG_DISPLAY_INFO) != 0)
+  {
+    // The Ident (update id)
+    if (binfo->updateID == 0)
+    {
+      vty_out (vty, "-------- ");
+    }
+    else
+    {
+      vty_out (vty, "%08X ", binfo->updateID);
+    }
+    // Calculate the total validation state
+    valState = srx_calc_validation_state(bgp, binfo);
+    // Print the total validation result depending on the validation mode
+    srx_validation_vty_short_out(vty, valState);
+    vty_out (vty, "(");           
+    if ((bgp->srx_config & SRX_CONFIG_EVAL_ORIGIN) != 0)
+    {
+      // print the origin validation
+      srx_validation_vty_short_out(vty, binfo->val_res_ROA);
+    }
+    else
+    {
+      vty_out (vty, "-");      
+    }
+    vty_out (vty, ",");      
+    if ((bgp->srx_config & SRX_CONFIG_EVAL_PATH) != 0)
+    {
+      // print path validation.
+      srx_validation_vty_short_out(vty, binfo->val_res_BGPSEC);
+    }
+    else
+    {
+      vty_out (vty, "-");      
+    }
+    vty_out (vty, ") ");
+    
+    // Determine local pref policy
+    switch (valState)
+    {
+      case SRx_RESULT_VALID:
+        locPrefPol = VAL_LOCPRF_VALID; 
+        break;
+      case SRx_RESULT_UNKNOWN:
+        locPrefPol = VAL_LOCPRF_UNKNOWN;
+        break;
+      case SRx_RESULT_INVALID:
+        locPrefPol = VAL_LOCPRF_INVALID;
+        break;
+      default:
+        locPrefPol = -1;        
+    }
+    if (locPrefPol > -1)
+    {
+      if (bgp->srx_val_local_pref[locPrefPol].is_set)
+      {
+        switch (bgp->srx_val_local_pref[locPrefPol].relative)
+        {
+          case -1: 
+            vty_out (vty, "-"); 
+            break;
+          case  1: 
+            vty_out (vty, "+"); 
+            break;
+          default: 
+            vty_out (vty, " ");
+        }
+        vty_out (vty, "%4d,", bgp->srx_val_local_pref[locPrefPol].value);
+      }
+      else
+      {
+        vty_out (vty, "      ");
+      }
+    }
+    else
+    {
+      vty_out (vty, "      ");
+    }
+    vty_out (vty, "   ");
+    if (CHECK_FLAG (binfo->flags, BGP_INFO_IGNORE))
+    {
+      vty_out (vty, "I");
+    }
+    else if ((bgp->srx_config & SRX_CONFIG_EVALUATE) == 0)
+    {
+      vty_out (vty, "D");
+    }
+    else
+    {
+      vty_out (vty, " ");
+    }
+    vty_out (vty, "   ");
+  }
+}
+
+#endif
+
 /* Print the short form route status for a bgp_info */
 static void
 route_vty_short_status_out (struct vty *vty, struct bgp_info *binfo)
@@ -5499,6 +6453,10 @@
       vty_out (vty, "i");
     else
       vty_out (vty, " "); 
+  
+#ifdef USE_SRX  
+  srx_route_vty_validation_out (vty, binfo);
+#endif
 }
 
 /* called from terminal list command */
@@ -5547,12 +6505,59 @@
 #endif /* HAVE_IPV6 */
 
       if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC))
-	vty_out (vty, "%10u", attr->med);
+	vty_out (vty, "%10d", attr->med);
       else
 	vty_out (vty, "          ");
 
+#ifdef USE_SRX
+      // Determine srx policy local pref
+      struct bgp* bgp = binfo->peer->bgp;
+      int srxResult = srx_calc_validation_state(bgp, binfo);
+      struct srx_local_pref* srxLocPref;
+      int srxDoLocPref;
+      
+      if (bgp != NULL)
+      {
+        switch (srxResult)
+        {
+          case SRx_RESULT_VALID: 
+            srxLocPref = &bgp->srx_val_local_pref[VAL_LOCPRF_VALID]; 
+            srxDoLocPref = 1; break;
+          case SRx_RESULT_UNKNOWN: 
+            srxLocPref = &bgp->srx_val_local_pref[VAL_LOCPRF_UNKNOWN]; 
+            srxDoLocPref = 1; break;
+          case SRx_RESULT_INVALID: 
+            srxLocPref = &bgp->srx_val_local_pref[VAL_LOCPRF_INVALID]; 
+            srxDoLocPref = 1; break;
+          default:
+            srxDoLocPref = 0;
+            srxLocPref = NULL;
+        }
+      }
+      else
+      {
+        srxDoLocPref = 0;
+        srxLocPref = NULL;
+      }
+#endif
+      
       if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF))
-	vty_out (vty, "%7u", attr->local_pref);
+      #ifdef USE_SRX
+      {       
+        if (srxDoLocPref)
+          vty_out (vty, "%7da", srxLocPref->relative
+            ? attr->local_pref + srxLocPref->relative * srxLocPref->value
+            : srxLocPref->value); 
+        else
+      #endif
+	vty_out (vty, "%7d ", attr->local_pref);
+      #ifdef USE_SRX
+      }
+      else if (srxDoLocPref && srxLocPref->is_set)
+      {
+        vty_out (vty, "%7ds", srxLocPref->value);
+      }
+      #endif
       else
 	vty_out (vty, "       ");
 
@@ -5612,16 +6617,16 @@
 #endif /* HAVE_IPV6 */
 
       if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC))
-	vty_out (vty, "%10u", attr->med);
+	vty_out (vty, "%10d", attr->med);
       else
 	vty_out (vty, "          ");
 
       if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF))
-	vty_out (vty, "%7u", attr->local_pref);
+	vty_out (vty, "%7d", attr->local_pref);
       else
 	vty_out (vty, "       ");
       
-      vty_out (vty, "%7u ", (attr->extra ? attr->extra->weight : 0));
+      vty_out (vty, "%7d ", (attr->extra ? attr->extra->weight : 0));
       
       /* Print aspath */
       if (attr->aspath)
@@ -5795,6 +6800,68 @@
   vty_out (vty, "%s", VTY_NEWLINE);
 }
 
+#ifdef USE_SRX
+
+/**
+ * Print the SRx validation details of the given route on the terminal.
+ * 
+ * @param vty The terminal
+ * @param bgp The bgp router instance
+ * @param binfo The route information.
+ */
+static void srx_route_vty_out_detail(struct vty *vty, struct bgp *bgp, 
+                                     struct bgp_info *binfo)
+{
+  static const char *INDEX_STR[4] =
+  {
+    "valid",
+    "unknown",
+    "invalid",
+    "undefined"       // might be removed again
+  };
+  
+  vty_out (vty, "    SRx Information:%s", VTY_NEWLINE);    
+  vty_out (vty, "      Update ID: 0x%08X%s", binfo->updateID, VTY_NEWLINE);    
+  if (CHECK_FLAG(bgp->srx_config, SRX_CONFIG_EVAL_ORIGIN))
+  {    
+    if (CHECK_FLAG (binfo->flags, BGP_INFO_IGNORE))
+    {
+      vty_out (vty, "      This update will be ignored!%s",VTY_NEWLINE);
+    }
+    if (aspath_count_hops (binfo->attr->aspath) == 0)
+    {
+      vty_out (vty, "      Internal update, no policy processing performed!!%s", 
+               VTY_NEWLINE);          
+    }
+    else
+    {
+      vty_out (vty, "      Validation:%s", VTY_NEWLINE);
+      vty_out (vty, "        prefix-origin: %s%s", INDEX_STR[binfo->val_res_ROA], 
+                                             VTY_NEWLINE);
+      if (CHECK_FLAG(bgp->srx_config, SRX_CONFIG_EVAL_PATH))
+      {
+        vty_out (vty, "        path:   %s%s", INDEX_STR[binfo->val_res_ROA], 
+                                        VTY_NEWLINE);
+        vty_out (vty, "        bgpsec: %s  (combination of prefix-origin and "
+                      "path validation)%s", 
+                      INDEX_STR[srx_calc_validation_state(bgp, binfo)], 
+                      VTY_NEWLINE);
+      }
+      else
+      {
+        vty_out (vty, "        path processing disabled!%s", VTY_NEWLINE); 
+      }
+    }
+  }
+  else
+  {
+	  vty_out (vty, "      SRx evaluation is deactivated, validation results "
+                  "are ignored!%s", VTY_NEWLINE);    
+  }
+}
+
+#endif
+
 static void
 route_vty_out_detail (struct vty *vty, struct bgp *bgp, struct prefix *p, 
 		      struct bgp_info *binfo, afi_t afi, safi_t safi)
@@ -5803,9 +6870,6 @@
   char buf1[BUFSIZ];
   struct attr *attr;
   int sockunion_vty_out (struct vty *, union sockunion *);
-#ifdef HAVE_CLOCK_MONOTONIC
-  time_t tbuf;
-#endif
 	
   attr = binfo->attr;
 
@@ -5839,6 +6903,14 @@
 	vty_out (vty, ", (suppressed due to dampening)");
       vty_out (vty, "%s", VTY_NEWLINE);
 	  
+#ifdef USE_SRX
+      /* Line1.5 display SRx information */
+  if (CHECK_FLAG(bgp->srx_config, SRX_CONFIG_DISPLAY_INFO))
+  {
+    srx_route_vty_out_detail(vty, bgp, binfo);
+  }
+#endif
+      
       /* Line2 display Next-hop, Neighbor, Router-id */
       if (p->family == AF_INET)
 	{
@@ -5891,15 +6963,15 @@
       vty_out (vty, "      Origin %s", bgp_origin_long_str[attr->origin]);
 	  
       if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_MULTI_EXIT_DISC))
-	vty_out (vty, ", metric %u", attr->med);
+	vty_out (vty, ", metric %d", attr->med);
 	  
       if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF))
-	vty_out (vty, ", localpref %u", attr->local_pref);
+	vty_out (vty, ", localpref %d", attr->local_pref);
       else
-	vty_out (vty, ", localpref %u", bgp->default_local_pref);
+	vty_out (vty, ", localpref %d", bgp->default_local_pref);
 
       if (attr->extra && attr->extra->weight != 0)
-	vty_out (vty, ", weight %u", attr->extra->weight);
+	vty_out (vty, ", weight %d", attr->extra->weight);
 	
       if (! CHECK_FLAG (binfo->flags, BGP_INFO_HISTORY))
 	vty_out (vty, ", valid");
@@ -5957,23 +7029,38 @@
 	  vty_out (vty, "%s", VTY_NEWLINE);
 	}
       
+      /* 7: AS Pathlimit */
+      if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_AS_PATHLIMIT))
+        {
+          
+          vty_out (vty, "      AS-Pathlimit: %u",
+                   attr->pathlimit.ttl);
+          if (attr->pathlimit.as)
+            vty_out (vty, " (%u)", attr->pathlimit.as);
+          vty_out (vty, "%s", VTY_NEWLINE);
+        }
+      
       if (binfo->extra && binfo->extra->damp_info)
 	bgp_damp_info_vty (vty, binfo);
 
       /* Line 7 display Uptime */
-#ifdef HAVE_CLOCK_MONOTONIC
-      tbuf = time(NULL) - (bgp_clock() - binfo->uptime);
-      vty_out (vty, "      Last update: %s", ctime(&tbuf));
-#else
       vty_out (vty, "      Last update: %s", ctime(&binfo->uptime));
-#endif /* HAVE_CLOCK_MONOTONIC */
     }
   vty_out (vty, "%s", VTY_NEWLINE);
 }  
 
 #define BGP_SHOW_SCODE_HEADER "Status codes: s suppressed, d damped, h history, * valid, > best, i - internal,%s              r RIB-failure, S Stale, R Removed%s"
-#define BGP_SHOW_OCODE_HEADER "Origin codes: i - IGP, e - EGP, ? - incomplete%s%s"
+#ifdef USE_SRX
+#define BGP_SRX_SHOW_SCODE_HEADER "Validation:    v - valid, u - unknown, i - invalid, ? - undefined%s" \
+                                  "SRx Status:    I - route ignored, D - SRx evaluation deactivated%s" \
+                                  "SRxVal Format: validation result (origin validation, path validation)%s"
+//#define BGP_SRX_SHOW_HEADER       "   SRx Data      Network          Next Hop            Metric  LocPrf Weight Path%s"
+#define BGP_SRX_SHOW_HEADER       "   Ident    SRxVal SRxLP Status Network          Next Hop            Metric  LocPrf Weight Path%s"
+//                                    12345678 i(v,i) +1000   I                                                                             
+#endif
+#define BGP_SHOW_SCODE_HEADER "Status codes: s suppressed, d damped, h history, * valid, > best, i - internal,%s              r RIB-failure, S Stale, R Removed%s"
 #define BGP_SHOW_HEADER "   Network          Next Hop            Metric LocPrf Weight Path%s"
+#define BGP_SHOW_OCODE_HEADER "Origin codes: i - IGP, e - EGP, ? - incomplete%s%s"
 #define BGP_SHOW_DAMP_HEADER "   Network          From             Reuse    Path%s"
 #define BGP_SHOW_FLAP_HEADER "   Network          From            Flaps Duration Reuse    Path%s"
 
@@ -6016,6 +7103,10 @@
   int display;
   unsigned long output_count;
 
+#ifdef USE_SRX
+  int displaySRX = 0;
+#endif
+
   /* This is first entry point, so reset total line. */
   output_count = 0;
 
@@ -6175,6 +7266,17 @@
 	      {
 		vty_out (vty, "BGP table version is 0, local router ID is %s%s", inet_ntoa (*router_id), VTY_NEWLINE);
 		vty_out (vty, BGP_SHOW_SCODE_HEADER, VTY_NEWLINE, VTY_NEWLINE);
+#ifdef USE_SRX
+          if ((ri->peer->bgp->srx_config & SRX_CONFIG_DISPLAY_INFO) != 0)
+          {
+            displaySRX = 1;
+    vty_out (vty, BGP_SRX_SHOW_SCODE_HEADER, VTY_NEWLINE, VTY_NEWLINE, VTY_NEWLINE);
+          }
+          else
+          {
+            displaySRX = 0;
+          }
+#endif
 		vty_out (vty, BGP_SHOW_OCODE_HEADER, VTY_NEWLINE, VTY_NEWLINE);
 		if (type == bgp_show_type_dampend_paths
 		    || type == bgp_show_type_damp_neighbor)
@@ -6191,7 +7293,20 @@
 			 || type == bgp_show_type_flap_neighbor)
 		  vty_out (vty, BGP_SHOW_FLAP_HEADER, VTY_NEWLINE);
 		else
+#ifdef USE_SRX
+    {
+      if (displaySRX)
+      {
+        vty_out (vty, BGP_SRX_SHOW_HEADER, VTY_NEWLINE);
+      }
+      else
+      {
+  		  vty_out (vty, BGP_SHOW_HEADER, VTY_NEWLINE);
+      }
+    }
+#else
 		  vty_out (vty, BGP_SHOW_HEADER, VTY_NEWLINE);
+#endif
 		header = 0;
 	      }
 
@@ -6375,10 +7490,7 @@
               if ((rm = bgp_node_match (table, &match)) != NULL)
                 {
                   if (prefix_check && rm->p.prefixlen != match.prefixlen)
-                    {
-                      bgp_unlock_node (rm);
                       continue;
-                    }
 
                   for (ri = rm->info; ri; ri = ri->next)
                     {
@@ -6392,8 +7504,6 @@
                       display++;
                       route_vty_out_detail (vty, bgp, &rm->p, ri, AFI_IP, SAFI_MPLS_VPN);
                     }
-
-                  bgp_unlock_node (rm);
                 }
             }
         }
@@ -6417,8 +7527,6 @@
                   route_vty_out_detail (vty, bgp, &rn->p, ri, afi, safi);
                 }
             }
-
-          bgp_unlock_node (rn);
         }
     }
 
@@ -7450,7 +8558,7 @@
 
 static int
 bgp_show_community (struct vty *vty, int argc, const char **argv, int exact,
-                    afi_t afi, safi_t safi)
+                    u_int16_t afi, u_char safi)
 {
   struct community *com;
   struct buffer *b;
@@ -8450,7 +9558,7 @@
 
 static int
 bgp_show_community_list (struct vty *vty, const char *com, int exact,
-			 afi_t afi, safi_t safi)
+			 u_int16_t afi, u_char safi)
 {
   struct community_list *list;
 
@@ -9192,6 +10300,9 @@
   PCOUNT_HISTORY,
   PCOUNT_STALE,
   PCOUNT_VALID,
+#ifdef USE_SRX
+  PCOUNT_IGNORE,
+#endif
   PCOUNT_ALL,
   PCOUNT_COUNTED,
   PCOUNT_PFCNT, /* the figure we display to users */
@@ -9206,6 +10317,9 @@
   [PCOUNT_HISTORY] = "History",
   [PCOUNT_STALE]   = "Stale",
   [PCOUNT_VALID]   = "Valid",
+#ifdef USE_SRX
+  [PCOUNT_IGNORE]  = "Ignore",
+#endif
   [PCOUNT_ALL]     = "All RIB",
   [PCOUNT_COUNTED] = "PfxCt counted",
   [PCOUNT_PFCNT]   = "Useable",
@@ -9254,6 +10368,12 @@
             pc->count[PCOUNT_STALE]++;
           if (CHECK_FLAG (ri->flags, BGP_INFO_VALID))
             pc->count[PCOUNT_VALID]++;
+          #ifdef USE_SRX
+          if (CHECK_FLAG (ri->flags, BGP_INFO_IGNORE))
+          {
+            pc->count[PCOUNT_IGNORE]++;
+          }
+          #endif
           if (!CHECK_FLAG (ri->flags, BGP_INFO_UNUSEABLE))
             pc->count[PCOUNT_PFCNT]++;
           
@@ -11176,7 +12296,6 @@
 
 	  if ((table = rn->info) != NULL)
 	    if ((rm = bgp_node_match (table, &match)) != NULL)
-              {
                 if (! prefix_check || rm->p.prefixlen == match.prefixlen)
                   {
                     ri = rm->info;
@@ -11192,15 +12311,11 @@
                           ri = ri->next;
                       }
                   }
-
-                bgp_unlock_node (rm);
-              }
         }
     }
   else
     {
       if ((rn = bgp_node_match (bgp->rib[afi][safi], &match)) != NULL)
-        {
           if (! prefix_check || rn->p.prefixlen == match.prefixlen)
             {
               ri = rn->info;
@@ -11216,9 +12331,6 @@
                     ri = ri->next;
                 }
             }
-
-          bgp_unlock_node (rn);
-        }
     }
 
   return CMD_SUCCESS;
@@ -11383,6 +12495,8 @@
 	  {
 	    if (bgp_static->backdoor)
 	      vty_out (vty, " backdoor");
+            if (bgp_static->ttl)
+              vty_out (vty, " pathlimit %u", bgp_static->ttl);
           }
 
 	vty_out (vty, "%s", VTY_NEWLINE);
@@ -11471,6 +12585,12 @@
   install_element (BGP_NODE, &bgp_network_backdoor_cmd);
   install_element (BGP_NODE, &bgp_network_mask_backdoor_cmd);
   install_element (BGP_NODE, &bgp_network_mask_natural_backdoor_cmd);
+  install_element (BGP_NODE, &bgp_network_ttl_cmd);
+  install_element (BGP_NODE, &bgp_network_mask_ttl_cmd);
+  install_element (BGP_NODE, &bgp_network_mask_natural_ttl_cmd);
+  install_element (BGP_NODE, &bgp_network_backdoor_ttl_cmd);
+  install_element (BGP_NODE, &bgp_network_mask_backdoor_ttl_cmd);
+  install_element (BGP_NODE, &bgp_network_mask_natural_backdoor_ttl_cmd);
   install_element (BGP_NODE, &no_bgp_network_cmd);
   install_element (BGP_NODE, &no_bgp_network_mask_cmd);
   install_element (BGP_NODE, &no_bgp_network_mask_natural_cmd);
@@ -11480,6 +12600,12 @@
   install_element (BGP_NODE, &no_bgp_network_backdoor_cmd);
   install_element (BGP_NODE, &no_bgp_network_mask_backdoor_cmd);
   install_element (BGP_NODE, &no_bgp_network_mask_natural_backdoor_cmd);
+  install_element (BGP_NODE, &no_bgp_network_ttl_cmd);
+  install_element (BGP_NODE, &no_bgp_network_mask_ttl_cmd);
+  install_element (BGP_NODE, &no_bgp_network_mask_natural_ttl_cmd);
+  install_element (BGP_NODE, &no_bgp_network_backdoor_ttl_cmd);
+  install_element (BGP_NODE, &no_bgp_network_mask_backdoor_ttl_cmd);
+  install_element (BGP_NODE, &no_bgp_network_mask_natural_backdoor_ttl_cmd);
 
   install_element (BGP_NODE, &aggregate_address_cmd);
   install_element (BGP_NODE, &aggregate_address_mask_cmd);
@@ -11509,13 +12635,23 @@
   install_element (BGP_IPV4_NODE, &bgp_network_route_map_cmd);
   install_element (BGP_IPV4_NODE, &bgp_network_mask_route_map_cmd);
   install_element (BGP_IPV4_NODE, &bgp_network_mask_natural_route_map_cmd);
-  install_element (BGP_IPV4_NODE, &no_bgp_network_cmd);
+  install_element (BGP_IPV4_NODE, &bgp_network_ttl_cmd);
+  install_element (BGP_IPV4_NODE, &bgp_network_mask_ttl_cmd);
+  install_element (BGP_IPV4_NODE, &bgp_network_mask_natural_ttl_cmd);
+  install_element (BGP_IPV4_NODE, &bgp_network_backdoor_ttl_cmd);
+  install_element (BGP_IPV4_NODE, &bgp_network_mask_backdoor_ttl_cmd);
+  install_element (BGP_IPV4_NODE, &bgp_network_mask_natural_backdoor_ttl_cmd);  install_element (BGP_IPV4_NODE, &no_bgp_network_cmd);
   install_element (BGP_IPV4_NODE, &no_bgp_network_mask_cmd);
   install_element (BGP_IPV4_NODE, &no_bgp_network_mask_natural_cmd);
   install_element (BGP_IPV4_NODE, &no_bgp_network_route_map_cmd);
   install_element (BGP_IPV4_NODE, &no_bgp_network_mask_route_map_cmd);
   install_element (BGP_IPV4_NODE, &no_bgp_network_mask_natural_route_map_cmd);
-  
+  install_element (BGP_IPV4_NODE, &no_bgp_network_ttl_cmd);
+  install_element (BGP_IPV4_NODE, &no_bgp_network_mask_ttl_cmd);
+  install_element (BGP_IPV4_NODE, &no_bgp_network_mask_natural_ttl_cmd);
+  install_element (BGP_IPV4_NODE, &no_bgp_network_backdoor_ttl_cmd);
+  install_element (BGP_IPV4_NODE, &no_bgp_network_mask_backdoor_ttl_cmd);
+  install_element (BGP_IPV4_NODE, &no_bgp_network_mask_natural_backdoor_ttl_cmd);  install_element (BGP_IPV4_NODE, &no_bgp_network_cmd);
   install_element (BGP_IPV4_NODE, &aggregate_address_cmd);
   install_element (BGP_IPV4_NODE, &aggregate_address_mask_cmd);
   install_element (BGP_IPV4_NODE, &aggregate_address_summary_only_cmd);
@@ -11544,12 +12680,24 @@
   install_element (BGP_IPV4M_NODE, &bgp_network_route_map_cmd);
   install_element (BGP_IPV4M_NODE, &bgp_network_mask_route_map_cmd);
   install_element (BGP_IPV4M_NODE, &bgp_network_mask_natural_route_map_cmd);
+  install_element (BGP_IPV4M_NODE, &bgp_network_ttl_cmd);
+  install_element (BGP_IPV4M_NODE, &bgp_network_mask_ttl_cmd);
+  install_element (BGP_IPV4M_NODE, &bgp_network_mask_natural_ttl_cmd);
+  install_element (BGP_IPV4M_NODE, &bgp_network_backdoor_ttl_cmd);
+  install_element (BGP_IPV4M_NODE, &bgp_network_mask_backdoor_ttl_cmd);
+  install_element (BGP_IPV4M_NODE, &bgp_network_mask_natural_backdoor_ttl_cmd);  install_element (BGP_IPV4_NODE, &no_bgp_network_cmd);
   install_element (BGP_IPV4M_NODE, &no_bgp_network_cmd);
   install_element (BGP_IPV4M_NODE, &no_bgp_network_mask_cmd);
   install_element (BGP_IPV4M_NODE, &no_bgp_network_mask_natural_cmd);
   install_element (BGP_IPV4M_NODE, &no_bgp_network_route_map_cmd);
   install_element (BGP_IPV4M_NODE, &no_bgp_network_mask_route_map_cmd);
   install_element (BGP_IPV4M_NODE, &no_bgp_network_mask_natural_route_map_cmd);
+  install_element (BGP_IPV4M_NODE, &no_bgp_network_ttl_cmd);
+  install_element (BGP_IPV4M_NODE, &no_bgp_network_mask_ttl_cmd);
+  install_element (BGP_IPV4M_NODE, &no_bgp_network_mask_natural_ttl_cmd);
+  install_element (BGP_IPV4M_NODE, &no_bgp_network_backdoor_ttl_cmd);
+  install_element (BGP_IPV4M_NODE, &no_bgp_network_mask_backdoor_ttl_cmd);
+  install_element (BGP_IPV4M_NODE, &no_bgp_network_mask_natural_backdoor_ttl_cmd);  install_element (BGP_IPV4_NODE, &no_bgp_network_cmd);
   install_element (BGP_IPV4M_NODE, &aggregate_address_cmd);
   install_element (BGP_IPV4M_NODE, &aggregate_address_mask_cmd);
   install_element (BGP_IPV4M_NODE, &aggregate_address_summary_only_cmd);
@@ -11770,8 +12918,10 @@
   /* New config IPv6 BGP commands.  */
   install_element (BGP_IPV6_NODE, &ipv6_bgp_network_cmd);
   install_element (BGP_IPV6_NODE, &ipv6_bgp_network_route_map_cmd);
+  install_element (BGP_IPV6_NODE, &ipv6_bgp_network_ttl_cmd);
   install_element (BGP_IPV6_NODE, &no_ipv6_bgp_network_cmd);
   install_element (BGP_IPV6_NODE, &no_ipv6_bgp_network_route_map_cmd);
+  install_element (BGP_IPV6_NODE, &no_ipv6_bgp_network_ttl_cmd);
 
   install_element (BGP_IPV6_NODE, &ipv6_aggregate_address_cmd);
   install_element (BGP_IPV6_NODE, &ipv6_aggregate_address_summary_only_cmd);
@@ -12090,52 +13240,6 @@
   install_element (BGP_IPV4_NODE, &bgp_damp_set3_cmd);
   install_element (BGP_IPV4_NODE, &bgp_damp_unset_cmd);
   install_element (BGP_IPV4_NODE, &bgp_damp_unset2_cmd);
-  
-  /* Deprecated AS-Pathlimit commands */
-  install_element (BGP_NODE, &bgp_network_ttl_cmd);
-  install_element (BGP_NODE, &bgp_network_mask_ttl_cmd);
-  install_element (BGP_NODE, &bgp_network_mask_natural_ttl_cmd);
-  install_element (BGP_NODE, &bgp_network_backdoor_ttl_cmd);
-  install_element (BGP_NODE, &bgp_network_mask_backdoor_ttl_cmd);
-  install_element (BGP_NODE, &bgp_network_mask_natural_backdoor_ttl_cmd);
-  
-  install_element (BGP_NODE, &no_bgp_network_ttl_cmd);
-  install_element (BGP_NODE, &no_bgp_network_mask_ttl_cmd);
-  install_element (BGP_NODE, &no_bgp_network_mask_natural_ttl_cmd);
-  install_element (BGP_NODE, &no_bgp_network_backdoor_ttl_cmd);
-  install_element (BGP_NODE, &no_bgp_network_mask_backdoor_ttl_cmd);
-  install_element (BGP_NODE, &no_bgp_network_mask_natural_backdoor_ttl_cmd);
-  
-  install_element (BGP_IPV4_NODE, &bgp_network_ttl_cmd);
-  install_element (BGP_IPV4_NODE, &bgp_network_mask_ttl_cmd);
-  install_element (BGP_IPV4_NODE, &bgp_network_mask_natural_ttl_cmd);
-  install_element (BGP_IPV4_NODE, &bgp_network_backdoor_ttl_cmd);
-  install_element (BGP_IPV4_NODE, &bgp_network_mask_backdoor_ttl_cmd);
-  install_element (BGP_IPV4_NODE, &bgp_network_mask_natural_backdoor_ttl_cmd);
-  
-  install_element (BGP_IPV4_NODE, &no_bgp_network_ttl_cmd);
-  install_element (BGP_IPV4_NODE, &no_bgp_network_mask_ttl_cmd);
-  install_element (BGP_IPV4_NODE, &no_bgp_network_mask_natural_ttl_cmd);
-  install_element (BGP_IPV4_NODE, &no_bgp_network_backdoor_ttl_cmd);
-  install_element (BGP_IPV4_NODE, &no_bgp_network_mask_backdoor_ttl_cmd);
-  install_element (BGP_IPV4_NODE, &no_bgp_network_mask_natural_backdoor_ttl_cmd);
-  
-  install_element (BGP_IPV4M_NODE, &bgp_network_ttl_cmd);
-  install_element (BGP_IPV4M_NODE, &bgp_network_mask_ttl_cmd);
-  install_element (BGP_IPV4M_NODE, &bgp_network_mask_natural_ttl_cmd);
-  install_element (BGP_IPV4M_NODE, &bgp_network_backdoor_ttl_cmd);
-  install_element (BGP_IPV4M_NODE, &bgp_network_mask_backdoor_ttl_cmd);
-  install_element (BGP_IPV4M_NODE, &bgp_network_mask_natural_backdoor_ttl_cmd);
-  
-  install_element (BGP_IPV4M_NODE, &no_bgp_network_ttl_cmd);
-  install_element (BGP_IPV4M_NODE, &no_bgp_network_mask_ttl_cmd);
-  install_element (BGP_IPV4M_NODE, &no_bgp_network_mask_natural_ttl_cmd);
-  install_element (BGP_IPV4M_NODE, &no_bgp_network_backdoor_ttl_cmd);
-  install_element (BGP_IPV4M_NODE, &no_bgp_network_mask_backdoor_ttl_cmd);
-  install_element (BGP_IPV4M_NODE, &no_bgp_network_mask_natural_backdoor_ttl_cmd);
-  
-  install_element (BGP_IPV6_NODE, &ipv6_bgp_network_ttl_cmd);
-  install_element (BGP_IPV6_NODE, &no_ipv6_bgp_network_ttl_cmd);
 }
 
 void
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./bgpd/bgp_aspath.h	2011-03-21 09:52:26.000000000 -0400
+++ ./bgpd/bgp_aspath.h	2010-10-18 16:11:20.000000000 -0400
@@ -65,7 +65,7 @@
 /* Prototypes. */
 extern void aspath_init (void);
 extern void aspath_finish (void);
-extern struct aspath *aspath_parse (struct stream *, size_t, int, int);
+extern struct aspath *aspath_parse (struct stream *, size_t, int);
 extern struct aspath *aspath_dup (struct aspath *);
 extern struct aspath *aspath_aggregate (struct aspath *, struct aspath *);
 extern struct aspath *aspath_prepend (struct aspath *, struct aspath *);
@@ -103,4 +103,8 @@
 /* For SNMP BGP4PATHATTRASPATHSEGMENT, might be useful for debug */
 extern u_char *aspath_snmp_pathseg (struct aspath *, size_t *);
 
+#ifdef USE_SRX
+extern as_t aspath_origin_as (struct aspath *);
+#endif
+
 #endif /* _QUAGGA_BGP_ASPATH_H */
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./bgpd/bgp_attr.h	2011-03-21 10:32:49.000000000 -0400
+++ ./bgpd/bgp_attr.h	2010-10-18 16:11:18.000000000 -0400
@@ -110,6 +110,12 @@
   u_int32_t med;
   u_int32_t local_pref;
   
+  /* AS-Pathlimit */
+  struct {
+    u_int32_t as;
+    u_char ttl;
+  } pathlimit;
+  
   /* Path origin attribute */
   u_char origin;
 };
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./bgpd/bgp_damp.c	2011-03-21 09:43:34.000000000 -0400
+++ ./bgpd/bgp_damp.c	2010-10-18 16:11:24.000000000 -0400
@@ -407,10 +407,14 @@
   damp->reuse_list = XCALLOC (MTYPE_BGP_DAMP_ARRAY, 
 			      damp->reuse_list_size 
 			      * sizeof (struct bgp_reuse_node *));
+  memset (damp->reuse_list, 0x00, 
+          damp->reuse_list_size * sizeof (struct bgp_reuse_node *));  
 
   /* Reuse-array computations */
-  damp->reuse_index = XCALLOC (MTYPE_BGP_DAMP_ARRAY,
+  damp->reuse_index = XMALLOC (MTYPE_BGP_DAMP_ARRAY, 
 			       sizeof(int) * damp->reuse_index_size);
+  memset (damp->reuse_index, 0x00,
+          damp->reuse_list_size * sizeof (int));
 
   reuse_max_ratio = (double)damp->ceiling/damp->reuse_limit;
   j = (exp((double)damp->max_suppress_time/damp->half_life) * log10(2.0));
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./bgpd/bgp_open.h	2011-03-21 05:43:52.000000000 -0400
+++ ./bgpd/bgp_open.h	2010-10-18 16:11:18.000000000 -0400
@@ -31,9 +31,9 @@
 /* Generic MP capability data */
 struct capability_mp_data
 {
-  afi_t afi;
+  u_int16_t afi;
   u_char reserved;
-  safi_t safi;
+  u_char safi;
 };
 
 #pragma pack(1)
@@ -55,8 +55,8 @@
 
 struct graceful_restart_af
 {
-  afi_t afi;
-  safi_t safi;
+  u_int16_t afi;
+  u_char safi;
   u_char flag;
 };
 
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./bgpd/bgp_routemap.c	2011-03-21 10:32:49.000000000 -0400
+++ ./bgpd/bgp_routemap.c	2010-10-18 16:11:23.000000000 -0400
@@ -92,15 +92,107 @@
       origin            :  Done
       tag               :  (This will not be implemented by bgpd)
       weight            :  Done
+      pathlimit		:  Done
 
 o Local extention
 
   set ipv6 next-hop global: Done
   set ipv6 next-hop local : Done
+  set pathlimit ttl       : Done
   set as-path exclude     : Done
+  match pathlimit as     : Done
 
 */ 
 
+/* Compiles either AS or TTL argument. It is amused the VTY code
+ * has already range-checked the values to be suitable as TTL or ASN
+ */
+static void *
+route_pathlimit_compile (const char *arg)
+{
+  unsigned long tmp;
+  u_int32_t *val;
+  char *endptr = NULL;
+
+  /* TTL or AS value shoud be integer. */
+  if (! all_digit (arg))
+    return NULL;
+  
+  tmp = strtoul (arg, &endptr, 10);
+  if (*endptr != '\0' || tmp == ULONG_MAX || tmp > UINT32_MAX)
+    return NULL;
+   
+  if (!(val = XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (u_int32_t))))
+    return NULL;
+  
+  *val = tmp;
+  
+  return val;
+}
+
+static void
+route_pathlimit_free (void *rule)
+{
+  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);
+}
+
+static route_map_result_t
+route_match_pathlimit_as (void *rule, struct prefix *prefix, route_map_object_t type,
+      void *object)
+{
+  struct bgp_info *info = object;
+  struct attr *attr = info->attr;
+  uint32_t as = *(uint32_t *)rule;
+  
+  if (type != RMAP_BGP)
+    return RMAP_NOMATCH;
+  
+  if (!attr->pathlimit.as)
+    return RMAP_NOMATCH;
+  
+  if (as == attr->pathlimit.as)
+    return RMAP_MATCH;
+  
+  return RMAP_NOMATCH;
+}
+
+/* 'match pathlimit as' */
+struct route_map_rule_cmd route_match_pathlimit_as_cmd =
+{
+  "pathlimit as",
+  route_match_pathlimit_as,
+  route_pathlimit_compile,
+  route_pathlimit_free
+};
+
+/* Set pathlimit TTL. */
+static route_map_result_t
+route_set_pathlimit_ttl (void *rule, struct prefix *prefix,
+		         route_map_object_t type, void *object)
+{
+  struct bgp_info *info = object;
+  struct attr *attr = info->attr;
+  u_char ttl = *(uint32_t *)rule;
+  
+  if (type == RMAP_BGP)
+    {
+      attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_AS_PATHLIMIT);
+      attr->pathlimit.ttl = ttl;
+      attr->pathlimit.as = 0;
+    }
+
+  return RMAP_OKAY;
+}
+
+/* Set local preference rule structure. */
+struct route_map_rule_cmd route_set_pathlimit_ttl_cmd = 
+{
+  "pathlimit ttl",
+  route_set_pathlimit_ttl,
+  route_pathlimit_compile,
+  route_pathlimit_free,
+};
+
  /* 'match peer (A.B.C.D|X:X::X:X)' */
 
 /* Compares the peer specified in the 'match peer' clause with the peer
@@ -3651,17 +3743,17 @@
        "BGP originator ID attribute\n"
        "IP address of originator\n")
 
-DEFUN_DEPRECATED (set_pathlimit_ttl,
+DEFUN (set_pathlimit_ttl,
        set_pathlimit_ttl_cmd,
        "set pathlimit ttl <1-255>",
        SET_STR
        "BGP AS-Pathlimit attribute\n"
        "Set AS-Path Hop-count TTL\n")
 {
-  return CMD_SUCCESS;
+  return bgp_route_set_add (vty, vty->index, "pathlimit ttl", argv[0]);
 }
 
-DEFUN_DEPRECATED (no_set_pathlimit_ttl,
+DEFUN (no_set_pathlimit_ttl,
        no_set_pathlimit_ttl_cmd,
        "no set pathlimit ttl",
        NO_STR
@@ -3669,7 +3761,10 @@
        "BGP AS-Pathlimit attribute\n"
        "Set AS-Path Hop-count TTL\n")
 {
-  return CMD_SUCCESS;
+  if (argc == 0)
+    return bgp_route_set_delete (vty, vty->index, "pathlimit ttl", NULL);
+  
+  return bgp_route_set_delete (vty, vty->index, "pathlimit ttl", argv[0]);
 }
 
 ALIAS (no_set_pathlimit_ttl,
@@ -3680,17 +3775,17 @@
        "BGP AS-Pathlimit attribute\n"
        "Set AS-Path Hop-count TTL\n")
 
-DEFUN_DEPRECATED (match_pathlimit_as,
+DEFUN (match_pathlimit_as,
        match_pathlimit_as_cmd,
        "match pathlimit as <1-65535>",
        MATCH_STR
        "BGP AS-Pathlimit attribute\n"
        "Match Pathlimit AS number\n")
 {
-  return CMD_SUCCESS;
+  return bgp_route_match_add (vty, vty->index, "pathlimit as", argv[0]);
 }
 
-DEFUN_DEPRECATED (no_match_pathlimit_as,
+DEFUN (no_match_pathlimit_as,
        no_match_pathlimit_as_cmd,
        "no match pathlimit as",
        NO_STR
@@ -3698,7 +3793,10 @@
        "BGP AS-Pathlimit attribute\n"
        "Match Pathlimit AS number\n")
 {
-  return CMD_SUCCESS;
+  if (argc == 0)
+    return bgp_route_match_delete (vty, vty->index, "pathlimit as", NULL);
+  
+  return bgp_route_match_delete (vty, vty->index, "pathlimit as", argv[0]);
 }
 
 ALIAS (no_match_pathlimit_as,
@@ -3861,9 +3959,10 @@
   install_element (RMAP_NODE, &no_set_ipv6_nexthop_local_val_cmd);
 #endif /* HAVE_IPV6 */
 
-  /* AS-Pathlimit: functionality removed, commands kept for
-   * compatibility.
-   */
+  /* AS-Pathlimit */
+  route_map_install_match (&route_match_pathlimit_as_cmd);
+  route_map_install_set (&route_set_pathlimit_ttl_cmd);
+
   install_element (RMAP_NODE, &set_pathlimit_ttl_cmd);
   install_element (RMAP_NODE, &no_set_pathlimit_ttl_cmd);
   install_element (RMAP_NODE, &no_set_pathlimit_ttl_val_cmd);
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./bgpd/bgp_aspath.c	2011-03-21 09:52:26.000000000 -0400
+++ ./bgpd/bgp_aspath.c	2011-08-25 11:38:31.000000000 -0400
@@ -671,79 +671,58 @@
   return aspath;
 }
 
-/* parse as-segment byte stream in struct assegment
- *
- * Returns NULL if the AS_PATH or AS4_PATH is not valid.
- */
+/* parse as-segment byte stream in struct assegment */
 static struct assegment *
-assegments_parse (struct stream *s, size_t length, int use32bit, int as4_path)
+assegments_parse (struct stream *s, size_t length, int use32bit)
 {
   struct assegment_header segh;
   struct assegment *seg, *prev = NULL, *head = NULL;
+  size_t bytes = 0;
   
-  assert (length > 0);  /* does not expect empty AS_PATH or AS4_PATH    */
+  /* empty aspath (ie iBGP or somesuch) */
+  if (length == 0)
+    return NULL;
   
   if (BGP_DEBUG (as4, AS4_SEGMENT))
     zlog_debug ("[AS4SEG] Parse aspath segment: got total byte length %lu",
 		(unsigned long) length);
-
-  /* double check that length does not exceed stream    */
-  if (STREAM_READABLE(s) < length)
+  /* basic checks */
+  if ( (STREAM_READABLE(s) < length)
+      || (STREAM_READABLE(s) < AS_HEADER_SIZE) 
+      || (length % AS16_VALUE_SIZE ))
     return NULL;
   
-  /* deal with each segment in turn                             */
-  while (length > 0)
+  while ( (STREAM_READABLE(s) > AS_HEADER_SIZE)
+         && (bytes < length))
     {
       int i;
-      size_t seg_size;
+      int seg_size;
       
       /* softly softly, get the header first on its own */
-      if (length >= AS_HEADER_SIZE)
-        {
       segh.type = stream_getc (s);
       segh.length = stream_getc (s);
       
       seg_size = ASSEGMENT_SIZE(segh.length, use32bit);
-                                      /* includes the header bytes */
 
       if (BGP_DEBUG (as4, AS4_SEGMENT))
 	zlog_debug ("[AS4SEG] Parse aspath segment: got type %d, length %d",
                     segh.type, segh.length);
       
-          switch (segh.type)
-          {
-            case AS_SEQUENCE:
-            case AS_SET:
-              break ;
-
-            case AS_CONFED_SEQUENCE:
-            case AS_CONFED_SET:
-              if (!as4_path)
-                break ;
-              /* RFC4893 3: "invalid for the AS4_PATH attribute"            */
-              /* fall through */
-
-            default:    /* reject unknown or invalid AS_PATH segment types  */
-              seg_size = 0 ;
-          } ;
-        }
-      else
-        seg_size = 0 ;
-
-     /* Stop now if segment is not valid (discarding anything collected to date)
-      *
-      * RFC4271 4.3, Path Attributes, b) AS_PATH:
-      *
-      *   "path segment value field contains one or more AS numbers"
+      /* check it.. */
+      if ( ((bytes + seg_size) > length)
+          /* 1771bis 4.3b: seg length contains one or more */
+          || (segh.length == 0) 
+          /* Paranoia in case someone changes type of segment length.
+           * Shift both values by 0x10 to make the comparison operate
+           * on more, than 8 bits (otherwise it's a warning, bug #564).
            */
-      if ((seg_size == 0) || (seg_size > length) || (segh.length == 0))
+          || ((sizeof segh.length > 1) && (0x10 + segh.length > 0x10 + AS_SEGMENT_MAX)) )
         {
+          if (head)
             assegment_free_all (head);
           return NULL;
         }
       
-      length -= seg_size ;
-      
       /* now its safe to trust lengths */
       seg = assegment_new (segh.type, segh.length);
       
@@ -755,9 +734,11 @@
       for (i = 0; i < segh.length; i++)
 	seg->as[i] = (use32bit) ? stream_getl (s) : stream_getw (s);
 
+      bytes += seg_size;
+      
       if (BGP_DEBUG (as4, AS4_SEGMENT))
-	zlog_debug ("[AS4SEG] Parse aspath segment: length left: %lu",
-	            (unsigned long) length);
+	zlog_debug ("[AS4SEG] Parse aspath segment: Bytes now: %lu",
+	            (unsigned long) bytes);
       
       prev = seg;
     }
@@ -765,42 +746,30 @@
   return assegment_normalise (head);
 }
 
-/* AS path parse function -- parses AS_PATH and AS4_PATH attributes
- *
- * Requires: s        -- stream, currently positioned before first segment
- *                       of AS_PATH or AS4_PATH (ie after attribute header)
- *           length   -- length of the value of the AS_PATH or AS4_PATH
- *           use32bit -- true <=> 4Byte ASN, otherwise 2Byte ASN
- *           as4_path -- true <=> AS4_PATH, otherwise AS_PATH
- *
- * Returns: if valid: address of struct aspath in the hash of known aspaths,
- *                    with reference count incremented.
- *              else: NULL
- *
- * NB: empty AS path (length == 0) is valid.  The returned struct aspath will
- *     have segments == NULL and str == zero length string (unique).
- */
+/* AS path parse function.  pnt is a pointer to byte stream and length
+   is length of byte stream.  If there is same AS path in the the AS
+   path hash then return it else make new AS path structure. */
 struct aspath *
-aspath_parse (struct stream *s, size_t length, int use32bit, int as4_path)
+aspath_parse (struct stream *s, size_t length, int use32bit)
 {
   struct aspath as;
   struct aspath *find;
 
-  /* Parse each segment and construct normalised list of struct assegment */
-  memset (&as, 0, sizeof (struct aspath));
-  if (length != 0)
-    {
-      as.segments = assegments_parse (s, length, use32bit, as4_path);
+  /* If length is odd it's malformed AS path. */
+  /* Nit-picking: if (use32bit == 0) it is malformed if odd,
+   * otherwise its malformed when length is larger than 2 and (length-2) 
+   * is not dividable by 4.
+   * But... this time we're lazy
+   */
+  if (length % AS16_VALUE_SIZE )
+    return NULL;
 
-      if (as.segments == NULL)
-        return NULL ;   /* Invalid AS_PATH or AS4_PATH  */
-    } ;
+  memset (&as, 0, sizeof (struct aspath));
+  as.segments = assegments_parse (s, length, use32bit);
   
   /* If already same aspath exist then return it. */
   find = hash_get (ashash, &as, aspath_hash_alloc);
   
-  assert(find) ;        /* valid aspath, so must find or create */
-  
   /* aspath_hash_alloc dupes segments too. that probably could be
    * optimised out.
    */
@@ -808,6 +777,8 @@
   if (as.str)
     XFREE (MTYPE_AS_STR, as.str);
   
+  if (! find)
+    return NULL;
   find->refcnt++;
 
   return find;
@@ -1631,7 +1602,7 @@
 struct aspath *
 aspath_empty (void)
 {
-  return aspath_parse (NULL, 0, 1, 0); /* 32Bit ;-) not AS4_PATH */
+  return aspath_parse (NULL, 0, 1); /* 32Bit ;-) */
 }
 
 struct aspath *
@@ -1819,6 +1790,39 @@
   return key;
 }
 
+#ifdef USE_SRX
+
+/**
+ * Determine the right most as in the path as origin as!
+ * 
+ * @param ap The AS path
+ * 
+ * @return the right most AS or 0
+ */
+as_t aspath_origin_as (struct aspath *ap)
+{
+  struct assegment* cseg;
+  as_t oas = 0;
+
+  if (ap == NULL)
+  {
+    return 0;
+  }
+
+  // take the last element in each segment. At the end the origin is 
+  // written in the oas value.
+  for (cseg = ap->segments; cseg; cseg = cseg->next)
+  {
+    if (cseg->type == AS_SEQUENCE)
+    {
+      oas = cseg->as[cseg->length - 1];
+    }
+  }
+
+  return oas;
+}
+#endif
+
 /* If two aspath have same value then return 1 else return 0 */
 static int
 aspath_cmp (const void *arg1, const void *arg2)
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./bgpd/bgp_table.c	2011-03-21 09:43:34.000000000 -0400
+++ ./bgpd/bgp_table.c	2010-10-18 16:11:05.000000000 -0400
@@ -350,6 +350,7 @@
       if (new->p.prefixlen != p->prefixlen)
 	{
 	  match = new;
+	  bgp_lock_node (match);
 	  new = bgp_node_set (table, p);
 	  set_link (match, new);
 	  table->count++;
@@ -504,3 +505,4 @@
 {
   return table->count;
 }
+
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./bgpd/bgp_info_hash.h	1969-12-31 19:00:00.000000000 -0500
+++ ./bgpd/bgp_info_hash.h	2011-06-01 17:37:25.000000000 -0400
@@ -0,0 +1,35 @@
+#ifndef _QUAGGA_BGP_INFO_HASH_H
+#define _QUAGGA_BGP_INFO_HASH_H
+
+#ifdef USE_SRX
+
+#include "srx/uthash.h"
+
+struct bgp_info_hash_item {
+  uint32_t        identifier;
+  struct bgp_info *info;
+  UT_hash_handle  hh;
+};
+
+struct bgp_info_hash {
+  struct bgp_info_hash_item *table;
+};
+
+/* Install VTY commands - call only once */
+extern void bgp_all_info_hashes_init (void);
+
+/* Create and destroy a info hash */
+extern struct bgp_info_hash* bgp_info_hash_init (void);
+extern void bgp_info_hash_finish (struct bgp_info_hash **);
+
+/* Access the hash */
+/* 1 = registered, 0 = known identifier, -1 = error */
+extern int bgp_info_register (struct bgp_info_hash *, struct bgp_info *,
+                              uint32_t);
+extern void bgp_info_unregister (struct bgp_info_hash *, uint32_t);
+extern struct bgp_info * bgp_info_fetch (struct bgp_info_hash *, uint32_t);
+
+#endif /* USE_SRX */
+
+#endif /* !_QUAGGA_BGP_INFO_HASH_H */
+
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./bgpd/bgp_vty.c	2011-03-21 09:36:46.000000000 -0400
+++ ./bgpd/bgp_vty.c	2011-10-02 13:24:08.000000000 -0400
@@ -1240,6 +1240,450 @@
        "local preference (higher=more preferred)\n"
        "Configure default local preference value\n")
 
+/* SRx */
+#ifdef USE_SRX
+DEFUN (srx_show_config,
+       srx_show_config_cmd,
+       SRX_VTY_CMD_SHOW_CONFIG,
+       SRX_VTY_HLP_SHOW_CONFIG)
+{
+  #define _BLANKS "                 "
+  struct bgp *bgp;
+  int doPolicy;
+  
+  bgp      = vty->index;
+  doPolicy = 0;
+  
+  
+  vty_out (vty, "SRx configuration settings:%s", VTY_NEWLINE);
+  vty_out (vty, "  server.......: %s%s", bgp->srx_host, VTY_NEWLINE);
+  vty_out (vty, "  port.........: %d%s", bgp->srx_port, VTY_NEWLINE);
+  vty_out (vty, "  proxy-id.....: %d%s", bgp->srx_proxyID, VTY_NEWLINE);
+  vty_out (vty, "  keep-window..: %d%s", bgp->srx_keepWindow, VTY_NEWLINE);
+  vty_out (vty, "  evaluation...: ");
+  if (bgp->srx_config & SRX_CONFIG_EVAL_PATH)
+  {
+    vty_out (vty, "bgpsec (prefix-origin and path processing)%s", VTY_NEWLINE);
+  }
+  else if (bgp->srx_config & SRX_CONFIG_EVAL_ORIGIN)
+  {
+    vty_out (vty, "origin_only (prefix-origin processing)%s", VTY_NEWLINE);    
+  }
+  else
+  {
+    vty_out (vty, "disabled!%s", VTY_NEWLINE);    
+  }
+   // always active
+  vty_out (vty, "  policy.......: ");
+  if (bgp->srx_val_policy & SRX_VAL_POLICY_IGNORE_UNKNOWN)    
+  {
+    vty_out (vty, "%signore-unknown%s", (doPolicy ? _BLANKS : ""), VTY_NEWLINE);
+    doPolicy = 1;
+  }
+  if (bgp->srx_val_policy & SRX_VAL_POLICY_IGNORE_INVALID)
+  {
+    vty_out (vty, "%signore-invalid%s", (doPolicy ? _BLANKS : ""), VTY_NEWLINE);
+    doPolicy = 1;
+  }
+  if (bgp->srx_val_policy & SRX_VAL_POLICY_IGNORE_UNDEFINED)
+  {
+    vty_out (vty, "%signore-undefined%s", (doPolicy ? _BLANKS : ""), 
+             VTY_NEWLINE);
+    doPolicy = 1;
+  }  
+  if (bgp->srx_val_local_pref[VAL_LOCPRF_VALID].is_set)
+  {
+    vty_out (vty, "%slocal-preference valid %d", (doPolicy ? _BLANKS : ""), 
+                  bgp->srx_val_local_pref[VAL_LOCPRF_VALID].value);
+    switch (bgp->srx_val_local_pref[VAL_LOCPRF_VALID].relative)
+    {
+      case -1 : vty_out (vty, " SUBTRACT%s", VTY_NEWLINE); break;
+      case  1 : vty_out (vty, " ADD%s", VTY_NEWLINE); break;
+      default: vty_out (vty, "%s", VTY_NEWLINE);
+    }
+    doPolicy = 1;
+  }  
+  if (bgp->srx_val_local_pref[VAL_LOCPRF_UNKNOWN].is_set)
+  {
+    vty_out (vty, "%slocal-preference unknown %d", (doPolicy ? _BLANKS : ""), 
+                  bgp->srx_val_local_pref[VAL_LOCPRF_UNKNOWN].value);
+    switch (bgp->srx_val_local_pref[VAL_LOCPRF_UNKNOWN].relative)
+    {
+      case -1 : vty_out (vty, " SUBTRACT%s", VTY_NEWLINE); break;
+      case  1 : vty_out (vty, " ADD%s", VTY_NEWLINE); break;
+      default: vty_out (vty, "%s", VTY_NEWLINE);
+    }
+    doPolicy = 1;
+  }  
+  if (bgp->srx_val_local_pref[VAL_LOCPRF_INVALID].is_set)
+  {
+    vty_out (vty, "%slocal-preference invalid %d", (doPolicy ? _BLANKS : ""), 
+                  bgp->srx_val_local_pref[VAL_LOCPRF_INVALID].value);
+    switch (bgp->srx_val_local_pref[VAL_LOCPRF_INVALID].relative)
+    {
+      case -1 : vty_out (vty, " SUBTRACT%s", VTY_NEWLINE); break;
+      case  1 : vty_out (vty, " ADD%s", VTY_NEWLINE); break;
+      default: vty_out (vty, "%s", VTY_NEWLINE);
+    }
+    doPolicy = 1;
+  }  
+  if (bgp->srx_val_policy & SRX_VAL_POLICY_PREFER_VALID)
+  {
+    vty_out (vty, "%sprefer-valid%s", (doPolicy ? _BLANKS : ""), VTY_NEWLINE);
+    doPolicy = 1;
+  }
+  if (doPolicy == 0)
+  {
+    vty_out (vty, "%s", VTY_NEWLINE);
+  }
+  
+  vty_out (vty, "  connected....: %s%s", (isConnected(bgp->srxProxy) 
+                                          ? "true" : "false"), VTY_NEWLINE);
+  
+  return CMD_SUCCESS;
+}
+
+DEFUN (srx_connect_short,
+       srx_connect_short_cmd,
+       SRX_VTY_CMD_CONNECT_SHORT,
+       SRX_VTY_HLP_CONNECT_SHORT)
+{
+  struct bgp *bgp;
+  bgp = vty->index;
+
+  /* Host name */
+  if (bgp->srx_host == NULL)
+  {
+    vty_out (vty, "No SRx host name defined%s", VTY_NEWLINE);
+    return CMD_WARNING;    
+  }
+  
+  if (strlen(bgp->srx_host) == 0)
+  { 
+    vty_out (vty, "Empty SRx host name%s", VTY_NEWLINE);
+    return CMD_WARNING;
+  }
+
+  /* Port number */
+  if (bgp->srx_port == 0)
+  {
+    vty_out (vty, "SRx port not specified!%s", VTY_NEWLINE);
+    return CMD_WARNING;    
+  }
+  
+  /* Set configuration */
+  bgp_srx_set (bgp, bgp->srx_host, bgp->srx_port);
+
+  return CMD_SUCCESS;
+}
+
+DEFUN (srx_connect,
+       srx_connect_cmd,
+       SRX_VTY_CMD_CONNECT,
+       SRX_VTY_HLP_CONNECT)
+{
+  struct bgp *bgp;
+  int port;
+
+  bgp = vty->index;
+
+  /* Host name */
+  if (strlen(argv[SRX_VTY_PARAM_CONNECT_SRV]) == 0)
+  { 
+    vty_out (vty, "%% Empty SRx host name%s", VTY_NEWLINE);
+    return CMD_WARNING;
+  }
+
+  /* Port number */
+  VTY_GET_INTEGER_RANGE ("Port", port, argv[SRX_VTY_PARAM_CONNECT_PORT], 
+                         1, 65535);
+
+  /* Set configuration */
+  bgp_srx_set (bgp, argv[SRX_VTY_PARAM_CONNECT_SRV], port);
+
+  return CMD_SUCCESS;
+}
+
+DEFUN (srx_disconnect,
+       srx_disconnect_cmd,
+       SRX_VTY_CMD_DISCONNECT,
+       SRX_VTY_HLP_DISCONNECT)
+{
+  struct bgp *bgp;
+
+  bgp = vty->index;
+  bgp_srx_unset (bgp);
+  return CMD_SUCCESS;
+}
+
+DEFUN (srx_evaluation,
+       srx_evaluation_cmd,
+       SRX_VTY_CMD_EVALUATE,
+       SRX_VTY_HLP_EVALUATE)
+{
+  struct bgp* bgp;
+  int mode;
+  
+  bgp = vty->index;
+  mode = SRX_CONFIG_EVAL_ORIGIN;
+  if (strncmp(argv[0], SRX_VTY_EVAL_BGPSEC, 1) == 0)
+  {
+    mode |= SRX_CONFIG_EVAL_PATH;
+  }
+    
+  bgp_srx_evaluation(bgp, mode);
+  return CMD_SUCCESS;
+}
+
+DEFUN (no_srx_evaluation,
+       no_srx_evaluation_cmd,
+       SRX_VTY_CMD_NO_EVALUATE,
+       SRX_VTY_HLP_NO_EVALUATE)
+{
+  struct bgp *bgp;
+
+  bgp = vty->index;
+  bgp_srx_evaluation (bgp, 0);
+  return CMD_SUCCESS;
+}
+
+
+DEFUN (srx_apply_policy,
+       srx_apply_policy_cmd,
+       SRX_VTY_CMD_APPLY_POLICY,
+       SRX_VTY_HLP_APPLY_POLICY)
+{
+  struct bgp *bgp;
+
+  bgp = vty->index;
+  zlog_debug("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX");
+  srx_bgp_requeue_all(bgp);
+  return CMD_SUCCESS;
+}
+
+// Disabled for this prototype. srx_display_cmd is not installed.
+//
+DEFUN (srx_display,
+       srx_display_cmd,
+       SRX_VTY_CMD_DISPLAY,
+       SRX_VTY_HLP_DISPLAY)
+{
+  struct bgp *bgp;
+
+  bgp = vty->index;
+  bgp_srx_display (bgp, 1);
+  return CMD_SUCCESS;
+}
+
+DEFUN (no_srx_display,
+       no_srx_display_cmd,
+       "no " SRX_VTY_CMD_DISPLAY,
+       NO_STR
+       SRX_VTY_HLP_DISPLAY_NO)
+{
+  struct bgp *bgp;
+
+  bgp = vty->index;
+  bgp_srx_display (bgp, 0);
+  return CMD_SUCCESS;
+}
+
+DEFUN (srx_keepwindow,
+       srx_keepwindow_cmd,
+       SRX_VTY_CMD_KEEPWINDOW,
+       SRX_VTY_HLP_KEEPWINDOW)
+{
+  struct bgp *bgp;
+  
+
+  bgp = vty->index;
+  bgp->srx_keepWindow = strtoul (argv[0], NULL, 10);
+  
+  return CMD_SUCCESS;
+}
+
+// This defines are used to have only ONE location to change the terminal
+// commands and its documentation.
+
+/*
+#define VALIDATION_CMD       SRX_VTY_CMD_POLICY " (" \
+                             SRX_VTY_CMD_PARAM_EVAL_ROA "|" \
+                             SRX_VTY_CMD_PARAM_EVAL_BGPSEC ") "
+#define VALIDATION_CMD_STR   SRX_VTY_CONF_STR \
+                             SRX_VTY_CONF_POLICY_STR \
+                             SRX_VTY_CONF_EVAL_PO_STR \
+                             SRX_VTY_CONF_EVAL_PATH_STR
+
+#define NO_VALIDATION_CMD    "no " VALIDATION_CMD
+#define NO_VALIDATION_CMD_STR NO_STR SRX_VTY_CONF_STR \
+                             SRX_VTY_CONF_POLICY_STR \
+                             SRX_VTY_CONF_EVAL_PO_STR \
+                             SRX_VTY_CONF_EVAL_PATH_STR
+#define VALIDATION_OPTION    "(valid|unknown|invalid) "
+#define VOSTR_VALID          "Update validation returned type: valid\n"
+#define VOSTR_UNKNOWN        "Update validation returned type: unknown\n"
+#define VOSTR_INVALID        "Update validation returned type: invalid\n"
+#define VAL_OPTION_STR        VOSTR_VALID VOSTR_UNKNOWN VOSTR_INVALID
+
+*/
+
+/**
+ *  Scan for the validation result "v" for valid, "u" for unknown, otherwise 
+ * invalid.
+ * 
+ * @param str The local pref validation string (valid, unknown, or invalid)
+ * 
+ * @return the index type VAL_LOCPRF_VALID,VAL_LOCPRF_UNKNOWN, or 
+ *         VAL_LOCPRF_INVALID
+ */
+static int parse_local_pref_index (const char *str)
+{
+  if (strncmp (str, "v", 1) == 0)
+  {
+    return VAL_LOCPRF_VALID;
+  }
+  return (strncmp (str, "u", 1) == 0) ? VAL_LOCPRF_UNKNOWN
+                                      : VAL_LOCPRF_INVALID;
+}
+
+/**
+ * Set the local pref policy
+ * 
+ * @param argc the number of arguments passed
+ * @param type the argument array
+ * @param bgp the bgp struct
+ * @param set 1 == set the value, otherwise unset
+ * @return if the command could be executed successfully
+ */
+static int validation_local_preference(int argc, const char** argv, 
+                                       struct bgp* bgp, int set)
+{
+  int index, relative;
+  uint32_t lp_val;
+
+  index  = parse_local_pref_index (argv[0]);
+  
+  if (set == 1)
+  {
+    lp_val = strtoul (argv[1], NULL, 10);
+
+    if (argc == 2)
+      relative = 0; 
+    else
+      relative = (strncmp (argv[2], "a", 1) == 0) ? 1 : -1;
+
+    srx_val_local_preference_set (bgp, index, relative, lp_val);
+  }
+  else
+  {
+    srx_val_local_preference_unset (bgp, index);    
+  }
+  return CMD_SUCCESS;
+}
+ 
+DEFUN (srx_policy_local_preference_var,
+       srx_policy_local_preference_var_cmd,
+       SRX_VTY_CMD_POL_LOCP_VAR,
+       SRX_VTY_HLP_POL_LOCP_VAR
+       )
+{
+  return validation_local_preference(argc, argv, vty->index, 1);
+}
+
+DEFUN (srx_policy_local_preference_fix,
+       srx_policy_local_preference_fix_cmd,
+       SRX_VTY_CMD_POL_LOCP_FIX,
+       SRX_VTY_HLP_POL_LOCP_FIX
+       )
+{
+  return validation_local_preference(argc, argv, vty->index, 1);
+}
+
+DEFUN (no_srx_policy_local_preference,
+       no_srx_policy_local_preference_cmd,
+       SRX_VTY_CMD_NO_POL_LOCP,
+       SRX_VTY_HLP_NO_POL_LOCP
+       )
+{
+  return validation_local_preference(argc, argv, vty->index, 0);
+}
+
+DEFUN (srx_policy_ignore_unknown,
+       srx_policy_ignore_unknown_cmd,
+       SRX_VTY_CMD_POL_IGNORE_UNKNOWN,
+       SRX_VTY_HLP_POL_IGNORE_UNKNOWN)
+{
+  srx_val_policy_set (vty->index, SRX_VAL_POLICY_IGNORE_UNKNOWN);
+  return  CMD_SUCCESS;
+}
+
+DEFUN (no_srx_policy_ignore_unknown,
+       no_srx_policy_ignore_unknown_cmd,
+       "no " SRX_VTY_CMD_POL_IGNORE_UNKNOWN,
+       NO_STR
+       SRX_VTY_HLP_POL_IGNORE_UNKNOWN)
+{
+  srx_val_policy_unset (vty->index, SRX_VAL_POLICY_IGNORE_UNKNOWN);
+  return  CMD_SUCCESS;
+}
+
+DEFUN (srx_policy_ignore_invalid,
+       srx_policy_ignore_invalid_cmd,
+       SRX_VTY_CMD_POL_IGNORE_INVALID,
+       SRX_VTY_HLP_POL_IGNORE_INVALID)
+{
+  srx_val_policy_set (vty->index, SRX_VAL_POLICY_IGNORE_INVALID);
+  return  CMD_SUCCESS;
+}
+
+DEFUN (no_srx_policy_ignore_invalid,
+       no_srx_policy_ignore_invalid_cmd,
+       "no " SRX_VTY_CMD_POL_IGNORE_INVALID,
+       NO_STR
+       SRX_VTY_HLP_POL_IGNORE_INVALID)
+{
+  srx_val_policy_unset (vty->index, SRX_VAL_POLICY_IGNORE_INVALID);
+  return  CMD_SUCCESS;
+}
+
+DEFUN (srx_policy_ignore_undefined,
+       srx_policy_ignore_undefined_cmd,
+       SRX_VTY_CMD_POL_IGNORE_UNDEFINED,
+       SRX_VTY_HLP_POL_IGNORE_UNDEFINED)
+{
+  srx_val_policy_set (vty->index, SRX_VAL_POLICY_IGNORE_UNDEFINED);
+  return  CMD_SUCCESS;
+}
+
+DEFUN (no_srx_policy_ignore_undefined,
+       no_srx_policy_ignore_undefined_cmd,
+       "no " SRX_VTY_CMD_POL_IGNORE_UNDEFINED,
+       NO_STR
+       SRX_VTY_HLP_POL_IGNORE_UNDEFINED)
+{
+  srx_val_policy_unset (vty->index, SRX_VAL_POLICY_IGNORE_UNDEFINED);
+  return  CMD_SUCCESS;
+}
+
+DEFUN (srx_policy_prefer_valid,
+       srx_policy_prefer_valid_cmd,
+       SRX_VTY_CMD_POL_PREFV,
+       SRX_VTY_HLP_POL_PREFV)
+{
+  return srx_val_policy_set (vty->index, SRX_VAL_POLICY_PREFER_VALID);
+}
+
+DEFUN (no_srx_policy_prefer_valid,
+       no_srx_policy_prefer_valid_cmd,
+       "no " SRX_VTY_CMD_POL_PREFV,
+       NO_STR
+       SRX_VTY_HLP_POL_PREFV)
+{
+  return srx_val_policy_unset (vty->index, SRX_VAL_POLICY_PREFER_VALID);
+}
+
+#endif /* USE_SRX */
+
 static int
 peer_remote_as_vty (struct vty *vty, const char *peer_str, 
                     const char *as_str, afi_t afi, safi_t safi)
@@ -6717,6 +7161,13 @@
                                      ents * sizeof (struct bgp_node)),
                        VTY_NEWLINE);
               
+              /* SRx */
+              #ifdef USE_SRX
+              vty_out (vty,
+                       "SRx host %s, port %d%s",
+                       bgp->srx_host, bgp->srx_port, VTY_NEWLINE);
+              #endif
+              
               /* Peer related usage */
               ents = listcount (bgp->peer);
               vty_out (vty, "Peers %ld, using %s of memory%s",
@@ -8960,6 +9411,42 @@
   install_element (BGP_NODE, &no_bgp_default_local_preference_cmd);
   install_element (BGP_NODE, &no_bgp_default_local_preference_val_cmd);
 
+  /* "srx *" commands. */
+#ifdef USE_SRX
+  install_element (BGP_NODE, &srx_show_config_cmd);
+  
+  install_element (BGP_NODE, &srx_connect_short_cmd);  
+  install_element (BGP_NODE, &srx_connect_cmd);
+  install_element (BGP_NODE, &srx_disconnect_cmd);
+
+  install_element (BGP_NODE, &srx_evaluation_cmd);
+  install_element (BGP_NODE, &no_srx_evaluation_cmd);  
+
+// NOT IN THIS VERSION
+//  install_element (BGP_NODE, &srx_apply_policy_cmd);
+  
+  install_element (BGP_NODE, &srx_display_cmd);
+  install_element (BGP_NODE, &no_srx_display_cmd);    
+
+  install_element (BGP_NODE, &srx_keepwindow_cmd);
+  
+  install_element (BGP_NODE, &srx_policy_local_preference_var_cmd);
+  install_element (BGP_NODE, &srx_policy_local_preference_fix_cmd);
+  install_element (BGP_NODE, &no_srx_policy_local_preference_cmd);
+  
+  install_element (BGP_NODE, &srx_policy_ignore_unknown_cmd);
+  install_element (BGP_NODE, &no_srx_policy_ignore_unknown_cmd);
+  
+  install_element (BGP_NODE, &srx_policy_ignore_invalid_cmd);
+  install_element (BGP_NODE, &no_srx_policy_ignore_invalid_cmd);
+
+  install_element (BGP_NODE, &srx_policy_ignore_undefined_cmd);
+  install_element (BGP_NODE, &no_srx_policy_ignore_undefined_cmd);
+
+  install_element (BGP_NODE, &srx_policy_prefer_valid_cmd);
+  install_element (BGP_NODE, &no_srx_policy_prefer_valid_cmd);  
+#endif
+
   /* "neighbor remote-as" commands. */
   install_element (BGP_NODE, &neighbor_remote_as_cmd);
   install_element (BGP_NODE, &no_neighbor_cmd);
@@ -9952,7 +10439,7 @@
   switch (ret)
     {
     case COMMUNITY_LIST_ERR_CANT_FIND_LIST:
-      vty_out (vty, "%% Can't find community-list%s", VTY_NEWLINE);
+      vty_out (vty, "%% Can't find communit-list%s", VTY_NEWLINE);
       break;
     case COMMUNITY_LIST_ERR_MALFORMED_VAL:
       vty_out (vty, "%% Malformed community-list value%s", VTY_NEWLINE);
@@ -10313,7 +10800,7 @@
   list = community_list_lookup (bgp_clist, argv[0], COMMUNITY_LIST_MASTER);
   if (! list)
     {
-      vty_out (vty, "%% Can't find community-list%s", VTY_NEWLINE);
+      vty_out (vty, "%% Can't find communit-list%s", VTY_NEWLINE);
       return CMD_WARNING;
     }
 
@@ -10663,7 +11150,7 @@
   list = community_list_lookup (bgp_clist, argv[0], EXTCOMMUNITY_LIST_MASTER);
   if (! list)
     {
-      vty_out (vty, "%% Can't find extcommunity-list%s", VTY_NEWLINE);
+      vty_out (vty, "%% Can't find extcommunit-list%s", VTY_NEWLINE);
       return CMD_WARNING;
     }
 
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./bgpd/bgp_route.h	2011-03-21 10:32:49.000000000 -0400
+++ ./bgpd/bgp_route.h	2011-08-30 18:30:10.000000000 -0400
@@ -22,6 +22,10 @@
 #define _QUAGGA_BGP_ROUTE_H
 
 #include "bgp_table.h"
+#ifdef USE_SRX
+#include "bgp_info_hash.h"
+#include <srx/srx_api.h>
+#endif
 
 /* Ancillary information to struct bgp_info, 
  * used for uncommonly used data (aggregation, MPLS, etc.)
@@ -76,6 +80,9 @@
 #define BGP_INFO_STALE          (1 << 8)
 #define BGP_INFO_REMOVED        (1 << 9)
 #define BGP_INFO_COUNTED	(1 << 10)
+#ifdef USE_SRX
+#define BGP_INFO_IGNORE         (1 << 11)
+#endif
 
   /* BGP route type.  This can be static, RIP, OSPF, BGP etc.  */
   u_char type;
@@ -87,6 +94,17 @@
 #define BGP_ROUTE_STATIC       1
 #define BGP_ROUTE_AGGREGATE    2
 #define BGP_ROUTE_REDISTRIBUTE 3 
+
+#ifdef USE_SRX
+  struct bgp_node        *node;
+  struct bgp_info_hash   *info_hash;
+  SRxUpdateID            updateID;
+//  int                    lpref_adj_do;
+//  int                    lpref_adj_relative;
+//  uint32_t               lpref_adj_value;
+  SRxValidationResultVal val_res_ROA;
+  SRxValidationResultVal val_res_BGPSEC;    
+#endif
 };
 
 /* BGP static route configuration. */
@@ -116,11 +134,19 @@
 
   /* MPLS label.  */
   u_char tag[3];
+  
+  /* AS-Pathlimit TTL */
+  u_char ttl;
 };
 
 /* Flags which indicate a route is unuseable in some form */
+#ifdef USE_SRX
+#define BGP_INFO_UNUSEABLE \
+  (BGP_INFO_HISTORY|BGP_INFO_DAMPED|BGP_INFO_REMOVED|BGP_INFO_IGNORE)
+#else
 #define BGP_INFO_UNUSEABLE \
   (BGP_INFO_HISTORY|BGP_INFO_DAMPED|BGP_INFO_REMOVED)
+#endif
 /* Macro to check BGP information is alive or not.  Sadly,
  * not equivalent to just checking previous, because of the
  * sense of the additional VALID flag.
@@ -186,6 +212,19 @@
 extern struct bgp_info_extra *bgp_info_extra_get (struct bgp_info *);
 extern void bgp_info_set_flag (struct bgp_node *, struct bgp_info *, u_int32_t);
 extern void bgp_info_unset_flag (struct bgp_node *, struct bgp_info *, u_int32_t);
+#ifdef USE_SRX
+extern void bgp_info_set_identifier (struct bgp_info *, struct bgp_info_hash *,
+                                     uint32_t);
+extern int  bgp_info_set_ignore_flag(struct bgp_info *);
+extern void srx_bgp_requeue_update(struct bgp_info *);
+extern void srx_bgp_requeue_all(struct bgp *);
+extern void bgp_info_set_validation_result (struct bgp_info *, 
+                                       ValidationResultType resType, 
+                                       uint8_t roaResult, uint8_t bgpsecResult);
+extern void verify_update (struct bgp *, struct bgp_info *, SRxDefaultResult *, 
+                           bool forceReceipt);
+extern int  srx_calc_validation_state(struct bgp *, struct bgp_info *);
+#endif
 
 extern int bgp_nlri_sanity_check (struct peer *, int, u_char *, bgp_size_t);
 extern int bgp_nlri_parse (struct peer *, struct attr *, struct bgp_nlri *);
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./bgpd/bgp_debug.c	2011-03-21 07:09:13.000000000 -0400
+++ ./bgpd/bgp_debug.c	2010-10-18 16:11:28.000000000 -0400
@@ -331,6 +331,7 @@
        undebug_bgp_as4_cmd,
        "undebug bgp as4",
        UNDEBUG_STR
+       DEBUG_STR
        BGP_STR
        "BGP AS4 actions\n")
 
@@ -339,7 +340,6 @@
        "debug bgp as4 segment",
        DEBUG_STR
        BGP_STR
-       "BGP AS4 actions\n"
        "BGP AS4 aspath segment handling\n")
 {
   if (vty->node == CONFIG_NODE)
@@ -358,7 +358,6 @@
        NO_STR
        DEBUG_STR
        BGP_STR
-       "BGP AS4 actions\n"
        "BGP AS4 aspath segment handling\n")
 {
   if (vty->node == CONFIG_NODE)
@@ -375,8 +374,8 @@
        undebug_bgp_as4_segment_cmd,
        "undebug bgp as4 segment",
        UNDEBUG_STR
+       DEBUG_STR
        BGP_STR
-       "BGP AS4 actions\n"
        "BGP AS4 aspath segment handling\n")
 
 DEFUN (debug_bgp_fsm,
@@ -418,6 +417,7 @@
        undebug_bgp_fsm_cmd,
        "undebug bgp fsm",
        UNDEBUG_STR
+       DEBUG_STR
        BGP_STR
        "Finite State Machine\n")
 
@@ -715,6 +715,7 @@
        undebug_bgp_zebra_cmd,
        "undebug bgp zebra",
        UNDEBUG_STR
+       DEBUG_STR
        BGP_STR
        "BGP Zebra messages\n")
 
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./bgpd/bgpd.c	2011-03-21 09:36:46.000000000 -0400
+++ ./bgpd/bgpd.c	2011-09-16 20:38:41.000000000 -0400
@@ -60,6 +60,16 @@
 #ifdef HAVE_SNMP
 #include "bgpd/bgp_snmp.h"
 #endif /* HAVE_SNMP */
+#ifdef USE_SRX
+#include "bgpd/bgp_info_hash.h"
+
+// Forward Declaration
+static void handleSRxValidationResult (SRxValidationResult* result, 
+                                       void* bgpRouter);
+static void handleSRxSignatures(SRxUpdateID* updateID, BGPSecData* data,
+                                void* bgpRouter);
+static void handleSRxSynchRequest(void* bgpRouter);
+#endif
 
 /* BGP process wide configuration.  */
 static struct bgp_master bgp_master;
@@ -154,6 +164,23 @@
   return CHECK_FLAG (bgp->config, config);
 }
 
+#ifdef USE_SRX
+static void srx_config_set (struct bgp *bgp, int config)
+{
+  SET_FLAG (bgp->srx_config, config);
+}
+
+static void srx_config_unset (struct bgp *bgp, int config)
+{
+  UNSET_FLAG (bgp->srx_config, config);
+}
+
+int srx_config_check (struct bgp *bgp, uint16_t config)
+{
+  return CHECK_FLAG (bgp->srx_config, config);
+}
+#endif
+
 /* Set BGP router identifier. */
 int
 bgp_router_id_set (struct bgp *bgp, struct in_addr *id)
@@ -507,6 +534,213 @@
   return 0;
 }
 
+#ifdef USE_SRX
+
+/**
+ * Store the SRx settings for this BGP router.
+ * 
+ * @param bgp The bgp router instance
+ * @param host The host name or address of the SRx server
+ * @param port The port number of the SRx server
+ * @return 0
+ */
+int bgp_srx_set(struct bgp *bgp, const char *host, int port)
+{
+  int prev_set, same_host = 0, same_port = 0;
+
+  prev_set = bgp_config_check (bgp, BGP_CONFIG_SRX);
+  if (prev_set)
+  {
+    same_host = (strcmp (bgp->srx_host, host) == 0);
+    same_port = (bgp->srx_port == port);
+
+    XFREE (MTYPE_SRX_HOST, bgp->srx_host);
+  }
+
+  if (same_host && same_port)
+  {
+    // Check if SRx is connected.
+    if (isConnected(bgp->srxProxy))
+    {
+      return 0;
+    }
+  }
+
+  bgp_config_set (bgp, BGP_CONFIG_SRX);
+  bgp->srx_host = XSTRDUP (MTYPE_SRX_HOST, host);
+  bgp->srx_port = port;
+
+  if (bgp->srxProxy != NULL)
+  {
+    if (prev_set)
+    {
+      zlog_debug ("Disconnect and create new proxy (same ID)!");      
+      disconnectFromSRx (bgp->srxProxy, 0);      
+      releaseSRxProxy(bgp->srxProxy);
+      bgp->srxProxy = createSRxProxy(handleSRxValidationResult, 
+                                     handleSRxSignatures, handleSRxSynchRequest, 
+                                     bgp->srx_proxyID, bgp->as, bgp);        
+    }
+
+    bool cret = connectToSRx (bgp->srxProxy, bgp->srx_host, bgp->srx_port, 
+                              bgp->srx_handshakeTimeout);
+    bgp->srx_proxyID = bgp->srxProxy->proxyID;
+    zlog_debug ("Connect to SRx server %s:%d: %s", bgp->srx_host, 
+                bgp->srx_port, cret ? "OK" : "Failed");
+  }
+
+  return 0;
+}
+
+/**
+ * disconnect from srx server
+ * 
+ * @param bgp the bgp struct
+ * @param server the server the bgp struct is connected to
+ * 
+ * @return 0 successful, -1 unsuccessful
+ */
+int bgp_srx_unset (struct bgp *bgp)
+{
+  int retVal = 0;
+  
+  if (bgp_config_check (bgp, BGP_CONFIG_SRX))
+  {
+    bgp_config_unset (bgp, BGP_CONFIG_SRX);
+    XFREE (MTYPE_SRX_HOST, bgp->srx_host);
+
+    disconnectFromSRx (bgp->srxProxy, bgp->srx_keepWindow);
+  }
+  else
+  {
+    zlog_info("BGP session is not connected to an SRx server!");
+    retVal = -1;
+  }
+
+  return retVal;
+}
+
+/**
+ * Set or unset the srx result processing.
+ * 
+ * @param bgp the bgo router instance.
+ * @param mode 0 == disable, otherwise the prefix-origin or BGPSEC processing,
+ * @return 0
+ */
+int bgp_srx_evaluation (struct bgp *bgp, int mode)
+{
+  if (mode == 0)
+  {
+    // unset
+    if (srx_config_check(bgp, SRX_CONFIG_EVAL_PATH))
+    {
+      srx_config_unset (bgp, SRX_CONFIG_EVAL_PATH);    
+    }
+    if (srx_config_check(bgp, SRX_CONFIG_EVAL_ORIGIN))
+    {
+      srx_config_unset (bgp, SRX_CONFIG_EVAL_ORIGIN);    
+    }
+  }
+  else if (CHECK_FLAG (mode,  SRX_CONFIG_EVAL_PATH))
+  {
+    srx_config_set (bgp, SRX_CONFIG_EVAL_ORIGIN);            
+    srx_config_set (bgp, SRX_CONFIG_EVAL_PATH);            
+  }
+  else if (CHECK_FLAG (mode,  SRX_CONFIG_EVAL_ORIGIN))
+  {
+    srx_config_set (bgp, SRX_CONFIG_EVAL_ORIGIN);
+    if (srx_config_check(bgp, SRX_CONFIG_EVAL_PATH))
+    {
+      srx_config_unset (bgp, SRX_CONFIG_EVAL_PATH);    
+    }
+  }
+  
+  return 0;
+}
+
+/**
+ * Enable or disable the srx validation result
+ * 
+ * @param bgp The bgp router instance
+ * @param enable enable or disable the additional information output
+ * @return 0
+ */
+int bgp_srx_display (struct bgp *bgp, int enable)
+{
+  if (enable)
+  {
+    srx_config_set (bgp, SRX_CONFIG_DISPLAY_INFO);
+  }
+  else
+  {
+    srx_config_unset (bgp, SRX_CONFIG_DISPLAY_INFO);
+  }
+  
+  return 0;
+}
+
+/**
+ * Set the manipulation value for the local preference and enables the policy 
+ * for the given validation result
+ * 
+ * @param bgp the bgp router instance
+ * @param index the validation result (valid, unknown, invalid)
+ * @param relative is this value relative or absolute
+ * @param value the value itself. (negative = subtract, positive = add)
+ * @return 0
+ */
+int srx_val_local_preference_set (struct bgp *bgp, int index, int relative, 
+                              uint32_t value)
+{
+  bgp->srx_val_local_pref[index].is_set = 1;
+  bgp->srx_val_local_pref[index].relative = relative;
+  bgp->srx_val_local_pref[index].value = value;
+  return 0;
+}
+
+/**
+ * Reset the local pref manipulation value and disables this policy for the 
+ * given validation result.
+ * 
+ * @param bgp the bgp router instance
+ * @param index the validation result (valid, unknown, invalid)
+ * @return 0
+ */
+int srx_val_local_preference_unset (struct bgp *bgp, int index)
+{
+  bgp->srx_val_local_pref[index].is_set = 0;
+  bgp->srx_val_local_pref[index].relative = 1;
+  bgp->srx_val_local_pref[index].value = 0;
+  return 0;
+}
+
+/**
+ * Set the given flag.
+ * 
+ * @param bgp the bgp router instance
+ * @param policy the policy flag to be set
+ * @return 0
+ */
+int srx_val_policy_set (struct bgp *bgp, uint16_t policy) 
+{
+  SET_FLAG (bgp->srx_val_policy, policy);
+  return 0;
+}
+
+/**
+ * Reset the give flag.
+ * 
+ * @param bgp the bgp router instance.
+ * @param opt the flag to be set
+ * @return 0
+ */
+int srx_val_policy_unset (struct bgp *bgp, uint16_t policy) 
+{
+  UNSET_FLAG (bgp->srx_val_policy, policy);
+  return 0;
+}
+#endif
+
 /* If peer is RSERVER_CLIENT in at least one address family and is not member
     of a peer_group for that family, return 1.
     Used to check wether the peer is included in list bgp->rsclient. */
@@ -1913,6 +2147,176 @@
   return 0;
 }
 
+#ifdef USE_SRX
+
+static void srxLockUpdate(struct bgp_info* info)
+{
+  // TODO LOCK MUTEX OR WHATEVER
+}
+
+static void srxUnLockUpdate(struct bgp_info* info)
+{
+  // TODO UNLOCK MUTEX OR WHATEVER  
+}
+
+
+/* Called by proxy once notifications are received. */
+static void handleSRxValidationResult (SRxValidationResult* result,
+                                       void* bgpRouter)
+{
+  struct bgp_info* info;
+  struct bgp*      bgp   = (struct bgp*)bgpRouter;
+  int              retry = 3; 
+  
+  // TODO: Find a much better way to resolve this racing condition!
+  // The racing condition is that an initial update request providing default 
+  // result values that differ from the validation results that are computed 
+  // shortly after will be overwritten here but the Update itself is not 
+  // registered yet in the update ID pool.
+  
+  while (retry > 0) // Not very nice work around to a racing condition.
+  {    
+    // Retrieve the Update by using the update ID.
+    info = bgp_info_fetch(bgp->info_hash, result->updateID);
+    if (info)
+    {
+      // Set the Update validation result values
+      bgp_info_set_validation_result (info, result->valType, 
+                                      result->valResult.roaResult, 
+                                      result->valResult.bgpsecResult);
+      retry = 0;
+    }
+    else
+    {
+      // Give the system some time to process the initial update validation 
+      // request.
+      retry--;
+      zlog_info("Yield and allow update [0x%08X] to be registered!", 
+                result->updateID);
+      //shed_yield();
+      pthread_yield();
+      zlog_info("Sleep and allow update [0x%08X] to be registered!", 
+                result->updateID);
+      sleep(1);
+      if (retry <= 0)
+      {
+        //raise(11);
+				zlog_info("I give up!");
+      }
+    }
+  }
+
+  if (info == NULL)
+  { // This is BAD after 15 seconds the update still does not exist.
+    zlog_err("Received validation result for unknown update [0x%08X]!", 
+             result->updateID);
+    deleteUpdate(bgp->srxProxy, bgp->srx_keepWindow, &result->updateID);
+  }
+}
+
+/* Called by proxy once notifications are received. */
+static void handleSRxSignatures(SRxUpdateID* updateID, BGPSecData* data,
+                                void* bgpRouter)
+{
+  zlog_info ("*** Received SRx Signatures for update [0x%08X]! ***\n", 
+             *updateID);
+  // TODO: Add the signature to the update that was/will be send out.
+}
+
+/**
+ * Send a validation request for each update in the given table.
+ * 
+ * @param bgp
+ * @param table
+ */
+static void _handleSRxSynchRequest_processTable(struct bgp* bgp, 
+                                                struct bgp_table* table)
+{
+  struct bgp_info *binfo;
+  struct bgp_node *bnode;
+  
+  SRxDefaultResult defResult;
+  
+  /* Start processing of routes. */
+  for (bnode = bgp_table_top(table); bnode; bnode = bgp_route_next(bnode))
+  {
+    if (bnode->info != NULL)
+    {
+      binfo  = (struct bgp_info*)bnode->info;
+      srxLockUpdate(binfo);
+      defResult.resSourceROA    = SRxRS_ROUTER;
+      defResult.resSourceBGPSEC = SRxRS_ROUTER;
+      defResult.result.roaResult    = binfo->val_res_ROA;
+      defResult.result.bgpsecResult = binfo->val_res_BGPSEC;
+      
+      verify_update (bgp, binfo, &defResult, false);
+      srxUnLockUpdate(binfo);
+    }
+  }
+}
+
+
+/**
+ * Called by proxy once a synchronization request is received. The request will
+ * only be served as long as SRx is connected to the router, regardless of 
+ * the SRx evaluation setting.
+ * 
+ * @param bgpRouter A pointer to the bgp router instance that received this 
+ *        request
+ */
+static void handleSRxSynchRequest(void* bgpRouter)
+{
+  zlog_info ("*** Received SRx Synchronization Request! ***\n");
+  
+  struct bgp* bgp = (struct bgp*)bgpRouter;
+  if (bgp == NULL)
+  {
+    zlog_err("*** SRx did not provide configured BGP session for "
+             "synchronization request");
+    return;
+  }
+  
+  _handleSRxSynchRequest_processTable(bgp, bgp->rib[AFI_IP][SAFI_MULTICAST]);
+  _handleSRxSynchRequest_processTable(bgp, bgp->rib[AFI_IP][SAFI_UNICAST]);
+}
+
+/**
+ * Is called by bgp_create and initialized the srx default settings in the 
+ * bgp router. 
+ * 
+ * this method creates the info hash, the scxProxy, and the following settings:
+ * srx_proxyID, srx_keepWindow, srx_handshakeTimeout
+ * and the following policies:
+ * ignore-unknown
+ * 
+ * @param bgp the bgp router instance.
+ */
+static void srx_set_default(struct bgp *bgp)
+{
+  bgp->info_hash            = bgp_info_hash_init (); 
+  bgp->srx_proxyID          = SRX_PROXYID;
+  bgp->srx_keepWindow       = SRX_KEEP_WINDOW;
+  bgp->srx_handshakeTimeout = SRX_HANDHAKE_TIMEOUT;
+  
+  // Can be turned off using config file
+  bgp->srx_val_policy        = SRX_VAL_POLICY_IGNORE_UNDEFINED;
+
+  // Turn on only prefix origin validation and srx info display. This default 
+  // setting might be changed into both ROA as well as path
+  bgp->srx_config            =   SRX_CONFIG_EVAL_ORIGIN 
+                               | SRX_CONFIG_DISPLAY_INFO; 
+  
+  // Set the default result values.
+  bgp->srx_default_roaVal    = SRx_RESULT_UNDEFINED;
+  bgp->srx_default_bgpsecVal = SRx_RESULT_UNDEFINED;
+  
+  
+  bgp->srxProxy = createSRxProxy(handleSRxValidationResult, handleSRxSignatures,
+                                 handleSRxSynchRequest, bgp->srx_proxyID,
+                                 bgp->as, bgp);  
+}
+#endif
+
 /* BGP instance creation by `router bgp' commands. */
 static struct bgp *
 bgp_create (as_t *as, const char *name)
@@ -1956,6 +2360,10 @@
   if (name)
     bgp->name = strdup (name);
 
+#ifdef USE_SRX
+  srx_set_default(bgp);
+#endif  
+  
   return bgp;
 }
 
@@ -2143,6 +2551,15 @@
 	if (bgp->rib[afi][safi])
           bgp_table_finish (&bgp->rib[afi][safi]);
       }
+
+#ifdef USE_SRX
+  bgp_info_hash_finish (&bgp->info_hash);
+  if (bgp->srxProxy) 
+  {
+    releaseSRxProxy (bgp->srxProxy);
+  }
+#endif
+
   XFREE (MTYPE_BGP, bgp);
 }
 
@@ -4952,6 +5369,91 @@
   return write;
 }
 
+#ifdef USE_SRX
+static int srx_config_write_configuration (struct vty *vty, struct bgp *bgp)
+{
+  static const char *INDEX_STR[3] =
+  {
+    "valid",
+    "unknown",
+    "invalid"
+  };
+    
+  int noElements = 3; // Number of elements in the above INDEX_STR
+  int index;
+
+  // ENABLE / DISABLE DISPLAY
+  vty_out (vty, " !SRx Configuration Settigns%s %s%s%s", VTY_NEWLINE, 
+           srx_config_check(bgp, SRX_CONFIG_DISPLAY_INFO) ? "" : "no ", 
+           SRX_VTY_CMD_DISPLAY, VTY_NEWLINE);        
+  
+  // CONNECT TO SRX
+  if (bgp_config_check(bgp, BGP_CONFIG_SRX))
+  {
+   vty_out (vty, " srx connect %s %d%s", 
+                 bgp->srx_host, bgp->srx_port, VTY_NEWLINE);
+  }
+  
+  // EVALUATION MODE
+  if (srx_config_check(bgp, SRX_CONFIG_EVAL_PATH)) 
+  { // if this is set the ROA flag is set too -> BGPSEC
+   vty_out (vty, " srx evaluation bgpsec%s", VTY_NEWLINE);        
+  }
+  else if (srx_config_check(bgp, SRX_CONFIG_EVAL_ORIGIN))
+  {
+   vty_out (vty, " srx evaluation roa_only%s", VTY_NEWLINE);        
+  }
+  else
+  {
+   vty_out (vty, " no srx evaluation%s", VTY_NEWLINE);            
+  }
+  
+  // KEEP WINDOW
+  vty_out (vty, " srx keep-window %d%s", bgp->srx_keepWindow,  VTY_NEWLINE);        
+  
+  // VALIDATION POLICY LOCAL PREF
+  for (index = 0; index < noElements; index++)
+  {
+    if (bgp->srx_val_local_pref[index].is_set) 
+    {
+    	vty_out (vty, " " SRX_VTY_CMD_POL_LOCP " %s %u", INDEX_STR[index],
+                    bgp->srx_val_local_pref[index].value);
+
+      if (bgp->srx_val_local_pref[index].relative)
+      {
+        vty_out (vty, " %s", (bgp->srx_val_local_pref[index].relative == 1)
+                             ? "add" : "subtract");
+      }
+
+      vty_out (vty, "%s", VTY_NEWLINE);
+    }
+  }
+
+  // VALIDATION POLICY PREFER VALID
+  if (CHECK_FLAG (bgp->srx_val_policy, SRX_VAL_POLICY_PREFER_VALID))
+  {
+    vty_out (vty, " %s%s", SRX_VTY_CMD_POL_PREFV, VTY_NEWLINE);        
+  }
+
+  // VALIDATION POLICY IGNORE ...  
+  if (CHECK_FLAG (bgp->srx_val_policy, SRX_VAL_POLICY_IGNORE_UNKNOWN))
+  {
+    if (srx_config_check(bgp, SRX_CONFIG_EVAL_PATH)) // BGPSec Processing
+    {
+      vty_out (vty, "!  The following policy only applies to \"" 
+                    " srx evaluation roa_only\" %s!", VTY_NEWLINE);
+    }
+    vty_out (vty, " %s%s", SRX_VTY_CMD_POL_IGNORE_UNKNOWN, VTY_NEWLINE);        
+  }
+  if (CHECK_FLAG (bgp->srx_val_policy, SRX_VAL_POLICY_IGNORE_INVALID))
+  {
+    vty_out (vty, " " SRX_VTY_CMD_POL_IGNORE_INVALID "%s", VTY_NEWLINE);        
+  }
+
+  return 0;
+}
+#endif
+
 int
 bgp_config_write (struct vty *vty)
 {
@@ -5138,6 +5640,11 @@
       /* IPv6 multicast configuration.  */
       write += bgp_config_write_family (vty, bgp, AFI_IP6, SAFI_MULTICAST);
 
+      /* SRx Settings */
+      #ifdef USE_SRX
+      srx_config_write_configuration (vty, bgp);
+      #endif
+
       write++;
     }
   return write;
@@ -5174,6 +5681,9 @@
   bgp_route_map_init ();
   bgp_scan_init ();
   bgp_mplsvpn_init ();
+#ifdef USE_SRX
+  bgp_all_info_hashes_init ();
+#endif
 
   /* Access list initialize. */
   access_list_init ();
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospfd/ospf_lsdb.c	2011-03-21 07:09:13.000000000 -0400
+++ ./ospfd/ospf_lsdb.c	2010-10-18 16:13:42.000000000 -0400
@@ -120,10 +120,7 @@
   
   /* nothing to do? */
   if (rn->info && rn->info == lsa)
-    {
-      route_unlock_node (rn);
       return;
-    }
   
   /* purge old entry? */
   if (rn->info)
@@ -165,12 +162,11 @@
       return;
     }
   
-  assert (lsa->data->type < OSPF_MAX_LSA);
   table = lsdb->type[lsa->data->type].db;
   lsdb_prefix_set (&lp, lsa);
-  if ((rn = route_node_lookup (table, (struct prefix *) &lp)))
+  rn = route_node_lookup (table, (struct prefix *) &lp);
+  if (rn && (rn->info == lsa))
     {
-      if (rn->info == lsa)
         ospf_lsdb_delete_entry (lsdb, rn);
       route_unlock_node (rn); /* route_node_lookup */
     }
@@ -278,8 +274,7 @@
       rn = route_top (table);
   else
     {
-      if ((rn = route_node_lookup (table, (struct prefix *) &lp)) == NULL)
-        return NULL;
+      rn = route_node_get (table, (struct prefix *) &lp);
       rn = route_next (rn);
     }
 
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospfd/ospf_network.c	2011-03-21 05:43:52.000000000 -0400
+++ ./ospfd/ospf_network.c	2010-10-18 16:13:47.000000000 -0400
@@ -61,7 +61,7 @@
 	       "on # of multicast group memberships has been exceeded?",
                top->fd, inet_ntoa(p->u.prefix4), ifindex, safe_strerror(errno));
   else
-    zlog_debug ("interface %s [%u] join AllSPFRouters Multicast group.",
+    zlog_info ("interface %s [%u] join AllSPFRouters Multicast group.",
 	       inet_ntoa (p->u.prefix4), ifindex);
 
   return ret;
@@ -81,7 +81,7 @@
 	       "ifindex %u, AllSPFRouters): %s",
                top->fd, inet_ntoa(p->u.prefix4), ifindex, safe_strerror(errno));
   else
-    zlog_debug ("interface %s [%u] leave AllSPFRouters Multicast group.",
+    zlog_info ("interface %s [%u] leave AllSPFRouters Multicast group.",
 	        inet_ntoa (p->u.prefix4), ifindex);
 
   return ret;
@@ -103,7 +103,7 @@
 	       "on # of multicast group memberships has been exceeded?",
                top->fd, inet_ntoa(p->u.prefix4), ifindex, safe_strerror(errno));
   else
-    zlog_debug ("interface %s [%u] join AllDRouters Multicast group.",
+    zlog_info ("interface %s [%u] join AllDRouters Multicast group.",
 	        inet_ntoa (p->u.prefix4), ifindex);
 
   return ret;
@@ -123,7 +123,7 @@
 	       "ifindex %u, AllDRouters): %s",
                top->fd, inet_ntoa(p->u.prefix4), ifindex, safe_strerror(errno));
   else
-    zlog_debug ("interface %s [%u] leave AllDRouters Multicast group.",
+    zlog_info ("interface %s [%u] leave AllDRouters Multicast group.",
 	        inet_ntoa (p->u.prefix4), ifindex);
 
   return ret;
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospfd/ospf_zebra.c	2011-03-21 05:43:52.000000000 -0400
+++ ./ospfd/ospf_zebra.c	2010-10-18 16:13:46.000000000 -0400
@@ -929,9 +929,14 @@
   struct external_info *ei;
   struct route_table *rt;
   struct ospf_lsa *lsa;
-  int type, default_refresh = 0;
+  intptr_t type;
   struct ospf *ospf;
 
+  type = (intptr_t)THREAD_ARG (thread);
+  assert (type <= ZEBRA_ROUTE_MAX);
+  
+  rt = EXTERNAL_INFO (type);
+
   ospf = ospf_lookup ();
   if (ospf == NULL)
     return 0;
@@ -941,24 +946,17 @@
   zlog_info ("Zebra[Redistribute]: distribute-list update timer fired!");
 
   /* foreach all external info. */
-  for (type = 0; type <= ZEBRA_ROUTE_MAX; type++)
-    {
-      rt = EXTERNAL_INFO (type);
-      if (!rt)
-	continue;
+  if (rt)
       for (rn = route_top (rt); rn; rn = route_next (rn))
 	if ((ei = rn->info) != NULL)
 	  {
 	    if (is_prefix_default (&ei->p))
-	      default_refresh = 1;
+            ospf_external_lsa_refresh_default (ospf);
 	    else if ((lsa = ospf_external_info_find_lsa (ospf, &ei->p)))
 	      ospf_external_lsa_refresh (ospf, lsa, ei, LSA_REFRESH_IF_CHANGED);
 	    else
 	      ospf_external_lsa_originate (ospf, ei);
 	  }
-    }
-  if (default_refresh)
-    ospf_external_lsa_refresh_default (ospf);
   return 0;
 }
 
@@ -974,9 +972,9 @@
   if (!(rt = EXTERNAL_INFO (type)))
     return;
 
-  /* If exists previously invoked thread, then let it continue. */
+  /* If exists previously invoked thread, then cancel it. */
   if (ospf->t_distribute_update)
-    return;
+    OSPF_TIMER_OFF (ospf->t_distribute_update);
 
   /* Set timer. */
   ospf->t_distribute_update =
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospfd/ospf_flood.h	2011-03-21 05:43:52.000000000 -0400
+++ ./ospfd/ospf_flood.h	2010-10-18 16:13:46.000000000 -0400
@@ -66,7 +66,6 @@
 extern void ospf_flood_lsa_as (struct ospf_lsa *);
 extern void ospf_lsa_flush_area (struct ospf_lsa *, struct ospf_area *);
 extern void ospf_lsa_flush_as (struct ospf *, struct ospf_lsa *);
-extern void ospf_lsa_flush (struct ospf *, struct ospf_lsa *);
 extern struct external_info *ospf_external_info_check (struct ospf_lsa *);
 
 extern void ospf_lsdb_init (struct ospf_lsdb *);
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospfd/ospf_asbr.c	2011-03-21 05:43:52.000000000 -0400
+++ ./ospfd/ospf_asbr.c	2010-10-18 16:13:42.000000000 -0400
@@ -264,7 +264,8 @@
 
   /* Transition from/to status ASBR, schedule timer. */
   ospf_spf_calculate_schedule (ospf);
-  ospf_router_lsa_update (ospf);
+  OSPF_TIMER_ON (ospf->t_router_lsa_update,
+		 ospf_router_lsa_update_timer, OSPF_LSA_UPDATE_DELAY);
 }
 
 void
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospfd/ospf_nsm.h	2011-03-21 05:43:52.000000000 -0400
+++ ./ospfd/ospf_nsm.h	2010-10-18 16:13:50.000000000 -0400
@@ -39,7 +39,7 @@
 
 /* OSPF Neighbor State Machine Event. */
 #define NSM_NoEvent	        0
-#define NSM_PacketReceived	1 /* HelloReceived in the protocol */
+#define NSM_HelloReceived	1
 #define NSM_Start		2
 #define NSM_TwoWayReceived	3
 #define NSM_NegotiationDone	4
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospfd/ospf_interface.h	2011-03-21 07:09:13.000000000 -0400
+++ ./ospfd/ospf_interface.h	2010-10-18 16:13:42.000000000 -0400
@@ -73,9 +73,6 @@
   
   DECLARE_IF_PARAM (struct list *, auth_crypt);    /* List of Auth cryptographic data. */
   DECLARE_IF_PARAM (int, auth_type);               /* OSPF authentication type */
-  
-  /* Other, non-configuration state */
-  u_int32_t network_lsa_seqnum;		/* Network LSA seqnum */
 };
 
 enum
@@ -170,7 +167,6 @@
 
   /* Configured varables. */
   struct ospf_if_params *params;
-  
   u_int32_t crypt_seqnum;		/* Cryptographic Sequence Number */ 
   u_int32_t output_cost;	        /* Acutual Interface Output Cost */
 
@@ -210,6 +206,8 @@
   struct thread *t_ls_ack;              /* timer */
   struct thread *t_ls_ack_direct;       /* event */
   struct thread *t_ls_upd_event;        /* event */
+  struct thread *t_network_lsa_self;    /* self-originated network-LSA
+                                           reflesh thread. timer */
 #ifdef HAVE_OPAQUE_LSA
   struct thread *t_opaque_lsa_self;     /* Type-9 Opaque-LSAs */
 #endif /* HAVE_OPAQUE_LSA */
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospfd/ospf_vty.c	2011-03-21 07:09:13.000000000 -0400
+++ ./ospfd/ospf_vty.c	2010-10-18 16:13:49.000000000 -0400
@@ -2934,12 +2934,6 @@
 	    }
 	}
       
-      /* Next network-LSA sequence number we'll use, if we're elected DR */
-      if (oi->params && ntohl (oi->params->network_lsa_seqnum)
-                          != OSPF_INITIAL_SEQUENCE_NUMBER)
-        vty_out (vty, "  Saved Network-LSA sequence number 0x%x%s",
-                 ntohl (oi->params->network_lsa_seqnum), VTY_NEWLINE);
-      
       vty_out (vty, "  Multicast group memberships:");
       if (OI_MEMBER_CHECK(oi, MEMBER_ALLROUTERS)
           || OI_MEMBER_CHECK(oi, MEMBER_DROUTERS))
@@ -7029,7 +7023,7 @@
       SET_FLAG (area->stub_router_state, OSPF_AREA_ADMIN_STUB_ROUTED);
       
       if (!CHECK_FLAG (area->stub_router_state, OSPF_AREA_IS_STUB_ROUTED))
-          ospf_router_lsa_update_area (area);
+          ospf_router_lsa_timer_add (area);
     }
   return CMD_SUCCESS;
 }
@@ -7055,7 +7049,7 @@
           && !area->t_stub_router)
         {
           UNSET_FLAG (area->stub_router_state, OSPF_AREA_IS_STUB_ROUTED);
-          ospf_router_lsa_update_area (area);
+          ospf_router_lsa_timer_add (area);
         }
     }
   return CMD_SUCCESS;
@@ -7108,7 +7102,7 @@
       if (!CHECK_FLAG (area->stub_router_state, OSPF_AREA_ADMIN_STUB_ROUTED))
         {
           UNSET_FLAG (area->stub_router_state, OSPF_AREA_IS_STUB_ROUTED);
-          ospf_router_lsa_update_area (area);
+          ospf_router_lsa_timer_add (area);
         }
     }
   return CMD_SUCCESS;
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospfd/ospf_packet.h	2011-03-21 05:43:52.000000000 -0400
+++ ./ospfd/ospf_packet.h	2010-10-18 16:13:45.000000000 -0400
@@ -162,5 +162,6 @@
 extern int ospf_ls_ack_timer (struct thread *);
 extern int ospf_poll_timer (struct thread *);
 extern int ospf_hello_reply_timer (struct thread *);
+extern void ospf_hello_send_sub (struct ospf_interface *, struct in_addr *);
 
 #endif /* _ZEBRA_OSPF_PACKET_H */
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospfd/ospf_interface.c	2011-03-21 07:09:13.000000000 -0400
+++ ./ospfd/ospf_interface.c	2010-10-18 16:13:36.000000000 -0400
@@ -97,7 +97,7 @@
       if (oi->output_cost != newcost)
 	{
 	  oi->output_cost = newcost;
-	  ospf_router_lsa_update_area (oi->area);
+	  ospf_router_lsa_timer_add (oi->area);
 	}
     }
 }
@@ -219,6 +219,9 @@
   ospf_add_to_if (ifp, oi);
   listnode_add (ospf->oiflist, oi);
   
+  /* Clear self-originated network-LSA. */
+  oi->network_lsa_self = NULL;
+
   /* Initialize neighbor list. */
   oi->nbrs = route_table_init ();
 
@@ -298,6 +301,10 @@
   ospf_nbr_delete (oi->nbr_self);
   oi->nbr_self = ospf_nbr_new (oi);
   ospf_nbr_add_self (oi);
+  
+  ospf_lsa_unlock (&oi->network_lsa_self);
+  oi->network_lsa_self = NULL;
+  OSPF_TIMER_OFF (oi->t_network_lsa_self);
 }
 
 void
@@ -328,8 +335,6 @@
   listnode_delete (oi->ospf->oiflist, oi);
   listnode_delete (oi->area->oiflist, oi);
 
-  thread_cancel_event (master, oi);
-
   memset (oi, 0, sizeof (*oi));
   XFREE (MTYPE_OSPF_IF, oi);
 }
@@ -529,8 +534,6 @@
 
   oip->auth_crypt = list_new ();
   
-  oip->network_lsa_seqnum = htonl(OSPF_INITIAL_SEQUENCE_NUMBER);
-
   return oip;
 }
 
@@ -569,8 +572,7 @@
       !OSPF_IF_PARAM_CONFIGURED (oip, type) &&
       !OSPF_IF_PARAM_CONFIGURED (oip, auth_simple) &&
       !OSPF_IF_PARAM_CONFIGURED (oip, auth_type) &&
-      listcount (oip->auth_crypt) == 0 &&
-      ntohl (oip->network_lsa_seqnum) != OSPF_INITIAL_SEQUENCE_NUMBER)
+      listcount (oip->auth_crypt) == 0)
     {
       ospf_del_if_params (oip);
       rn->info = NULL;
@@ -1120,7 +1122,7 @@
                zlog_debug ("ospf_vl_up_check: VL cost change,"
                           " scheduling router lsa refresh");
              if (ospf->backbone)
-               ospf_router_lsa_update_area (ospf->backbone);
+               ospf_router_lsa_timer_add (ospf->backbone);
              else if (IS_DEBUG_OSPF (ism, ISM_EVENTS))
                zlog_debug ("ospf_vl_up_check: VL cost change, no backbone!");
            }
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospfd/ospfd.h	2011-03-21 05:43:52.000000000 -0400
+++ ./ospfd/ospfd.h	2010-10-18 16:13:47.000000000 -0400
@@ -58,7 +58,6 @@
 #endif
 #define OSPF_MIN_LS_INTERVAL                     5
 #define OSPF_MIN_LS_ARRIVAL                      1
-#define OSPF_LSA_INITIAL_AGE                     0	/* useful for debug */
 #define OSPF_LSA_MAXAGE                       3600
 #define OSPF_CHECK_AGE                         300
 #define OSPF_LSA_MAXAGE_DIFF                   900
@@ -67,6 +66,7 @@
 #define OSPF_INITIAL_SEQUENCE_NUMBER    0x80000001
 #define OSPF_MAX_SEQUENCE_NUMBER        0x7fffffff
 
+#define OSPF_LSA_MAXAGE_CHECK_INTERVAL          30
 #define OSPF_NSSA_TRANS_STABLE_DEFAULT		40
 
 #define OSPF_ALLSPFROUTERS              0xe0000005      /* 224.0.0.5 */
@@ -251,6 +251,7 @@
   int redistribute;                     /* Num of redistributed protocols. */
 
   /* Threads. */
+  struct thread *t_router_lsa_update;   /* router-LSA update timer. */
   struct thread *t_abr_task;            /* ABR task timer. */
   struct thread *t_asbr_check;          /* ASBR check timer. */
   struct thread *t_distribute_update;   /* Distirbute list update timer. */
@@ -260,13 +261,8 @@
 #ifdef HAVE_OPAQUE_LSA
   struct thread *t_opaque_lsa_self;	/* Type-11 Opaque-LSAs origin event. */
 #endif /* HAVE_OPAQUE_LSA */
-
-#define OSFP_LSA_MAXAGE_REMOVE_DELAY_DEFAULT	60
-  unsigned int maxage_delay;		/* Delay on Maxage remover timer, sec */
   struct thread *t_maxage;              /* MaxAge LSA remover timer. */
-#define OSPF_LSA_MAXAGE_CHECK_INTERVAL		30
   struct thread *t_maxage_walker;       /* MaxAge LSA checking timer. */
-
   struct thread *t_deferred_shutdown;	/* deferred/stub-router shutdown timer*/
 
   struct thread *t_write;
@@ -437,6 +433,7 @@
   struct vertex *spf;
 
   /* Threads. */
+  struct thread *t_router_lsa_self;/* Self-originated router-LSA timer. */
   struct thread *t_stub_router;    /* Stub-router timer */
 #ifdef HAVE_OPAQUE_LSA
   struct thread *t_opaque_lsa_self;	/* Type-10 Opaque-LSAs origin. */
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospfd/ospf_lsa.h	2011-03-21 07:09:13.000000000 -0400
+++ ./ospfd/ospf_lsa.h	2010-10-18 16:13:44.000000000 -0400
@@ -114,6 +114,11 @@
 
   /* Refreshement List or Queue */
   int refresh_list;
+
+#ifdef HAVE_OPAQUE_LSA
+  /* For Type-9 Opaque-LSAs, reference to ospf-interface is required. */
+  struct ospf_interface *oi;
+#endif /* HAVE_OPAQUE_LSA */
 };
 
 /* OSPF LSA Link Type. */
@@ -249,16 +254,19 @@
 extern void ospf_lsa_data_free (struct lsa_header *);
 
 /* Prototype for various LSAs */
-extern int ospf_router_lsa_update (struct ospf *);
-extern int ospf_router_lsa_update_area (struct ospf_area *);
+extern int ospf_router_lsa_update_timer (struct thread *);
+extern void ospf_router_lsa_timer_add (struct ospf_area *);
 
-extern void ospf_network_lsa_update (struct ospf_interface *);
+extern int ospf_network_lsa_refresh (struct ospf_lsa *, struct ospf_interface *);
+extern void ospf_network_lsa_timer_add (struct ospf_interface *);
 
 extern struct ospf_lsa *ospf_summary_lsa_originate (struct prefix_ipv4 *, u_int32_t,
 					     struct ospf_area *);
 extern struct ospf_lsa *ospf_summary_asbr_lsa_originate (struct prefix_ipv4 *,
 						  u_int32_t,
 						  struct ospf_area *);
+extern struct ospf_lsa *ospf_summary_lsa_refresh (struct ospf *, struct ospf_lsa *);
+extern struct ospf_lsa *ospf_summary_asbr_lsa_refresh (struct ospf *, struct ospf_lsa *);
 
 extern struct ospf_lsa *ospf_lsa_install (struct ospf *,
 				   struct ospf_interface *, struct ospf_lsa *);
@@ -292,15 +300,12 @@
 extern u_int32_t get_metric (u_char *);
 
 extern int ospf_lsa_maxage_walker (struct thread *);
-extern struct ospf_lsa *ospf_lsa_refresh (struct ospf *, struct ospf_lsa *);
  
 extern void ospf_external_lsa_refresh_default (struct ospf *);
 
 extern void ospf_external_lsa_refresh_type (struct ospf *, u_char, int);
-extern struct ospf_lsa *ospf_external_lsa_refresh (struct ospf *,
-                                                   struct ospf_lsa *,
-                                                   struct external_info *,
-                                                   int);
+extern void ospf_external_lsa_refresh (struct ospf *, struct ospf_lsa *,
+				struct external_info *, int);
 extern struct in_addr ospf_lsa_unique_id (struct ospf *, struct ospf_lsdb *, u_char,
 				   struct prefix_ipv4 *);
 extern void ospf_schedule_lsa_flood_area (struct ospf_area *, struct ospf_lsa *);
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospfd/ospf_packet.c	2011-03-21 07:09:13.000000000 -0400
+++ ./ospfd/ospf_packet.c	2010-10-18 16:13:49.000000000 -0400
@@ -125,20 +125,6 @@
   fifo->count++;
 }
 
-/* Add new packet to head of fifo. */
-static void
-ospf_fifo_push_head (struct ospf_fifo *fifo, struct ospf_packet *op)
-{
-  op->next = fifo->head;
-  
-  if (fifo->tail == NULL)
-    fifo->tail = op;
-  
-  fifo->head = op;
-  
-  fifo->count++;
-}
-
 /* Delete first packet from fifo. */
 struct ospf_packet *
 ospf_fifo_pop (struct ospf_fifo *fifo)
@@ -213,27 +199,6 @@
   /* ospf_fifo_debug (oi->obuf); */
 }
 
-static void
-ospf_packet_add_top (struct ospf_interface *oi, struct ospf_packet *op)
-{
-  if (!oi->obuf)
-    {
-      zlog_err("ospf_packet_add(interface %s in state %d [%s], packet type %s, "
-	       "destination %s) called with NULL obuf, ignoring "
-	       "(please report this bug)!\n",
-	       IF_NAME(oi), oi->state, LOOKUP (ospf_ism_state_msg, oi->state),
-	       ospf_packet_type_str[stream_getc_from(op->s, 1)],
-	       inet_ntoa (op->dst));
-      return;
-    }
-
-  /* Add packet to head of queue. */
-  ospf_fifo_push_head (oi->obuf, op);
-
-  /* Debug of packet fifo*/
-  /* ospf_fifo_debug (oi->obuf); */
-}
-
 void
 ospf_packet_delete (struct ospf_interface *oi)
 {
@@ -916,7 +881,7 @@
   old_state = nbr->state;
 
   /* Add event to thread. */
-  OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_PacketReceived);
+  OSPF_NSM_EVENT_EXECUTE (nbr, NSM_HelloReceived);
 
   /*  RFC2328  Section 9.5.1
       If the router is not eligible to become Designated Router,
@@ -936,7 +901,7 @@
   if (oi->type == OSPF_IFTYPE_NBMA &&
       (old_state == NSM_Down || old_state == NSM_Attempt))
     {
-      OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_OneWayReceived);
+      OSPF_NSM_EVENT_EXECUTE (nbr, NSM_OneWayReceived);
       nbr->priority = hello->priority;
       nbr->d_router = hello->d_router;
       nbr->bd_router = hello->bd_router;
@@ -946,12 +911,12 @@
   if (ospf_nbr_bidirectional (&oi->ospf->router_id, hello->neighbors,
 			      size - OSPF_HELLO_MIN_SIZE))
     {
-      OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_TwoWayReceived);
+      OSPF_NSM_EVENT_EXECUTE (nbr, NSM_TwoWayReceived);
       nbr->options |= hello->options;
     }
   else
     {
-      OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_OneWayReceived);
+      OSPF_NSM_EVENT_EXECUTE (nbr, NSM_OneWayReceived);
       /* Set neighbor information. */
       nbr->priority = hello->priority;
       nbr->d_router = hello->d_router;
@@ -1226,9 +1191,6 @@
     }
 #endif /* HAVE_OPAQUE_LSA */
 
-  /* Add event to thread. */
-  OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_PacketReceived);
-
   /* Process DD packet by neighbor status. */
   switch (nbr->state)
     {
@@ -1450,9 +1412,6 @@
       return;
     }
 
-  /* Add event to thread. */
-  OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_PacketReceived);
-
   /* Neighbor State should be Exchange or later. */
   if (nbr->state != NSM_Exchange &&
       nbr->state != NSM_Loading &&
@@ -1685,9 +1644,6 @@
       return;
     }
 
-  /* Add event to thread. */
-  OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_PacketReceived);
-
   /* Check neighbor state. */
   if (nbr->state < NSM_Exchange)
     {
@@ -1990,7 +1946,7 @@
 	      quagga_gettime (QUAGGA_CLK_MONOTONIC, &now);
 	      
 	      if (tv_cmp (tv_sub (now, current->tv_orig), 
-			  int2tv (OSPF_MIN_LS_ARRIVAL)) >= 0)
+			  int2tv (OSPF_MIN_LS_ARRIVAL)) > 0)
 		/* Trap NSSA type later.*/
 		ospf_ls_upd_send_lsa (nbr, current, OSPF_SEND_PACKET_DIRECT);
 	      DISCARD_LSA (lsa, 8);
@@ -2021,9 +1977,6 @@
       return;
     }
 
-  /* Add event to thread. */
-  OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_PacketReceived);
-
   if (nbr->state < NSM_Exchange)
     {
       zlog_warn ("Link State Acknowledgment: "
@@ -3002,8 +2955,8 @@
   return length;
 }
 
-static void
-ospf_hello_send_sub (struct ospf_interface *oi, in_addr_t addr)
+void
+ospf_hello_send_sub (struct ospf_interface *oi, struct in_addr *addr)
 {
   struct ospf_packet *op;
   u_int16_t length = OSPF_HEADER_SIZE;
@@ -3022,12 +2975,10 @@
   /* Set packet length. */
   op->length = length;
 
-  op->dst.s_addr = addr;
+  op->dst.s_addr = addr->s_addr;
 
-  /* Add packet to the top of the interface output queue, so that they
-   * can't get delayed by things like long queues of LS Update packets
-   */
-  ospf_packet_add_top (oi, op);
+  /* Add packet to the interface output queue. */
+  ospf_packet_add (oi, op);
 
   /* Hook thread to write packet. */
   OSPF_ISM_WRITE_ON (oi->ospf);
@@ -3058,7 +3009,7 @@
       && oi->state != ISM_DR && oi->state != ISM_Backup)
     return;
 
-  ospf_hello_send_sub (oi, nbr_nbma->addr.s_addr);
+  ospf_hello_send_sub (oi, &nbr_nbma->addr);
 }
 
 int
@@ -3097,7 +3048,7 @@
     zlog (NULL, LOG_DEBUG, "NSM[%s:%s]: Timer (hello-reply timer expire)",
 	  IF_NAME (nbr->oi), inet_ntoa (nbr->router_id));
 
-  ospf_hello_send_sub (nbr->oi, nbr->address.u.prefix4.s_addr);
+  ospf_hello_send_sub (nbr->oi, &nbr->address.u.prefix4);
 
   return 0;
 }
@@ -3106,10 +3057,27 @@
 void
 ospf_hello_send (struct ospf_interface *oi)
 {
+  struct ospf_packet *op;
+  u_int16_t length = OSPF_HEADER_SIZE;
+
   /* If this is passive interface, do not send OSPF Hello. */
   if (OSPF_IF_PASSIVE_STATUS (oi) == OSPF_IF_PASSIVE)
     return;
 
+  op = ospf_packet_new (oi->ifp->mtu);
+
+  /* Prepare OSPF common header. */
+  ospf_make_header (OSPF_MSG_HELLO, oi, op->s);
+
+  /* Prepare OSPF Hello body. */
+  length += ospf_make_hello (oi, op->s);
+
+  /* Fill OSPF header. */
+  ospf_fill_header (oi, op->s, length);
+
+  /* Set packet length. */
+  op->length = length;
+
   if (oi->type == OSPF_IFTYPE_NBMA)
     {
       struct ospf_neighbor *nbr;
@@ -3139,16 +3107,34 @@
 		if (nbr->priority == 0 && oi->state == ISM_DROther)
 		  continue;
 		/* if oi->state == Waiting, send hello to all neighbors */
-		ospf_hello_send_sub (oi, nbr->address.u.prefix4.s_addr);
+		{
+		  struct ospf_packet *op_dup;
+
+		  op_dup = ospf_packet_dup(op);
+		  op_dup->dst = nbr->address.u.prefix4;
+
+		  /* Add packet to the interface output queue. */
+		  ospf_packet_add (oi, op_dup);
+
+		  OSPF_ISM_WRITE_ON (oi->ospf);
+		}
+
 	      }
+      ospf_packet_free (op);
     }
   else
     {
       /* Decide destination address. */
       if (oi->type == OSPF_IFTYPE_VIRTUALLINK)
-        ospf_hello_send_sub (oi, oi->vl_data->peer_addr.s_addr);
+	op->dst.s_addr = oi->vl_data->peer_addr.s_addr;
       else
-        ospf_hello_send_sub (oi, htonl (OSPF_ALLSPFROUTERS));
+	op->dst.s_addr = htonl (OSPF_ALLSPFROUTERS);
+
+      /* Add packet to the interface output queue. */
+      ospf_packet_add (oi, op);
+
+      /* Hook thread to write packet. */
+      OSPF_ISM_WRITE_ON (oi->ospf);
     }
 }
 
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospfd/ospf_opaque.c	2011-03-21 05:43:52.000000000 -0400
+++ ./ospfd/ospf_opaque.c	2010-10-18 16:13:43.000000000 -0400
@@ -1630,7 +1630,7 @@
         zlog_debug ("LSA[Type%d:%s]: Flush stray Opaque-LSA", lsa->data->type, inet_ntoa (lsa->data->id));
 
       lsa->data->ls_age = htons (OSPF_LSA_MAXAGE);
-      ospf_lsa_flush (ospf, lsa);
+      ospf_lsa_maxage (ospf, lsa);
     }
   else
     (* functab->lsa_refresher)(lsa);
@@ -2108,7 +2108,7 @@
     zlog_debug ("Schedule Type-%u Opaque-LSA to FLUSH: [opaque-type=%u, opaque-id=%x]", lsa->data->type, GET_OPAQUE_TYPE (ntohl (lsa->data->id.s_addr)), GET_OPAQUE_ID (ntohl (lsa->data->id.s_addr)));
 
   /* This lsa will be flushed and removed eventually. */
-  ospf_lsa_flush (lsa0->area->ospf, lsa);
+  ospf_lsa_maxage (lsa0->area->ospf, lsa);
 
 out:
   return;
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospfd/ospf_abr.c	2011-03-21 05:43:52.000000000 -0400
+++ ./ospfd/ospf_abr.c	2010-10-18 16:13:48.000000000 -0400
@@ -565,7 +565,8 @@
       if (IS_DEBUG_OSPF_EVENT)
 	zlog_debug ("ospf_check_abr_status(): new router flags: %x",new_flags);
       ospf->flags = new_flags;
-      ospf_router_lsa_update (ospf);
+      OSPF_TIMER_ON (ospf->t_router_lsa_update,
+		     ospf_router_lsa_update_timer, OSPF_LSA_UPDATE_DELAY);
     }
 }
 
@@ -759,7 +760,7 @@
             zlog_debug ("ospf_abr_announce_network_to_area(): "
                        "refreshing summary");
           set_metric (old, cost);
-          lsa = ospf_lsa_refresh (area->ospf, old);
+          lsa = ospf_summary_lsa_refresh (area->ospf, old);
           
           if (!lsa)
             {
@@ -1147,7 +1148,7 @@
       if (old) 
 	{ 
 	  set_metric (old, cost);
-	  lsa = ospf_lsa_refresh (area->ospf, old);
+	  lsa = ospf_summary_asbr_lsa_refresh (area->ospf, old);
 	}
       else
 	lsa = ospf_summary_asbr_lsa_originate (p, cost, area);
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospfd/ospf_nsm.c	2011-03-21 05:43:52.000000000 -0400
+++ ./ospfd/ospf_nsm.c	2010-10-18 16:13:49.000000000 -0400
@@ -162,7 +162,7 @@
 
 /* OSPF NSM functions. */
 static int
-nsm_packet_received (struct ospf_neighbor *nbr)
+nsm_hello_received (struct ospf_neighbor *nbr)
 {
   /* Start or Restart Inactivity Timer. */
   OSPF_NSM_TIMER_OFF (nbr->t_inactivity);
@@ -408,7 +408,7 @@
   {
     /* DependUpon: dummy state. */
     { NULL,                    NSM_DependUpon }, /* NoEvent           */
-    { NULL,                    NSM_DependUpon }, /* PacketReceived    */
+    { NULL,                    NSM_DependUpon }, /* HelloReceived     */
     { NULL,                    NSM_DependUpon }, /* Start             */
     { NULL,                    NSM_DependUpon }, /* 2-WayReceived     */
     { NULL,                    NSM_DependUpon }, /* NegotiationDone   */
@@ -425,7 +425,7 @@
   {
     /* Deleted: dummy state. */
     { NULL,                    NSM_Deleted    }, /* NoEvent           */
-    { NULL,                    NSM_Deleted    }, /* PacketReceived    */
+    { NULL,                    NSM_Deleted    }, /* HelloReceived     */
     { NULL,                    NSM_Deleted    }, /* Start             */
     { NULL,                    NSM_Deleted    }, /* 2-WayReceived     */
     { NULL,                    NSM_Deleted    }, /* NegotiationDone   */
@@ -442,7 +442,7 @@
   {
     /* Down: */
     { NULL,                    NSM_DependUpon }, /* NoEvent           */
-    { nsm_packet_received,     NSM_Init       }, /* PacketReceived    */
+    { nsm_hello_received,      NSM_Init       }, /* HelloReceived     */
     { nsm_start,               NSM_Attempt    }, /* Start             */
     { NULL,                    NSM_Down       }, /* 2-WayReceived     */
     { NULL,                    NSM_Down       }, /* NegotiationDone   */
@@ -459,7 +459,7 @@
   {
     /* Attempt: */
     { NULL,                    NSM_DependUpon }, /* NoEvent           */
-    { nsm_packet_received,     NSM_Init       }, /* PacketReceived    */
+    { nsm_hello_received,      NSM_Init       }, /* HelloReceived     */
     { NULL,                    NSM_Attempt    }, /* Start             */
     { NULL,                    NSM_Attempt    }, /* 2-WayReceived     */
     { NULL,                    NSM_Attempt    }, /* NegotiationDone   */
@@ -476,7 +476,7 @@
   {
     /* Init: */
     { NULL,                    NSM_DependUpon }, /* NoEvent           */
-    { nsm_packet_received,     NSM_Init      }, /* PacketReceived    */
+    { nsm_hello_received,      NSM_Init       }, /* HelloReceived     */
     { NULL,                    NSM_Init       }, /* Start             */
     { nsm_twoway_received,     NSM_DependUpon }, /* 2-WayReceived     */
     { NULL,                    NSM_Init       }, /* NegotiationDone   */
@@ -493,7 +493,7 @@
   {
     /* 2-Way: */
     { NULL,                    NSM_DependUpon }, /* NoEvent           */
-    { nsm_packet_received,     NSM_TwoWay     }, /* HelloReceived     */
+    { nsm_hello_received,      NSM_TwoWay     }, /* HelloReceived     */
     { NULL,                    NSM_TwoWay     }, /* Start             */
     { NULL,                    NSM_TwoWay     }, /* 2-WayReceived     */
     { NULL,                    NSM_TwoWay     }, /* NegotiationDone   */
@@ -510,7 +510,7 @@
   {
     /* ExStart: */
     { NULL,                    NSM_DependUpon }, /* NoEvent           */
-    { nsm_packet_received,     NSM_ExStart    }, /* PacaketReceived   */
+    { nsm_hello_received,      NSM_ExStart    }, /* HelloReceived     */
     { NULL,                    NSM_ExStart    }, /* Start             */
     { NULL,                    NSM_ExStart    }, /* 2-WayReceived     */
     { nsm_negotiation_done,    NSM_Exchange   }, /* NegotiationDone   */
@@ -527,7 +527,7 @@
   {
     /* Exchange: */
     { NULL,                    NSM_DependUpon }, /* NoEvent           */
-    { nsm_packet_received,     NSM_Exchange   }, /* PacketReceived    */
+    { nsm_hello_received,      NSM_Exchange   }, /* HelloReceived     */
     { NULL,                    NSM_Exchange   }, /* Start             */
     { NULL,                    NSM_Exchange   }, /* 2-WayReceived     */
     { NULL,                    NSM_Exchange   }, /* NegotiationDone   */
@@ -544,7 +544,7 @@
   {
     /* Loading: */
     { NULL,                    NSM_DependUpon }, /* NoEvent           */
-    { nsm_packet_received,     NSM_Loading    }, /* PacketReceived    */
+    { nsm_hello_received,      NSM_Loading    }, /* HelloReceived     */
     { NULL,                    NSM_Loading    }, /* Start             */
     { NULL,                    NSM_Loading    }, /* 2-WayReceived     */
     { NULL,                    NSM_Loading    }, /* NegotiationDone   */
@@ -560,7 +560,7 @@
   },
   { /* Full: */
     { NULL,                    NSM_DependUpon }, /* NoEvent           */
-    { nsm_packet_received,     NSM_Full       }, /* PacketReceived    */
+    { nsm_hello_received,      NSM_Full       }, /* HelloReceived     */
     { NULL,                    NSM_Full       }, /* Start             */
     { NULL,                    NSM_Full       }, /* 2-WayReceived     */
     { NULL,                    NSM_Full       }, /* NegotiationDone   */
@@ -579,7 +579,7 @@
 static const char *ospf_nsm_event_str[] =
 {
   "NoEvent",
-  "PacketReceived",
+  "HelloReceived",
   "Start",
   "2-WayReceived",
   "NegotiationDone",
@@ -711,7 +711,7 @@
 		 LOOKUP(ospf_nsm_state_msg, old_state),
 		 LOOKUP(ospf_nsm_state_msg, state));
 
-      ospf_router_lsa_update_area (oi->area);
+      ospf_router_lsa_timer_add (oi->area);
 
       if (oi->type == OSPF_IFTYPE_VIRTUALLINK)
 	{
@@ -719,7 +719,7 @@
 	    ospf_area_lookup_by_area_id (oi->ospf, oi->vl_data->vl_area_id);
 	  
 	  if (vl_area)
-	    ospf_router_lsa_update_area (vl_area);
+	    ospf_router_lsa_timer_add (vl_area);
 	}
 
       /* Originate network-LSA. */
@@ -730,9 +730,10 @@
 	      ospf_lsa_flush_area (oi->network_lsa_self, oi->area);
 	      ospf_lsa_unlock (&oi->network_lsa_self);
 	      oi->network_lsa_self = NULL;
+	      OSPF_TIMER_OFF (oi->t_network_lsa_self);
 	    }
 	  else
-	    ospf_network_lsa_update (oi);
+	    ospf_network_lsa_timer_add (oi);
 	}
     }
 
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospfd/ospf_lsa.c	2011-03-21 07:09:13.000000000 -0400
+++ ./ospfd/ospf_lsa.c	2010-10-18 16:13:44.000000000 -0400
@@ -372,7 +372,7 @@
 
   lsah = (struct lsa_header *) STREAM_DATA (s);
 
-  lsah->ls_age = htons (OSPF_LSA_INITIAL_AGE);
+  lsah->ls_age = htons (0);
   lsah->options = options;
   lsah->type = type;
   lsah->id = id;
@@ -741,7 +741,7 @@
   
   UNSET_FLAG (area->stub_router_state, OSPF_AREA_IS_STUB_ROUTED);
   
-  ospf_router_lsa_update_area (area);
+  ospf_router_lsa_timer_add (area);
   
   return 0;
 }
@@ -885,9 +885,6 @@
   /* Delete LSA from neighbor retransmit-list. */
   ospf_ls_retransmit_delete_nbr_area (area, lsa);
 
-  /* Unregister LSA from refresh-list */
-  ospf_refresher_unregister_lsa (area->ospf, lsa);
-  
   /* Create new router-LSA instance. */
   if ( (new = ospf_router_lsa_new (area)) == NULL)
     {
@@ -913,15 +910,20 @@
   return NULL;
 }
 
-int
-ospf_router_lsa_update_area (struct ospf_area *area)
+static int
+ospf_router_lsa_timer (struct thread *t)
 {
+  struct ospf_area *area;
+
   if (IS_DEBUG_OSPF_EVENT)
-    zlog_debug ("[router-LSA]: (router-LSA area update)");
+    zlog_debug ("Timer[router-LSA]: (router-LSA Refresh expire)");
+
+  area = THREAD_ARG (t);
+  area->t_router_lsa_self = NULL;
 
   /* Now refresh router-LSA. */
   if (area->router_lsa_self)
-    ospf_lsa_refresh (area->ospf, area->router_lsa_self);
+    ospf_router_lsa_refresh (area->router_lsa_self);
   /* Newly originate router-LSA. */
   else
     ospf_router_lsa_originate (area);
@@ -929,15 +931,50 @@
   return 0;
 }
 
+void
+ospf_router_lsa_timer_add (struct ospf_area *area)
+{
+  /* Keep area's self-originated router-LSA. */
+  struct ospf_lsa *lsa = area->router_lsa_self;
+
+  /* Cancel previously scheduled router-LSA timer. */
+  if (area->t_router_lsa_self)
+    if (IS_DEBUG_OSPF (lsa, LSA_GENERATE))
+      zlog_debug ("LSA[Type1]: Cancel previous router-LSA timer");
+
+  OSPF_TIMER_OFF (area->t_router_lsa_self);
+
+  /* If router-LSA is originated previously, check the interval time. */
+  if (lsa)
+    {
+      int delay;
+      if ((delay = ospf_lsa_refresh_delay (lsa)) > 0)
+        {
+	  OSPF_AREA_TIMER_ON (area->t_router_lsa_self,
+			      ospf_router_lsa_timer, delay);
+	  return;
+        }
+    }
+
+  if (IS_DEBUG_OSPF (lsa, LSA_GENERATE))
+    zlog_debug ("LSA[Type1]: Scheduling router-LSA origination right away");
+
+  /* Immediately refresh router-LSA. */
+  OSPF_AREA_TIMER_ON (area->t_router_lsa_self, ospf_router_lsa_timer, 0);
+}
+
 int
-ospf_router_lsa_update (struct ospf *ospf)
+ospf_router_lsa_update_timer (struct thread *thread)
 {
+  struct ospf *ospf = THREAD_ARG (thread);
   struct listnode *node, *nnode;
   struct ospf_area *area;
 
   if (IS_DEBUG_OSPF (lsa, LSA_GENERATE))
     zlog_debug ("Timer[router-LSA Update]: (timer expire)");
 
+  ospf->t_router_lsa_update = NULL;
+
   for (ALL_LIST_ELEMENTS (ospf->areas, node, nnode, area))
     {
       struct ospf_lsa *lsa = area->router_lsa_self;
@@ -962,20 +999,19 @@
 	  if (IS_DEBUG_OSPF (lsa, LSA_GENERATE))
 	    zlog_debug("LSA[Type%d:%s]: Refresh router-LSA for Area %s",
 		      lsa->data->type, inet_ntoa (lsa->data->id), area_str);
-          ospf_refresher_unregister_lsa (ospf, lsa);
 	  ospf_lsa_flush_area (lsa, area);
 	  ospf_lsa_unlock (&area->router_lsa_self);
 	  area->router_lsa_self = NULL;
 
 	  /* Refresh router-LSA, (not install) and flood through area. */
-	  ospf_router_lsa_update_area (area);
+	  ospf_router_lsa_timer_add (area);
 	}
       else
 	{
 	  rl = (struct router_lsa *) lsa->data;
 	  /* Refresh router-LSA, (not install) and flood through area. */
 	  if (rl->flags != ospf->flags)
-	    ospf_router_lsa_update_area (area);
+	    ospf_router_lsa_timer_add (area);
 	}
     }
 
@@ -1012,7 +1048,6 @@
   struct stream *s;
   struct ospf_lsa *new;
   struct lsa_header *lsah;
-  struct ospf_if_params *oip;
   int length;
 
   /* If there are no neighbours on this network (the net is stub),
@@ -1052,41 +1087,19 @@
   memcpy (new->data, lsah, length);
   stream_free (s);
   
-  /* Remember prior network LSA sequence numbers, even if we stop
-   * originating one for this oi, to try avoid re-originating LSAs with a
-   * prior sequence number, and thus speed up adjency forming & convergence.
-   */
-  if ((oip = ospf_lookup_if_params (oi->ifp, oi->address->u.prefix4)))
-    {
-      new->data->ls_seqnum = oip->network_lsa_seqnum;
-      new->data->ls_seqnum = lsa_seqnum_increment (new);
-    }
-  else
-    {
-      oip = ospf_get_if_params (oi->ifp, oi->address->u.prefix4);
-      ospf_if_update_params (oi->ifp, oi->address->u.prefix4);
-    }
-  oip->network_lsa_seqnum = new->data->ls_seqnum;
-  
   return new;
 }
 
 /* Originate network-LSA. */
-void
-ospf_network_lsa_update (struct ospf_interface *oi)
+static struct ospf_lsa *
+ospf_network_lsa_originate (struct ospf_interface *oi)
 {
   struct ospf_lsa *new;
   
-  if (oi->network_lsa_self != NULL)
-    {
-      ospf_lsa_refresh (oi->ospf, oi->network_lsa_self);
-      return;
-    }
-  
   /* Create new network-LSA instance. */
   new = ospf_network_lsa_new (oi);
   if (new == NULL)
-    return;
+    return NULL;
 
   /* Install LSA to LSDB. */
   new = ospf_lsa_install (oi->ospf, oi, new);
@@ -1104,50 +1117,27 @@
       ospf_lsa_header_dump (new->data);
     }
 
-  return;
+  return new;
 }
 
-static struct ospf_lsa *
-ospf_network_lsa_refresh (struct ospf_lsa *lsa)
+int
+ospf_network_lsa_refresh (struct ospf_lsa *lsa, struct ospf_interface *oi)
 {
   struct ospf_area *area = lsa->area;
-  struct ospf_lsa *new, *new2;
-  struct ospf_if_params *oip;
-  struct ospf_interface *oi;
+  struct ospf_lsa *new;
   
   assert (lsa->data);
   
-  /* Retrieve the oi for the network LSA */
-  oi = ospf_if_lookup_by_local_addr (area->ospf, NULL, lsa->data->id);
-  if (oi == NULL)
-    {
-      if (IS_DEBUG_OSPF (lsa, LSA_GENERATE))
-        {
-          zlog_debug ("LSA[Type%d:%s]: network-LSA refresh: "
-                      "no oi found, ick, ignoring.",
-		      lsa->data->type, inet_ntoa (lsa->data->id));
-          ospf_lsa_header_dump (lsa->data);
-        }
-      return NULL;
-    }
   /* Delete LSA from neighbor retransmit-list. */
   ospf_ls_retransmit_delete_nbr_area (area, lsa);
 
-  /* Unregister LSA from refresh-list */
-  ospf_refresher_unregister_lsa (area->ospf, lsa);
-  
   /* Create new network-LSA instance. */
   new = ospf_network_lsa_new (oi);
   if (new == NULL)
-    return NULL;
-  
-  oip = ospf_lookup_if_params (oi->ifp, oi->address->u.prefix4);
-  assert (oip != NULL);
-  oip->network_lsa_seqnum = new->data->ls_seqnum = lsa_seqnum_increment (lsa);
-
-  new2 = ospf_lsa_install (area->ospf, oi, new);
+    return -1;
+  new->data->ls_seqnum = lsa_seqnum_increment (lsa);
   
-  assert (new2 == new);
+  ospf_lsa_install (area->ospf, oi, new);
   
   /* Flood LSA through aera. */
   ospf_flood_through_area (area, NULL, new);
@@ -1159,9 +1149,61 @@
       ospf_lsa_header_dump (new->data);
     }
 
-  return new;
+  return 0;
+}
+
+static int
+ospf_network_lsa_refresh_timer (struct thread *t)
+{
+  struct ospf_interface *oi;
+
+  oi = THREAD_ARG (t);
+  oi->t_network_lsa_self = NULL;
+
+  if (oi->network_lsa_self)
+    /* Now refresh network-LSA. */
+    ospf_network_lsa_refresh (oi->network_lsa_self, oi);
+  else
+    /* Newly create network-LSA. */
+    ospf_network_lsa_originate (oi);
+
+  return 0;
+}
+
+void
+ospf_network_lsa_timer_add (struct ospf_interface *oi)
+{
+  /* Keep interface's self-originated network-LSA. */
+  struct ospf_lsa *lsa = oi->network_lsa_self;
+
+  /* Cancel previously schedules network-LSA timer. */
+  if (oi->t_network_lsa_self)
+    if (IS_DEBUG_OSPF (lsa, LSA_GENERATE))
+      zlog_debug ("LSA[Type2]: Cancel previous network-LSA timer");
+  OSPF_TIMER_OFF (oi->t_network_lsa_self);
+
+  /* If network-LSA is originated previously, check the interval time. */
+  if (lsa)
+    {
+      int delay;
+      if ((delay = ospf_lsa_refresh_delay (lsa)) > 0)
+        {
+          oi->t_network_lsa_self =
+            thread_add_timer (master, ospf_network_lsa_refresh_timer,
+			      oi, delay);
+          return;
+        }
 }
 
+  if (IS_DEBUG_OSPF (lsa, LSA_GENERATE))
+    zlog_debug ("Scheduling network-LSA origination right away");
+
+  /* Immediately refresh network-LSA. */
+  oi->t_network_lsa_self =
+    thread_add_event (master, ospf_network_lsa_refresh_timer, oi, 0);
+}
+
+
 static void
 stream_put_ospf_metric (struct stream *s, u_int32_t metric_value)
 {
@@ -1284,7 +1326,7 @@
   return new;
 }
 
-static struct ospf_lsa*
+struct ospf_lsa*
 ospf_summary_lsa_refresh (struct ospf *ospf, struct ospf_lsa *lsa)
 {
   struct ospf_lsa *new;
@@ -1431,7 +1473,7 @@
   return new;
 }
 
-static struct ospf_lsa*
+struct ospf_lsa*
 ospf_summary_asbr_lsa_refresh (struct ospf *ospf, struct ospf_lsa *lsa)
 {
   struct ospf_lsa *new;
@@ -2257,7 +2299,6 @@
 	{
 	  if (IS_DEBUG_OSPF_EVENT)
 	    zlog_debug ("LSA[Type5:0.0.0.0]: Flush AS-external-LSA");
-          ospf_refresher_unregister_lsa (ospf, lsa);
 	  ospf_lsa_flush_as (ospf, lsa);
 	}
     }
@@ -2286,7 +2327,7 @@
 }
 
 /* Refresh AS-external-LSA. */
-struct ospf_lsa *
+void
 ospf_external_lsa_refresh (struct ospf *ospf, struct ospf_lsa *lsa,
 			   struct external_info *ei, int force)
 {
@@ -2302,7 +2343,7 @@
                    lsa->data->type, inet_ntoa (lsa->data->id));
       ospf_external_lsa_flush (ospf, ei->type, &ei->p,
 			       ei->ifindex /*, ei->nexthop */);
-      return NULL;
+      return;
     }
 
   if (!changed && !force)
@@ -2310,7 +2351,7 @@
       if (IS_DEBUG_OSPF (lsa, LSA_GENERATE))
         zlog_debug ("LSA[Type%d:%s]: Not refreshed, not changed/forced",
                    lsa->data->type, inet_ntoa (lsa->data->id));
-      return NULL;
+      return;
     }
 
   /* Delete LSA from neighbor retransmit-list. */
@@ -2326,7 +2367,7 @@
       if (IS_DEBUG_OSPF (lsa, LSA_GENERATE))
 	zlog_debug ("LSA[Type%d:%s]: Could not be refreshed", lsa->data->type,
 		   inet_ntoa (lsa->data->id));
-      return NULL;
+      return;
     }
   
   new->data->ls_seqnum = lsa_seqnum_increment (lsa);
@@ -2355,7 +2396,7 @@
       ospf_lsa_header_dump (new->data);
     }
 
-  return new;
+  return;
 }
 
 
@@ -2363,8 +2404,8 @@
 
 /* Install router-LSA to an area. */
 static struct ospf_lsa *
-ospf_router_lsa_install (struct ospf *ospf, struct ospf_lsa *new,
-                         int rt_recalc)
+ospf_router_lsa_install (struct ospf *ospf,
+			 struct ospf_lsa *new, int rt_recalc)
 {
   struct ospf_area *area = new->area;
 
@@ -2383,11 +2424,15 @@
       if (CHECK_FLAG (new->flags, OSPF_LSA_RECEIVED))
 	return new; /* ignore stale LSA */
 
+      /* Set router-LSA refresh timer. */
+      OSPF_TIMER_OFF (area->t_router_lsa_self);
+      OSPF_AREA_TIMER_ON (area->t_router_lsa_self,
+                          ospf_router_lsa_timer, OSPF_LS_REFRESH_TIME);
+
       /* Set self-originated router-LSA. */
       ospf_lsa_unlock (&area->router_lsa_self);
       area->router_lsa_self = ospf_lsa_lock (new);
 
-      ospf_refresher_register_lsa (ospf, new);
     }
   if (rt_recalc)
     ospf_spf_calculate_schedule (ospf);
@@ -2420,9 +2465,15 @@
       if (CHECK_FLAG (new->flags, OSPF_LSA_RECEIVED))
 	return new; /* ignore stale LSA */
 
+      /* Set LSRefresh timer. */
+      OSPF_TIMER_OFF (oi->t_network_lsa_self);
+
+      OSPF_INTERFACE_TIMER_ON (oi->t_network_lsa_self,
+			       ospf_network_lsa_refresh_timer,
+			       OSPF_LS_REFRESH_TIME);
+
       ospf_lsa_unlock (&oi->network_lsa_self);
       oi->network_lsa_self = ospf_lsa_lock (new);
-      ospf_refresher_register_lsa (ospf, new);
     }
   if (rt_recalc)
     ospf_spf_calculate_schedule (ospf);
@@ -2670,8 +2721,7 @@
           if (IS_DEBUG_OSPF (lsa, LSA_REFRESH))
             {
       	      zlog_debug ("ospf_lsa_install() Premature Aging "
-		         "lsa 0x%p, seqnum 0x%x",
-		         lsa, ntohl(lsa->data->ls_seqnum));
+		         "lsa 0x%lx", (u_long)lsa);
       	      ospf_lsa_header_dump (lsa->data);
             }
         }
@@ -2776,7 +2826,7 @@
                    new->data->type, 
                    inet_ntoa (new->data->id), 
                    lsa);
-      ospf_lsa_flush (ospf, lsa);
+      ospf_lsa_maxage (ospf, lsa);
     }
 
   return new;
@@ -2808,6 +2858,35 @@
 }
 
 
+#ifdef ORIGINAL_CODING
+/* This function flood the maxaged LSA to DR. */
+void
+ospf_maxage_flood (struct ospf_lsa *lsa)
+{
+  switch (lsa->data->type)
+    {
+    case OSPF_ROUTER_LSA:
+    case OSPF_NETWORK_LSA:
+    case OSPF_SUMMARY_LSA:
+    case OSPF_ASBR_SUMMARY_LSA:
+    case OSPF_AS_NSSA_LSA:
+#ifdef HAVE_OPAQUE_LSA
+    case OSPF_OPAQUE_LINK_LSA:
+    case OSPF_OPAQUE_AREA_LSA:
+#endif /* HAVE_OPAQUE_LSA */
+      ospf_flood_through_area (lsa->area, NULL, lsa);
+      break;
+    case OSPF_AS_EXTERNAL_LSA:
+#ifdef HAVE_OPAQUE_LSA
+    case OSPF_OPAQUE_AS_LSA:
+#endif /* HAVE_OPAQUE_LSA */
+      ospf_flood_through_as (NULL, lsa);
+      break;
+    default:
+      break;
+    }
+}
+#endif /* ORIGINAL_CODING */
 
 static int
 ospf_maxage_lsa_remover (struct thread *thread)
@@ -2833,10 +2912,6 @@
             continue;
           }
         
-        /* TODO: maybe convert this function to a work-queue */
-        if (thread_should_yield (thread))
-          OSPF_TIMER_ON (ospf->t_maxage, ospf_maxage_lsa_remover, 0);
-          
         /* Remove LSA from the LSDB */
         if (CHECK_FLAG (lsa->flags, OSPF_LSA_SELF))
           if (IS_DEBUG_OSPF (lsa, LSA_FLOODING))
@@ -2847,11 +2922,19 @@
           zlog_debug ("LSA[Type%d:%s]: MaxAge LSA removed from list",
                      lsa->data->type, inet_ntoa (lsa->data->id));
 
-	if (CHECK_FLAG (lsa->flags, OSPF_LSA_PREMATURE_AGE))
+	/* Flood max age LSA. */
+#ifdef ORIGINAL_CODING
+	ospf_maxage_flood (lsa);
+#else /* ORIGINAL_CODING */
+        ospf_flood_through (ospf, NULL, lsa);
+#endif /* ORIGINAL_CODING */
+
+	if (lsa->flags & OSPF_LSA_PREMATURE_AGE)  
           {
             if (IS_DEBUG_OSPF (lsa, LSA_FLOODING))
-              zlog_debug ("originating new lsa for lsa 0x%p\n", lsa);
-            ospf_lsa_refresh (ospf, lsa);
+              zlog_debug ("originating new router lsa for lsa 0x%lx \n", 
+                         (u_long)lsa);
+            ospf_router_lsa_originate(lsa->area);
           }
 
 	/* Remove from lsdb. */
@@ -2870,8 +2953,7 @@
         neighbor Link state retransmission lists and b) none of the router's
         neighbors are in states Exchange or Loading. */
   if (reschedule)
-    OSPF_TIMER_ON (ospf->t_maxage, ospf_maxage_lsa_remover,
-                   ospf->maxage_delay);
+    OSPF_TIMER_ON (ospf->t_maxage, ospf_maxage_lsa_remover, 2);
 
   return 0;
 }
@@ -2889,11 +2971,6 @@
     }
 }
 
-/* Add LSA onto the MaxAge list, and schedule for removal.
- * This does *not* lead to the LSA being flooded, that must be taken
- * care of elsewhere, see, e.g., ospf_lsa_flush* (which are callers of this
- * function).
- */
 void
 ospf_lsa_maxage (struct ospf *ospf, struct ospf_lsa *lsa)
 {
@@ -2913,8 +2990,7 @@
   if (IS_DEBUG_OSPF (lsa, LSA_FLOODING))
     zlog_debug ("LSA[%s]: MaxAge LSA remover scheduled.", dump_lsa_key (lsa));
 
-  OSPF_TIMER_ON (ospf->t_maxage, ospf_maxage_lsa_remover,
-                 ospf->maxage_delay);
+  OSPF_TIMER_ON (ospf->t_maxage, ospf_maxage_lsa_remover, 2);
 }
 
 static int
@@ -2959,10 +3035,6 @@
 	ospf_lsa_maxage (ospf, lsa);
       }
 
-  if (IS_LSA_MAXAGE (lsa) && !ospf_lsa_is_self_originated (ospf, lsa))
-    if (LS_AGE (lsa) > OSPF_LSA_MAXAGE + 30)
-      printf ("Eek! Shouldn't happen!\n");
-
   return 0;
 }
 
@@ -3281,7 +3353,6 @@
   switch (lsa->data->type)
     {
 #ifdef HAVE_OPAQUE_LSA
-    /* Opaque wants to be notified of flushes */
     case OSPF_OPAQUE_LINK_LSA:
     case OSPF_OPAQUE_AREA_LSA:
     case OSPF_OPAQUE_AS_LSA:
@@ -3289,8 +3360,7 @@
       break;
 #endif /* HAVE_OPAQUE_LSA */
     default:
-      ospf_refresher_unregister_lsa (ospf, lsa);
-      ospf_lsa_flush (ospf, lsa);
+      ospf_lsa_maxage (ospf, lsa);
       break;
     }
 
@@ -3313,13 +3383,12 @@
       if ((lsa = area->router_lsa_self) != NULL)
         {
           if (IS_DEBUG_OSPF_EVENT)
-            zlog_debug ("LSA[Type%d:%s]: Schedule self-originated LSA to FLUSH",
-                        lsa->data->type, inet_ntoa (lsa->data->id));
+            zlog_debug ("LSA[Type%d:%s]: Schedule self-originated LSA to FLUSH", lsa->data->type, inet_ntoa (lsa->data->id));
           
-          ospf_refresher_unregister_lsa (ospf, lsa);
           ospf_lsa_flush_area (lsa, area);
           ospf_lsa_unlock (&area->router_lsa_self);
           area->router_lsa_self = NULL;
+          OSPF_TIMER_OFF (area->t_router_lsa_self);
         }
 
       for (ALL_LIST_ELEMENTS (area->oiflist, node2, nnode2, oi))
@@ -3329,13 +3398,12 @@
                &&   oi->full_nbrs > 0)
             {
               if (IS_DEBUG_OSPF_EVENT)
-                zlog_debug ("LSA[Type%d:%s]: Schedule self-originated LSA to FLUSH",
-                            lsa->data->type, inet_ntoa (lsa->data->id));
+                zlog_debug ("LSA[Type%d:%s]: Schedule self-originated LSA to FLUSH", lsa->data->type, inet_ntoa (lsa->data->id));
               
-              ospf_refresher_unregister_lsa (ospf, oi->network_lsa_self);
               ospf_lsa_flush_area (oi->network_lsa_self, area);
               ospf_lsa_unlock (&oi->network_lsa_self);
               oi->network_lsa_self = NULL;
+              OSPF_TIMER_OFF (oi->t_network_lsa_self);
             }
 
           if (oi->type != OSPF_IFTYPE_VIRTUALLINK
@@ -3535,28 +3603,23 @@
 
 
 /* LSA Refreshment functions. */
-struct ospf_lsa *
+static void
 ospf_lsa_refresh (struct ospf *ospf, struct ospf_lsa *lsa)
 {
   struct external_info *ei;
-  struct ospf_lsa *new = NULL;
   assert (CHECK_FLAG (lsa->flags, OSPF_LSA_SELF));
-  assert (lsa->lock > 0);
 
   switch (lsa->data->type)
     {
       /* Router and Network LSAs are processed differently. */
     case OSPF_ROUTER_LSA:
-      new = ospf_router_lsa_refresh (lsa);
-      break;
     case OSPF_NETWORK_LSA: 
-      new = ospf_network_lsa_refresh (lsa);
       break;
     case OSPF_SUMMARY_LSA:
-      new = ospf_summary_lsa_refresh (ospf, lsa);
+      ospf_summary_lsa_refresh (ospf, lsa);
       break;
     case OSPF_ASBR_SUMMARY_LSA:
-      new = ospf_summary_asbr_lsa_refresh (ospf, lsa);
+      ospf_summary_asbr_lsa_refresh (ospf, lsa);
       break;
     case OSPF_AS_EXTERNAL_LSA:
       /* Translated from NSSA Type-5s are refreshed when 
@@ -3566,7 +3629,7 @@
         break;
       ei = ospf_external_info_check (lsa);
       if (ei)
-        new = ospf_external_lsa_refresh (ospf, lsa, ei, LSA_REFRESH_FORCE);
+        ospf_external_lsa_refresh (ospf, lsa, ei, LSA_REFRESH_FORCE);
       else
         ospf_lsa_flush_as (ospf, lsa);
       break;
@@ -3574,13 +3637,12 @@
     case OSPF_OPAQUE_LINK_LSA:
     case OSPF_OPAQUE_AREA_LSA:
     case OSPF_OPAQUE_AS_LSA:
-      new = ospf_opaque_lsa_refresh (lsa);
+      ospf_opaque_lsa_refresh (lsa);
       break;
 #endif /* HAVE_OPAQUE_LSA */
     default:
       break;
     }
-  return new;
 }
 
 void
@@ -3588,7 +3650,6 @@
 {
   u_int16_t index, current_index;
   
-  assert (lsa->lock > 0);
   assert (CHECK_FLAG (lsa->flags, OSPF_LSA_SELF));
 
   if (lsa->refresh_list < 0)
@@ -3607,8 +3668,8 @@
       if (delay < 0)
 	delay = 0;
 
-      current_index = ospf->lsa_refresh_queue.index + (quagga_time (NULL)
-                - ospf->lsa_refresher_started)/OSPF_LSA_REFRESHER_GRANULARITY;
+      current_index = ospf->lsa_refresh_queue.index +
+	(quagga_time (NULL) - ospf->lsa_refresher_started)/OSPF_LSA_REFRESHER_GRANULARITY;
       
       index = (current_index + delay/OSPF_LSA_REFRESHER_GRANULARITY)
 	      % (OSPF_LSA_REFRESHER_SLOTS);
@@ -3631,7 +3692,6 @@
 void
 ospf_refresher_unregister_lsa (struct ospf *ospf, struct ospf_lsa *lsa)
 {
-  assert (lsa->lock > 0);
   assert (CHECK_FLAG (lsa->flags, OSPF_LSA_SELF));
   if (lsa->refresh_list >= 0)
     {
@@ -3668,9 +3728,8 @@
      modulus. */
   ospf->lsa_refresh_queue.index =
    ((unsigned long)(ospf->lsa_refresh_queue.index +
-		    (quagga_time (NULL) - ospf->lsa_refresher_started)
-		    / OSPF_LSA_REFRESHER_GRANULARITY))
-		    % OSPF_LSA_REFRESHER_SLOTS;
+		    (quagga_time (NULL) - ospf->lsa_refresher_started) /
+		    OSPF_LSA_REFRESHER_GRANULARITY)) % OSPF_LSA_REFRESHER_SLOTS;
 
   if (IS_DEBUG_OSPF (lsa, LSA_REFRESH))
     zlog_debug ("LSA[Refresh]: ospf_lsa_refresh_walker(): next index %d",
@@ -3685,8 +3744,6 @@
 
       refresh_list = ospf->lsa_refresh_queue.qs [i];
       
-      assert (i >= 0);
-
       ospf->lsa_refresh_queue.qs [i] = NULL;
 
       if (refresh_list)
@@ -3698,8 +3755,8 @@
 		           "refresh lsa %p (slot %d)", 
 		           inet_ntoa (lsa->data->id), lsa, i);
 	      
-	      assert (lsa->lock > 0);
 	      list_delete_node (refresh_list, node);
+	      ospf_lsa_unlock (&lsa); /* lsa_refresh_queue */
 	      lsa->refresh_list = -1;
 	      listnode_add (lsa_to_refresh, lsa);
 	    }
@@ -3712,11 +3769,7 @@
   ospf->lsa_refresher_started = quagga_time (NULL);
 
   for (ALL_LIST_ELEMENTS (lsa_to_refresh, node, nnode, lsa))
-    {
       ospf_lsa_refresh (ospf, lsa);
-      assert (lsa->lock > 0);
-      ospf_lsa_unlock (&lsa); /* lsa_refresh_queue & temp for lsa_to_refresh*/
-    }
   
   list_delete (lsa_to_refresh);
   
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospfd/ospf_ism.c	2011-03-21 05:43:52.000000000 -0400
+++ ./ospfd/ospf_ism.c	2010-10-18 16:13:50.000000000 -0400
@@ -221,8 +221,8 @@
 
   new_state = ospf_ism_state (oi);
 
-  zlog_debug ("DR-Election[1st]: Backup %s", inet_ntoa (BDR (oi)));
-  zlog_debug ("DR-Election[1st]: DR     %s", inet_ntoa (DR (oi)));
+  zlog_info ("DR-Election[1st]: Backup %s", inet_ntoa (BDR (oi)));
+  zlog_info ("DR-Election[1st]: DR     %s", inet_ntoa (DR (oi)));
 
   if (new_state != old_state &&
       !(new_state == ISM_DROther && old_state < ISM_DROther))
@@ -232,8 +232,8 @@
 
       new_state = ospf_ism_state (oi);
 
-      zlog_debug ("DR-Election[2nd]: Backup %s", inet_ntoa (BDR (oi)));
-      zlog_debug ("DR-Election[2nd]: DR     %s", inet_ntoa (DR (oi)));
+      zlog_info ("DR-Election[2nd]: Backup %s", inet_ntoa (BDR (oi)));
+      zlog_info ("DR-Election[2nd]: DR     %s", inet_ntoa (DR (oi)));
     }
 
   list_delete (el_list);
@@ -578,17 +578,20 @@
     oi->area->act_ints++;
 
   /* schedule router-LSA originate. */
-  ospf_router_lsa_update_area (oi->area);
+  ospf_router_lsa_timer_add (oi->area);
 
   /* Originate network-LSA. */
   if (old_state != ISM_DR && state == ISM_DR)
-    ospf_network_lsa_update (oi);
+    ospf_network_lsa_timer_add (oi);
   else if (old_state == ISM_DR && state != ISM_DR)
     {
       /* Free self originated network LSA. */
       lsa = oi->network_lsa_self;
       if (lsa)
+	{
         ospf_lsa_flush_area (lsa, oi->area);
+	  OSPF_TIMER_OFF (oi->t_network_lsa_self);
+	}
 
       ospf_lsa_unlock (&oi->network_lsa_self);
       oi->network_lsa_self = NULL;
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospfd/ospf_ase.c	2011-03-21 07:09:13.000000000 -0400
+++ ./ospfd/ospf_ase.c	2010-10-18 16:13:48.000000000 -0400
@@ -451,8 +451,8 @@
 
   /* if there is a Intra/Inter area route to the N
      do not install external route */
-  if ((rn = route_node_lookup (ospf->new_table,
-			      (struct prefix *) &p)))
+  if (rn = route_node_lookup (ospf->new_table,
+			      (struct prefix *) &p))
     {
       route_unlock_node(rn);
       if (rn->info == NULL)
@@ -463,8 +463,8 @@
     }
   /* Find a route to the same dest */
   /* If there is no route, create new one. */
-  if ((rn = route_node_lookup (ospf->new_external_route,
-			       (struct prefix *) &p)))
+  if (rn = route_node_lookup (ospf->new_external_route,
+			       (struct prefix *) &p))
       route_unlock_node(rn);
 
   if (!rn || (or = rn->info) == NULL)
@@ -718,6 +718,7 @@
 
   /* We assume that if LSA is deleted from DB
      is is also deleted from this RT */
+
   listnode_add (lst, ospf_lsa_lock (lsa)); /* external_lsas lst */
 }
 
@@ -798,8 +799,7 @@
     }
 
   rn = route_node_lookup (ospf->external_lsas, (struct prefix *) &p);
-  assert (rn); 
-  assert (rn->info);
+  assert (rn && rn->info);
   lsas = rn->info;
   route_unlock_node (rn);
 
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospfd/ospf_flood.c	2011-03-21 07:09:13.000000000 -0400
+++ ./ospfd/ospf_flood.c	2010-10-18 16:13:48.000000000 -0400
@@ -135,7 +135,7 @@
       /* Originate a new instance and schedule flooding */
       if (area->router_lsa_self)
 	area->router_lsa_self->data->ls_seqnum = new->data->ls_seqnum;
-      ospf_router_lsa_update_area (area);
+      ospf_router_lsa_timer_add (area);
       return;
     case OSPF_NETWORK_LSA:
 #ifdef HAVE_OPAQUE_LSA
@@ -171,7 +171,7 @@
             if (oi->network_lsa_self)
 	      oi->network_lsa_self->data->ls_seqnum = new->data->ls_seqnum;
             /* Schedule network-LSA origination. */
-            ospf_network_lsa_update (oi);
+            ospf_network_lsa_timer_add (oi);
             return;
           }
       break;
@@ -991,33 +991,3 @@
   ospf_flood_through_as (ospf, NULL, lsa);
   ospf_lsa_maxage (ospf, lsa);
 }
-
-void
-ospf_lsa_flush (struct ospf *ospf, struct ospf_lsa *lsa)
-{
-  lsa->data->ls_age = htons (OSPF_LSA_MAXAGE);
-  
-  switch (lsa->data->type)
-    {
-      case OSPF_ROUTER_LSA:
-      case OSPF_NETWORK_LSA:
-      case OSPF_SUMMARY_LSA:
-      case OSPF_ASBR_SUMMARY_LSA:
-      case OSPF_AS_NSSA_LSA:
-#ifdef HAVE_OPAQUE_LSA
-      case OSPF_OPAQUE_LINK_LSA:
-      case OSPF_OPAQUE_AREA_LSA:
-#endif /* HAVE_OPAQUE_LSA */
-        ospf_lsa_flush_area (lsa, lsa->area);
-        break;
-      case OSPF_AS_EXTERNAL_LSA:
-#ifdef HAVE_OPAQUE_LSA
-      case OSPF_OPAQUE_AS_LSA:
-#endif /* HAVE_OPAQUE_LSA */
-        ospf_lsa_flush_as (ospf, lsa);
-        break;
-      default:
-        zlog_info ("%s: Unknown LSA type %u", __func__, lsa->data->type);
-        break;
-    }
-}
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospfd/ospfd.c	2011-03-21 05:43:52.000000000 -0400
+++ ./ospfd/ospfd.c	2010-10-18 16:13:50.000000000 -0400
@@ -131,8 +131,8 @@
 	  ospf->external_origin = 0;
 	}
 
-      /* update router-lsa's for each area */
-      ospf_router_lsa_update (ospf);
+      OSPF_TIMER_ON (ospf->t_router_lsa_update,
+		     ospf_router_lsa_update_timer, OSPF_LSA_UPDATE_DELAY);
       
       /* update ospf_interface's */
       for (ALL_LIST_ELEMENTS_RO (om->iflist, node, ifp))
@@ -199,7 +199,6 @@
   new->spf_hold_multiplier = 1;
 
   /* MaxAge init. */
-  new->maxage_delay = OSFP_LSA_MAXAGE_REMOVE_DELAY_DEFAULT;
   new->maxage_lsa = list_new ();
   new->t_maxage_walker =
     thread_add_timer (master, ospf_lsa_maxage_walker,
@@ -338,7 +337,7 @@
           SET_FLAG (area->stub_router_state, OSPF_AREA_ADMIN_STUB_ROUTED);
           
           if (!CHECK_FLAG (area->stub_router_state, OSPF_AREA_IS_STUB_ROUTED))
-            ospf_router_lsa_update_area (area);
+              ospf_router_lsa_timer_add (area);
         }
       timeout = ospf->stub_router_shutdown_time;
     }
@@ -474,6 +473,7 @@
 
   /* Cancel all timers. */
   OSPF_TIMER_OFF (ospf->t_external_lsa);
+  OSPF_TIMER_OFF (ospf->t_router_lsa_update);
   OSPF_TIMER_OFF (ospf->t_spf_calc);
   OSPF_TIMER_OFF (ospf->t_ase_calc);
   OSPF_TIMER_OFF (ospf->t_maxage);
@@ -631,6 +631,7 @@
     free (IMPORT_NAME (area));
 
   /* Cancel timer. */
+  OSPF_TIMER_OFF (area->t_router_lsa_self);
   OSPF_TIMER_OFF (area->t_stub_router);
 #ifdef HAVE_OPAQUE_LSA
   OSPF_TIMER_OFF (area->t_opaque_lsa_self);
@@ -1040,7 +1041,7 @@
       break;
     }
 
-  ospf_router_lsa_update_area (area);
+  ospf_router_lsa_timer_add (area);
   ospf_schedule_abr_task (area->ospf);
 }
 
@@ -1051,7 +1052,7 @@
     return 0;
 
   area->shortcut_configured = mode;
-  ospf_router_lsa_update_area (area);
+  ospf_router_lsa_timer_add (area);
   ospf_schedule_abr_task (ospf);
 
   ospf_area_check_free (ospf, area->area_id);
@@ -1063,7 +1064,7 @@
 ospf_area_shortcut_unset (struct ospf *ospf, struct ospf_area *area)
 {
   area->shortcut_configured = OSPF_SHORTCUT_DEFAULT;
-  ospf_router_lsa_update_area (area);
+  ospf_router_lsa_timer_add (area);
   ospf_area_check_free (ospf, area->area_id);
   ospf_schedule_abr_task (ospf);
 
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./lib/memtypes.h	2011-03-21 10:33:45.000000000 -0400
+++ ./lib/memtypes.h	2010-10-19 13:20:55.000000000 -0400
@@ -89,7 +89,6 @@
   MTYPE_BGP_NODE,
   MTYPE_BGP_ROUTE,
   MTYPE_BGP_ROUTE_EXTRA,
-  MTYPE_BGP_CONN,
   MTYPE_BGP_STATIC,
   MTYPE_BGP_ADVERTISE_ATTR,
   MTYPE_BGP_ADVERTISE,
@@ -124,6 +123,9 @@
   MTYPE_BGP_DAMP_ARRAY,
   MTYPE_BGP_REGEXP,
   MTYPE_BGP_AGGREGATE,
+  MTYPE_SRX_HOST,
+  MTYPE_BGP_INFO_HASH,
+  MTYPE_BGP_INFO_HASH_ITEM,
   MTYPE_RIP,
   MTYPE_RIP_INFO,
   MTYPE_RIP_INTERFACE,
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./lib/distribute.c	2011-03-21 09:43:34.000000000 -0400
+++ ./lib/distribute.c	2010-10-18 16:12:30.000000000 -0400
@@ -114,11 +114,16 @@
 }
 
 static unsigned int
-distribute_hash_make (void *arg)
+distribute_hash_make (struct distribute *dist)
 {
-  const struct distribute *dist = arg;
+  unsigned int i, key;
 
-  return dist->ifname ? string_hash_make (dist->ifname) : 0;
+  key = 0;
+  if (dist->ifname)
+    for (i = 0; i < strlen (dist->ifname); i++)
+      key += dist->ifname[i];
+
+  return key;
 }
 
 /* If two distribute-list have same value then return 1 else return
@@ -758,7 +763,7 @@
 void
 distribute_list_init (int node)
 {
-  disthash = hash_create (distribute_hash_make,
+  disthash = hash_create ((unsigned int (*) (void *)) distribute_hash_make,
                           (int (*) (const void *, const void *)) distribute_cmp);
 
   if(node==RIP_NODE) {
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./lib/vty.c	2011-03-21 05:43:52.000000000 -0400
+++ ./lib/vty.c	2010-10-18 16:12:24.000000000 -0400
@@ -250,7 +250,7 @@
 	vty_out (vty, "MOTD file not found%s", VTY_NEWLINE);
     }
   else if (host.motd)
-    vty_out (vty, "%s", host.motd);
+    vty_out (vty, host.motd);
 }
 
 /* Put out prompt and wait input from user. */
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./lib/table.c	2011-03-21 07:09:13.000000000 -0400
+++ ./lib/table.c	2010-10-18 16:12:26.000000000 -0400
@@ -209,10 +209,6 @@
     {
       if (node->info)
 	matched = node;
-      
-      if (node->p.prefixlen == p->prefixlen)
-        break;
-      
       node = node->link[prefix_bit(&p->u.prefix, node->p.prefixlen)];
     }
 
@@ -264,8 +260,8 @@
   while (node && node->p.prefixlen <= p->prefixlen && 
 	 prefix_match (&node->p, p))
     {
-      if (node->p.prefixlen == p->prefixlen)
-        return node->info ? route_lock_node (node) : NULL;
+      if (node->p.prefixlen == p->prefixlen && node->info)
+	return route_lock_node (node);
 
       node = node->link[prefix_bit(&p->u.prefix, node->p.prefixlen)];
     }
@@ -287,8 +283,10 @@
 	 prefix_match (&node->p, p))
     {
       if (node->p.prefixlen == p->prefixlen)
-        return route_lock_node (node);
-      
+	{
+	  route_lock_node (node);
+	  return node;
+	}
       match = node;
       node = node->link[prefix_bit(&p->u.prefix, node->p.prefixlen)];
     }
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./lib/thread.c	2011-03-21 05:43:52.000000000 -0400
+++ ./lib/thread.c	2010-10-18 16:12:32.000000000 -0400
@@ -303,7 +303,7 @@
   void *args[3] = {&tmp, vty, &filter};
 
   memset(&tmp, 0, sizeof tmp);
-  tmp.funcname = (char *)"TOTAL";
+  tmp.funcname = "TOTAL";
   tmp.types = filter;
 
 #ifdef HAVE_RUSAGE
@@ -383,89 +383,6 @@
   return CMD_SUCCESS;
 }
 
-static void
-cpu_record_hash_clear (struct hash_backet *bucket, 
-		      void *args)
-{
-  thread_type *filter = args;
-  struct cpu_thread_history *a = bucket->data;
-  
-  a = bucket->data;
-  if ( !(a->types & *filter) )
-       return;
-  
-  hash_release (cpu_record, bucket->data);
-}
-
-static void
-cpu_record_clear (thread_type filter)
-{
-  thread_type *tmp = &filter;
-  hash_iterate (cpu_record,
-	        (void (*) (struct hash_backet*,void*)) cpu_record_hash_clear,
-	        tmp);
-}
-
-DEFUN(clear_thread_cpu,
-      clear_thread_cpu_cmd,
-      "clear thread cpu [FILTER]",
-      "Clear stored data\n"
-      "Thread information\n"
-      "Thread CPU usage\n"
-      "Display filter (rwtexb)\n")
-{
-  int i = 0;
-  thread_type filter = (thread_type) -1U;
-
-  if (argc > 0)
-    {
-      filter = 0;
-      while (argv[0][i] != '\0')
-	{
-	  switch ( argv[0][i] )
-	    {
-	    case 'r':
-	    case 'R':
-	      filter |= (1 << THREAD_READ);
-	      break;
-	    case 'w':
-	    case 'W':
-	      filter |= (1 << THREAD_WRITE);
-	      break;
-	    case 't':
-	    case 'T':
-	      filter |= (1 << THREAD_TIMER);
-	      break;
-	    case 'e':
-	    case 'E':
-	      filter |= (1 << THREAD_EVENT);
-	      break;
-	    case 'x':
-	    case 'X':
-	      filter |= (1 << THREAD_EXECUTE);
-	      break;
-	    case 'b':
-	    case 'B':
-	      filter |= (1 << THREAD_BACKGROUND);
-	      break;
-	    default:
-	      break;
-	    }
-	  ++i;
-	}
-      if (filter == 0)
-	{
-	  vty_out(vty, "Invalid filter \"%s\" specified,"
-                  " must contain at least one of 'RWTEXB'%s",
-		  argv[0], VTY_NEWLINE);
-	  return CMD_WARNING;
-	}
-    }
-
-  cpu_record_clear (filter);
-  return CMD_SUCCESS;
-}
-
 /* List allocation and head/tail print out. */
 static void
 thread_list_debug (struct thread_list *list)
@@ -986,24 +903,6 @@
   return ready;
 }
 
-/* process a list en masse, e.g. for event thread lists */
-static unsigned int
-thread_process (struct thread_list *list)
-{
-  struct thread *thread;
-  unsigned int ready = 0;
-  
-  for (thread = list->head; thread; thread = thread->next)
-    {
-      thread_list_delete (list, thread);
-      thread->type = THREAD_READY;
-      thread_list_add (&thread->master->ready, thread);
-      ready++;
-    }
-  return ready;
-}
-
-
 /* Fetch next ready thread. */
 struct thread *
 thread_fetch (struct thread_master *m, struct thread *fetch)
@@ -1012,31 +911,27 @@
   fd_set readfd;
   fd_set writefd;
   fd_set exceptfd;
-  struct timeval timer_val = { .tv_sec = 0, .tv_usec = 0 };
+  struct timeval timer_val;
   struct timeval timer_val_bg;
-  struct timeval *timer_wait = &timer_val;
+  struct timeval *timer_wait;
   struct timeval *timer_wait_bg;
 
   while (1)
     {
       int num = 0;
       
-      /* Signals pre-empt everything */
+      /* Signals are highest priority */
       quagga_sigevent_process ();
        
-      /* Drain the ready queue of already scheduled jobs, before scheduling
-       * more.
-       */
-      if ((thread = thread_trim_head (&m->ready)) != NULL)
+      /* Normal event are the next highest priority.  */
+      if ((thread = thread_trim_head (&m->event)) != NULL)
         return thread_run (m, thread, fetch);
       
-      /* To be fair to all kinds of threads, and avoid starvation, we
-       * need to be careful to consider all thread types for scheduling
-       * in each quanta. I.e. we should not return early from here on.
+      /* If there are any ready threads from previous scheduler runs,
+       * process top of them.  
        */
-       
-      /* Normal event are the next highest priority.  */
-      thread_process (&m->event);
+      if ((thread = thread_trim_head (&m->ready)) != NULL)
+        return thread_run (m, thread, fetch);
       
       /* Structure copy.  */
       readfd = m->readfd;
@@ -1044,8 +939,6 @@
       exceptfd = m->exceptfd;
       
       /* Calculate select wait timer if nothing else to do */
-      if (m->ready.count == 0)
-        {
           quagga_get_relative (NULL);
           timer_wait = thread_timer_wait (&m->timer, &timer_val);
           timer_wait_bg = thread_timer_wait (&m->background, &timer_val_bg);
@@ -1053,7 +946,6 @@
           if (timer_wait_bg &&
               (!timer_wait || (timeval_cmp (*timer_wait, *timer_wait_bg) > 0)))
             timer_wait = timer_wait_bg;
-        }
       
       num = select (FD_SETSIZE, &readfd, &writefd, &exceptfd, timer_wait);
       
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./lib/memtypes.c	2011-03-21 09:43:34.000000000 -0400
+++ ./lib/memtypes.c	2010-10-18 16:12:30.000000000 -0400
@@ -108,7 +108,6 @@
   { MTYPE_BGP_NODE,		"BGP node"			},
   { MTYPE_BGP_ROUTE,		"BGP route"			},
   { MTYPE_BGP_ROUTE_EXTRA,	"BGP ancillary route info"	},
-  { MTYPE_BGP_CONN,		"BGP connected"			},
   { MTYPE_BGP_STATIC,		"BGP static"			},
   { MTYPE_BGP_ADVERTISE_ATTR,	"BGP adv attr"			},
   { MTYPE_BGP_ADVERTISE,	"BGP adv"			},
@@ -151,6 +150,10 @@
   { MTYPE_BGP_DAMP_ARRAY,	"BGP Dampening array"		},
   { MTYPE_BGP_REGEXP,		"BGP regexp"			},
   { MTYPE_BGP_AGGREGATE,	"BGP aggregate"			},
+  { 0, NULL },
+  { MTYPE_SRX_HOST,           "SRx host name" },
+  { MTYPE_BGP_INFO_HASH,      "BGP info hash" },
+  { MTYPE_BGP_INFO_HASH_ITEM, "BGP info hash item" },
   { -1, NULL }
 };
 
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./lib/log.c	2011-03-21 09:43:34.000000000 -0400
+++ ./lib/log.c	2010-10-18 16:12:28.000000000 -0400
@@ -653,9 +653,6 @@
   if (zl->fp != NULL)
     fclose (zl->fp);
 
-  if (zl->filename != NULL)
-    free (zl->filename);
-
   XFREE (MTYPE_ZLOG, zl);
 }
 
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./lib/hash.h	2011-03-21 09:43:34.000000000 -0400
+++ ./lib/hash.h	2010-10-18 16:12:54.000000000 -0400
@@ -70,6 +70,4 @@
 extern void hash_clean (struct hash *, void (*) (void *));
 extern void hash_free (struct hash *);
 
-extern unsigned int string_hash_make (const char *);
-
 #endif /* _ZEBRA_HASH_H */
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./lib/workqueue.c	2011-03-21 05:43:52.000000000 -0400
+++ ./lib/workqueue.c	2010-10-18 16:12:31.000000000 -0400
@@ -341,7 +341,7 @@
 
 stats:
 
-#define WQ_HYSTERESIS_FACTOR 4
+#define WQ_HYSTERIS_FACTOR 2
 
   /* we yielded, check whether granularity should be reduced */
   if (yielded && (cycles < wq->cycles.granularity))
@@ -349,18 +349,17 @@
       wq->cycles.granularity = ((cycles > 0) ? cycles 
                                              : WORK_QUEUE_MIN_GRANULARITY);
     }
-  /* otherwise, should granularity increase? */
-  else if (cycles >= (wq->cycles.granularity))
+  
+  if (cycles >= (wq->cycles.granularity))
     {
       if (cycles > wq->cycles.best)
         wq->cycles.best = cycles;
       
-      /* along with yielded check, provides hysteresis for granularity */
-      if (cycles > (wq->cycles.granularity * WQ_HYSTERESIS_FACTOR
-                                           * WQ_HYSTERESIS_FACTOR))
-        wq->cycles.granularity *= WQ_HYSTERESIS_FACTOR; /* quick ramp-up */
-      else if (cycles > (wq->cycles.granularity * WQ_HYSTERESIS_FACTOR))
-        wq->cycles.granularity += WQ_HYSTERESIS_FACTOR;
+      /* along with yielded check, provides hysteris for granularity */
+      if (cycles > (wq->cycles.granularity * WQ_HYSTERIS_FACTOR * 2))
+        wq->cycles.granularity *= WQ_HYSTERIS_FACTOR; /* quick ramp-up */
+      else if (cycles > (wq->cycles.granularity * WQ_HYSTERIS_FACTOR))
+        wq->cycles.granularity += WQ_HYSTERIS_FACTOR;
     }
 #undef WQ_HYSTERIS_FACTOR
   
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./lib/zclient.c	2011-03-21 07:09:13.000000000 -0400
+++ ./lib/zclient.c	2010-10-18 16:12:51.000000000 -0400
@@ -339,12 +339,12 @@
   /* Create read thread. */
   zclient_event (ZCLIENT_READ, zclient);
 
-  /* We need router-id information. */
-  zebra_message_send (zclient, ZEBRA_ROUTER_ID_ADD);
-
   /* We need interface information. */
   zebra_message_send (zclient, ZEBRA_INTERFACE_ADD);
 
+  /* We need router-id information. */
+  zebra_message_send (zclient, ZEBRA_ROUTER_ID_ADD);
+
   /* Flush all redistribute request. */
   for (i = 0; i < ZEBRA_ROUTE_MAX; i++)
     if (i != zclient->redist_default && zclient->redist[i])
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./lib/prefix.h	2011-03-21 05:43:52.000000000 -0400
+++ ./lib/prefix.h	2010-10-18 16:12:57.000000000 -0400
@@ -144,8 +144,8 @@
 }
 
 /* Prototypes. */
-extern int afi2family (afi_t);
-extern afi_t family2afi (int);
+extern int afi2family (int);
+extern int family2afi (int);
 
 extern struct prefix *prefix_new (void);
 extern void prefix_free (struct prefix *);
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./lib/memory.c	2011-03-21 09:43:34.000000000 -0400
+++ ./lib/memory.c	2010-10-18 16:12:34.000000000 -0400
@@ -58,11 +58,7 @@
   abort();
 }
 
-/*
- * Allocate memory of a given size, to be tracked by a given type.
- * Effects: Returns a pointer to usable memory.  If memory cannot
- * be allocated, aborts execution.
- */
+/* Memory allocation. */
 void *
 zmalloc (int type, size_t size)
 {
@@ -78,9 +74,7 @@
   return memory;
 }
 
-/*
- * Allocate memory as in zmalloc, and also clear the memory.
- */
+/* Memory allocation with num * size with cleared. */
 void *
 zcalloc (int type, size_t size)
 {
@@ -96,13 +90,7 @@
   return memory;
 }
 
-/* 
- * Given a pointer returned by zmalloc or zcalloc, free it and
- * return a pointer to a new size, basically acting like realloc().
- * Requires: ptr was returned by zmalloc, zcalloc, or zrealloc with the
- * same type.
- * Effects: Returns a pointer to the new memory, or aborts.
- */
+/* Memory reallocation. */
 void *
 zrealloc (int type, void *ptr, size_t size)
 {
@@ -111,34 +99,18 @@
   memory = realloc (ptr, size);
   if (memory == NULL)
     zerror ("realloc", type, size);
-  if (ptr == NULL)
-    alloc_inc (type);
-
   return memory;
 }
 
-/*
- * Free memory allocated by z*alloc or zstrdup.
- * Requires: ptr was returned by zmalloc, zcalloc, or zrealloc with the
- * same type.
- * Effects: The memory is freed and may no longer be referenced.
- */
+/* Memory free. */
 void
 zfree (int type, void *ptr)
 {
-  if (ptr != NULL)
-    {
       alloc_dec (type);
       free (ptr);
     }
-}
 
-/*
- * Duplicate a string, counting memory usage by type.
- * Effects: The string is duplicated, and the return value must
- * eventually be passed to zfree with the same type.  The function will
- * succeed or abort.
- */
+/* String duplication. */
 char *
 zstrdup (int type, const char *str)
 {
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./lib/prefix.c	2011-03-21 07:09:13.000000000 -0400
+++ ./lib/prefix.c	2010-10-18 16:12:38.000000000 -0400
@@ -41,7 +41,7 @@
 
 /* Address Famiy Identifier to Address Family converter. */
 int
-afi2family (afi_t afi)
+afi2family (int afi)
 {
   if (afi == AFI_IP)
     return AF_INET;
@@ -52,7 +52,7 @@
   return 0;
 }
 
-afi_t
+int
 family2afi (int family)
 {
   if (family == AF_INET)
@@ -70,16 +70,15 @@
 {
   int offset;
   int shift;
-  const u_char *np, *pp;
+
+  /* Set both prefix's head pointer. */
+  const u_char *np = (const u_char *)&n->u.prefix;
+  const u_char *pp = (const u_char *)&p->u.prefix;
 
   /* If n's prefix is longer than p's one return 0. */
   if (n->prefixlen > p->prefixlen)
     return 0;
 
-  /* Set both prefix's head pointer. */
-  np = (const u_char *)&n->u.prefix;
-  pp = (const u_char *)&p->u.prefix;
-  
   offset = n->prefixlen / PNBBY;
   shift =  n->prefixlen % PNBBY;
 
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./lib/command.c	2011-03-21 05:43:52.000000000 -0400
+++ ./lib/command.c	2010-10-18 16:12:37.000000000 -0400
@@ -3650,8 +3650,6 @@
       install_element (VIEW_NODE, &show_thread_cpu_cmd);
       install_element (ENABLE_NODE, &show_thread_cpu_cmd);
       install_element (RESTRICTED_NODE, &show_thread_cpu_cmd);
-      
-      install_element (ENABLE_NODE, &clear_thread_cpu_cmd);
       install_element (VIEW_NODE, &show_work_queues_cmd);
       install_element (ENABLE_NODE, &show_work_queues_cmd);
     }
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./lib/if_rmap.c	2011-03-21 09:43:34.000000000 -0400
+++ ./lib/if_rmap.c	2010-10-18 16:12:29.000000000 -0400
@@ -109,9 +109,14 @@
 static unsigned int
 if_rmap_hash_make (void *data)
 {
-  const struct if_rmap *if_rmap = data;
+  struct if_rmap *if_rmap = data;
+  unsigned int i, key;
 
-  return string_hash_make (if_rmap->ifname);
+  key = 0;
+  for (i = 0; i < strlen (if_rmap->ifname); i++)
+    key += if_rmap->ifname[i];
+
+  return key;
 }
 
 static int
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./lib/hash.c	2011-03-21 09:43:34.000000000 -0400
+++ ./lib/hash.c	2010-10-18 16:12:35.000000000 -0400
@@ -101,17 +101,6 @@
   return hash_get (hash, data, NULL);
 }
 
-/* Simple Bernstein hash which is simple and fast for common case */
-unsigned int string_hash_make (const char *str)
-{
-  unsigned int hash = 0;
-
-  while (*str)
-    hash = (hash * 33) ^ (unsigned int) *str++;
-
-  return hash;
-}
-
 /* This function release registered value from specified hash.  When
    release is successfully finished, return the data pointer in the
    hash backet.  */
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./lib/thread.h	2011-03-21 05:43:52.000000000 -0400
+++ ./lib/thread.h	2010-10-18 16:12:58.000000000 -0400
@@ -82,7 +82,7 @@
 struct cpu_thread_history 
 {
   int (*func)(struct thread *);
-  char *funcname;
+  const char *funcname;
   unsigned int total_calls;
   struct time_stats
   {
@@ -197,7 +197,6 @@
 /* Internal libzebra exports */
 extern void thread_getrusage (RUSAGE_T *);
 extern struct cmd_element show_thread_cpu_cmd;
-extern struct cmd_element clear_thread_cpu_cmd;
 
 /* replacements for the system gettimeofday(), clock_gettime() and
  * time() functions, providing support for non-decrementing clock on
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./lib/if.c	2011-03-21 09:43:34.000000000 -0400
+++ ./lib/if.c	2010-10-18 16:12:31.000000000 -0400
@@ -878,21 +878,3 @@
 
   memset (&if_master, 0, sizeof if_master);
 }
-
-void
-if_terminate (void)
-{
-  for (;;)
-    {
-      struct interface *ifp;
-
-      ifp = listnode_head (iflist);
-      if (ifp == NULL)
-	break;
-
-      if_delete (ifp);
-    }
-
-  list_delete (iflist);
-  iflist = NULL;
-}
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./lib/if.h	2011-03-21 09:43:34.000000000 -0400
+++ ./lib/if.h	2010-10-18 16:12:31.000000000 -0400
@@ -266,7 +266,6 @@
 extern int if_is_multicast (struct interface *);
 extern void if_add_hook (int, int (*)(struct interface *));
 extern void if_init (void);
-extern void if_terminate (void);
 extern void if_dump_all (void);
 extern const char *if_flag_dump(unsigned long);
 
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./config.h.in	2011-03-21 10:46:41.000000000 -0400
+++ ./config.h.in	2011-10-01 04:51:58.000000000 -0400
@@ -284,6 +284,9 @@
 /* prctl */
 #undef HAVE_PR_SET_KEEPCAPS
 
+/* Define to 1 if you have the <pthread.h> header file. */
+#undef HAVE_PTHREAD_H
+
 /* Define to 1 if your system has a GNU libc compatible `realloc' function,
    and to 0 otherwise. */
 #undef HAVE_REALLOC
@@ -551,18 +554,6 @@
 /* IRIX 6.5 */
 #undef IRIX_65
 
-/* selected method for isis, == one of the constants */
-#undef ISIS_METHOD
-
-/* constant value for isis method bpf */
-#undef ISIS_METHOD_BPF
-
-/* constant value for isis method dlpi */
-#undef ISIS_METHOD_DLPI
-
-/* constant value for isis method pfpacket */
-#undef ISIS_METHOD_PFPACKET
-
 /* isisd vty socket */
 #undef ISIS_VTYSH_PATH
 
@@ -706,6 +697,9 @@
 /* Use PAM for authentication */
 #undef USE_PAM
 
+/* SRX */
+#undef USE_SRX
+
 /* Enable extensions on AIX 3, Interix.  */
 #ifndef _ALL_SOURCE
 # undef _ALL_SOURCE
@@ -771,6 +765,9 @@
 /* Define to 1 if you need to in order for `stat' and other things to work. */
 #undef _POSIX_SOURCE
 
+/* pthread reentrant nature */
+#undef _REENTRANT
+
 /* Define to empty if `const' does not conform to ANSI C. */
 #undef const
 
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ripngd/ripng_debug.h	2011-03-21 07:09:13.000000000 -0400
+++ ./ripngd/ripng_debug.h	2010-10-18 16:14:08.000000000 -0400
@@ -29,6 +29,7 @@
 #define RIPNG_DEBUG_PACKET  0x01
 #define RIPNG_DEBUG_SEND    0x20
 #define RIPNG_DEBUG_RECV    0x40
+#define RIPNG_DEBUG_DETAIL  0x80
 
 #define RIPNG_DEBUG_ZEBRA   0x01
 
@@ -38,6 +39,7 @@
 #define IS_RIPNG_DEBUG_PACKET (ripng_debug_packet & RIPNG_DEBUG_PACKET)
 #define IS_RIPNG_DEBUG_SEND   (ripng_debug_packet & RIPNG_DEBUG_SEND)
 #define IS_RIPNG_DEBUG_RECV   (ripng_debug_packet & RIPNG_DEBUG_RECV)
+#define IS_RIPNG_DEBUG_DETAIL (ripng_debug_packet & RIPNG_DEBUG_DETAIL)
 
 #define IS_RIPNG_DEBUG_ZEBRA  (ripng_debug_zebra & RIPNG_DEBUG_ZEBRA)
 
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ripngd/ripng_debug.c	2011-03-21 07:09:13.000000000 -0400
+++ ./ripngd/ripng_debug.c	2010-10-18 16:14:05.000000000 -0400
@@ -45,16 +45,19 @@
     {
       if (IS_RIPNG_DEBUG_SEND && IS_RIPNG_DEBUG_RECV)
 	{
-	  vty_out (vty, "  RIPng packet debugging is on%s",
+	  vty_out (vty, "  RIPng packet%s debugging is on%s",
+		   IS_RIPNG_DEBUG_DETAIL ? " detail" : "",
 		   VTY_NEWLINE);
 	}
       else
 	{
 	  if (IS_RIPNG_DEBUG_SEND)
-	    vty_out (vty, "  RIPng packet send debugging is on%s",
+	    vty_out (vty, "  RIPng packet send%s debugging is on%s",
+		     IS_RIPNG_DEBUG_DETAIL ? " detail" : "",
 		     VTY_NEWLINE);
 	  else
-	    vty_out (vty, "  RIPng packet receive debugging is on%s",
+	    vty_out (vty, "  RIPng packet receive%s debugging is on%s",
+		     IS_RIPNG_DEBUG_DETAIL ? " detail" : "",
 		     VTY_NEWLINE);
 	}
     }
@@ -103,13 +106,11 @@
     ripng_debug_packet |= RIPNG_DEBUG_SEND;
   if (strncmp ("recv", argv[0], strlen (argv[0])) == 0)
     ripng_debug_packet |= RIPNG_DEBUG_RECV;
-
+  ripng_debug_packet &= ~RIPNG_DEBUG_DETAIL;
   return CMD_SUCCESS;
 }
 
-/* N.B. the "detail" modifier is a no-op.  we leave this command
-   for legacy compatibility. */
-DEFUN_DEPRECATED (debug_ripng_packet_detail,
+DEFUN (debug_ripng_packet_detail,
        debug_ripng_packet_detail_cmd,
        "debug ripng packet (recv|send) detail",
        DEBUG_STR
@@ -124,7 +125,7 @@
     ripng_debug_packet |= RIPNG_DEBUG_SEND;
   if (strncmp ("recv", argv[0], strlen (argv[0])) == 0)
     ripng_debug_packet |= RIPNG_DEBUG_RECV;
-
+  ripng_debug_packet |= RIPNG_DEBUG_DETAIL;
   return CMD_SUCCESS;
 }
 
@@ -224,17 +225,20 @@
     {
       if (IS_RIPNG_DEBUG_SEND && IS_RIPNG_DEBUG_RECV)
 	{
-	  vty_out (vty, "debug ripng packet%s",
+	  vty_out (vty, "debug ripng packet%s%s",
+		   IS_RIPNG_DEBUG_DETAIL ? " detail" : "",
 		   VTY_NEWLINE);
 	  write++;
 	}
       else
 	{
 	  if (IS_RIPNG_DEBUG_SEND)
-	    vty_out (vty, "debug ripng packet send%s",
+	    vty_out (vty, "debug ripng packet send%s%s",
+		     IS_RIPNG_DEBUG_DETAIL ? " detail" : "",
 		     VTY_NEWLINE);
 	  else
-	    vty_out (vty, "debug ripng packet recv%s",
+	    vty_out (vty, "debug ripng packet recv%s%s",
+		     IS_RIPNG_DEBUG_DETAIL ? " detail" : "",
 		     VTY_NEWLINE);
 	  write++;
 	}
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./isisd/isis_dlpi.c	2011-03-21 05:43:52.000000000 -0400
+++ ./isisd/isis_dlpi.c	2010-10-18 16:11:49.000000000 -0400
@@ -21,7 +21,6 @@
  */
 
 #include <zebra.h>
-#if ISIS_METHOD == ISIS_METHOD_DLPI
 #include <net/if.h>
 #include <netinet/if_ether.h>
 #include <sys/types.h>
@@ -623,5 +622,3 @@
     sock_buff, stream_get_endp (circuit->snd_stream) + LLC_LEN, 0);
   return ISIS_OK;
 }
-
-#endif /* ISIS_METHOD == ISIS_METHOD_DLPI */
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./isisd/Makefile.am	2011-03-21 05:43:52.000000000 -0400
+++ ./isisd/Makefile.am	2010-10-18 16:11:50.000000000 -0400
@@ -13,6 +13,8 @@
 sbin_PROGRAMS = isisd 
 SUBDIRS = topology
 
+isis_method = @ISIS_METHOD@
+
 libisis_a_SOURCES = \
 	isis_adjacency.c isis_lsp.c dict.c isis_circuit.c isis_pdu.c \
 	isis_tlv.c isisd.c isis_misc.c isis_zebra.c isis_dr.c \
@@ -28,10 +30,13 @@
 	include-netbsd/clnp.h include-netbsd/esis.h include-netbsd/iso.h
 
 isisd_SOURCES = \
-	isis_main.c $(libisis_a_SOURCES) \
-	isis_bpf.c isis_dlpi.c isis_pfpacket.c
+	isis_main.c $(libisis_a_SOURCES)
+
+isisd_LDADD = $(isis_method) @ISIS_TOPOLOGY_LIB@ ../lib/libzebra.la @LIBCAP@
+
+isisd_DEPENDENCIES = $(isis_method)
 
-isisd_LDADD = @ISIS_TOPOLOGY_LIB@ ../lib/libzebra.la @LIBCAP@
+EXTRA_DIST = isis_bpf.c isis_dlpi.c isis_pfpacket.c
 
 examplesdir = $(exampledir)
 dist_examples_DATA = isisd.conf.sample
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./isisd/isis_bpf.c	2011-03-21 05:43:52.000000000 -0400
+++ ./isisd/isis_bpf.c	2010-10-18 16:11:50.000000000 -0400
@@ -21,7 +21,6 @@
  */
 
 #include <zebra.h>
-#if ISIS_METHOD == ISIS_METHOD_BPF
 #include <net/if.h>
 #include <netinet/if_ether.h>
 #include <sys/time.h>
@@ -340,5 +339,3 @@
 {
   return ISIS_OK;
 }
-
-#endif /* ISIS_METHOD == ISIS_METHOD_BPF */
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./isisd/isis_pfpacket.c	2011-03-21 05:43:52.000000000 -0400
+++ ./isisd/isis_pfpacket.c	2010-10-18 16:11:50.000000000 -0400
@@ -21,7 +21,6 @@
  */
 
 #include <zebra.h>
-#if ISIS_METHOD == ISIS_METHOD_PFPACKET
 #include <net/ethernet.h>	/* the L2 protocols */
 #include <netpacket/packet.h>
 
@@ -372,5 +371,3 @@
 
   return ISIS_OK;
 }
-
-#endif /* ISIS_METHOD == ISIS_METHOD_PFPACKET */
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./configure.ac	2011-03-21 10:46:05.000000000 -0400
+++ ./configure.ac	2011-09-30 21:40:55.000000000 -0400
@@ -123,7 +123,7 @@
         AC_MSG_RESULT([Intel default])
         ;;
     "GCC")
-  	CFLAGS="-Os -fno-omit-frame-pointer -g -std=gnu99 -Wall"
+  	CFLAGS="-O0 -fno-omit-frame-pointer -g -std=gnu99 -Wall"
   	CFLAGS="${CFLAGS} -Wsign-compare -Wpointer-arith"
   	CFLAGS="${CFLAGS} -Wbad-function-cast -Wwrite-strings"
   	CFLAGS="${CFLAGS} -Wmissing-prototypes -Wmissing-declarations"
@@ -259,6 +259,8 @@
 [  --disable-time-check          disable slow thread warning messages])
 AC_ARG_ENABLE(pcreposix,
 [  --enable-pcreposix          enable using PCRE Posix libs for regex functions])
+AC_ARG_ENABLE(srx,
+[  --enable-srx           enable SRx])
 
 if test x"${enable_gcc_ultra_verbose}" = x"yes" ; then
   CFLAGS="${CFLAGS} -W -Wcast-qual -Wstrict-prototypes"
@@ -782,18 +784,15 @@
 dnl --------------------------
 dnl Determine IS-IS I/O method
 dnl --------------------------
-AC_DEFINE(ISIS_METHOD_PFPACKET,	1, [ constant value for isis method pfpacket ])
-AC_DEFINE(ISIS_METHOD_DLPI,	2, [ constant value for isis method dlpi ])
-AC_DEFINE(ISIS_METHOD_BPF,	3, [ constant value for isis method bpf ])
 AC_CHECK_HEADER(net/bpf.h)
 AC_CHECK_HEADER(sys/dlpi.h)
 AC_MSG_CHECKING(zebra IS-IS I/O method)
 if test x"$opsys" = x"gnu-linux"; then
   AC_MSG_RESULT(pfpacket)
-  ISIS_METHOD_MACRO="ISIS_METHOD_PFPACKET"
+  ISIS_METHOD=isis_pfpacket.o
 elif test x"$opsys" = x"sol2-6" -o x"$opsys" = x"sol8"; then
   AC_MSG_RESULT(DLPI)
-  ISIS_METHOD_MACRO="ISIS_METHOD_DLPI"
+  ISIS_METHOD="isis_dlpi.o"
 else
   if test $ac_cv_header_net_bpf_h = no; then
     if test $ac_cv_header_sys_dlpi_h = no; then
@@ -803,13 +802,13 @@
     else
       AC_MSG_RESULT(DLPI)
     fi
-    ISIS_METHOD_MACRO="ISIS_METHOD_DLPI"
+    ISIS_METHOD="isis_dlpi.o"
   else
     AC_MSG_RESULT(BPF)
-    ISIS_METHOD_MACRO="ISIS_METHOD_BPF"
+    ISIS_METHOD="isis_bpf.o"
   fi
 fi
-AC_DEFINE_UNQUOTED(ISIS_METHOD, $ISIS_METHOD_MACRO, [ selected method for isis, == one of the constants ])
+AC_SUBST(ISIS_METHOD)
 
 dnl ------------------------------------
 dnl check for broken CMSG_FIRSTHDR macro
@@ -1212,6 +1211,52 @@
 
 fi
 
+
+dnl ----------------------
+dnl  SRX check & pthread
+dnl ----------------------
+have_pthreads=no
+if test "x${enable_srx}" == "xyes"; then
+  AC_DEFINE(USE_SRX,,SRX)
+  SRX_LIB=libsrx.a
+  SRX_LIB_SO=-lsrx
+  SRX_DIR=srx
+
+  AC_SEARCH_LIBS([pthread_create], [pthread], [have_pthreads=yes])
+  if test "x${have_pthreads}" = xyes; then
+      AC_CHECK_HEADERS([pthread.h], [], [have_pthreads=no])
+    if test "x${have_pthreads}" = xyes; then
+        AC_DEFINE([_REENTRANT],, pthread reentrant nature)
+    fi
+  fi
+
+  if test "x${have_pthreads}" = xno; then
+      AC_MSG_ERROR([
+      --------------------------------------------------
+      The pthread library and header file required to
+      build srx.  Stopping...
+      Check 'config.log' for more information.
+      --------------------------------------------------])
+  fi
+
+  AC_MSG_CHECKING([srx client module])
+  if test -f srx/libsrx.a ; then
+      SRX_CLI_LIB=../srx/libsrx.a
+      #AC_MSG_RESULT([yes - srx directory exists])
+  else
+      SRX_CLI_LIB=${SRX_USER_INC}/srx/libsrx.a
+      #AC_MSG_RESULT([no - srx directory  NOT exists])
+  fi
+
+      #CPPFLAGS= -I${SRX_USER_INC}
+
+  AC_MSG_RESULT([CPPFLAGS:${CPPFLAGS}])
+  AC_MSG_RESULT([USER:${SRX_CLI_LIB}  srx dir:${SRX_DIR}])
+  #AC_MSG_FAILURE([test])
+
+fi
+
+
 case "${enable_ripngd}" in
   "yes") RIPNGD="ripngd";;
   "no" ) RIPNGD="";;
@@ -1258,6 +1303,10 @@
 AC_SUBST(CURSES)
 AC_SUBST(OSPFCLIENT)
 AC_SUBST(OSPFAPI)
+AC_SUBST(SRX_CLI_LIB)
+AC_SUBST(SRX_DIR)
+AC_SUBST(SRX_LIB)
+AC_SUBST(SRX_LIB_SO)
 AC_CHECK_LIB(c, inet_ntop, [AC_DEFINE(HAVE_INET_NTOP,,inet_ntop)])
 AC_CHECK_LIB(c, inet_pton, [AC_DEFINE(HAVE_INET_PTON,,inet_pton)])
 AC_CHECK_LIB(crypt, crypt)
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospf6d/ospf6_lsa.c	2011-03-21 09:43:34.000000000 -0400
+++ ./ospf6d/ospf6_lsa.c	2010-10-18 16:13:05.000000000 -0400
@@ -712,11 +712,6 @@
   ospf6_install_lsa_handler (&unknown_handler);
 }
 
-void
-ospf6_lsa_terminate (void)
-{
-  vector_free (ospf6_lsa_handler_vector);
-}
 
 static char *
 ospf6_lsa_handler_name (struct ospf6_lsa_handler *h)
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospf6d/ospf6_lsa.h	2011-03-21 09:43:34.000000000 -0400
+++ ./ospf6d/ospf6_lsa.h	2010-10-18 16:13:10.000000000 -0400
@@ -243,7 +243,6 @@
 extern struct ospf6_lsa_handler *ospf6_get_lsa_handler (u_int16_t type);
 
 extern void ospf6_lsa_init (void);
-extern void ospf6_lsa_terminate (void);
 extern void ospf6_lsa_cmd_init (void);
 
 extern int config_write_ospf6_debug_lsa (struct vty *vty);
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospf6d/ospf6_spf.c	2011-03-21 09:43:34.000000000 -0400
+++ ./ospf6d/ospf6_spf.c	2010-10-18 16:13:07.000000000 -0400
@@ -50,9 +50,7 @@
   struct ospf6_vertex *vb = (struct ospf6_vertex *) b;
 
   /* ascending order */
-  if (va->cost != vb->cost)
     return (va->cost - vb->cost);
-  return (va->hops - vb->hops);
 }
 
 static int
@@ -322,7 +320,21 @@
         }
 
       prev = (struct ospf6_vertex *) route->route_option;
-      assert (prev->hops <= v->hops);
+      if (prev->hops > v->hops)
+        {
+          for (ALL_LIST_ELEMENTS (prev->child_list, node, nnode, w))
+            {
+              assert (w->parent == prev);
+              w->parent = v;
+              listnode_add_sort (v->child_list, w);
+            }
+          listnode_delete (prev->parent->child_list, prev);
+          listnode_add_sort (v->parent->child_list, v);
+
+          ospf6_vertex_delete (prev);
+          route->route_option = v;
+        }
+      else
       ospf6_vertex_delete (v);
 
       return -1;
@@ -392,19 +404,18 @@
   caddr_t lsdesc;
   struct ospf6_lsa *lsa;
 
-  /* Install the calculating router itself as the root of the SPF tree */
-  /* construct root vertex */
-  lsa = ospf6_lsdb_lookup (htons (OSPF6_LSTYPE_ROUTER), htonl (0),
-                           router_id, oa->lsdb);
-  if (lsa == NULL)
-    return;
-
   /* initialize */
   candidate_list = pqueue_create ();
   candidate_list->cmp = ospf6_vertex_cmp;
 
   ospf6_spf_table_finish (result_table);
 
+  /* Install the calculating router itself as the root of the SPF tree */
+  /* construct root vertex */
+  lsa = ospf6_lsdb_lookup (htons (OSPF6_LSTYPE_ROUTER), htonl (0),
+                           router_id, oa->lsdb);
+  if (lsa == NULL)
+    return;
   root = ospf6_vertex_create (lsa);
   root->area = oa;
   root->cost = 0;
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospf6d/ospf6_message.c	2011-03-21 09:43:34.000000000 -0400
+++ ./ospf6d/ospf6_message.c	2010-10-18 16:13:06.000000000 -0400
@@ -1168,24 +1168,6 @@
   return iobuflen;
 }
 
-void
-ospf6_message_terminate (void)
-{
-  if (recvbuf)
-    {
-      XFREE (MTYPE_OSPF6_MESSAGE, recvbuf);
-      recvbuf = NULL;
-    }
-
-  if (sendbuf)
-    {
-      XFREE (MTYPE_OSPF6_MESSAGE, sendbuf);
-      sendbuf = NULL;
-    }
-
-  iobuflen = 0;
-}
-
 int
 ospf6_receive (struct thread *thread)
 {
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospf6d/ospf6_route.c	2011-03-21 09:43:34.000000000 -0400
+++ ./ospf6d/ospf6_route.c	2010-10-18 16:13:10.000000000 -0400
@@ -690,8 +690,6 @@
   struct route_node *rnode;
   struct ospf6_route *next;
 
-  ospf6_route_unlock (route);
-
   rnode = route->rnode;
   route_lock_node (rnode);
   rnode = route_next (rnode);
@@ -703,6 +701,7 @@
 
   assert (rnode->info);
   next = (struct ospf6_route *) rnode->info;
+  ospf6_route_unlock (route);
   ospf6_route_lock (next);
   return next;
 }
@@ -1336,14 +1335,13 @@
 
 DEFUN (debug_ospf6_route,
        debug_ospf6_route_cmd,
-       "debug ospf6 route (table|intra-area|inter-area|memory)",
+       "debug ospf6 route (table|intra-area|inter-area)",
        DEBUG_STR
        OSPF6_STR
        "Debug route table calculation\n"
        "Debug detail\n"
        "Debug intra-area route calculation\n"
        "Debug inter-area route calculation\n"
-       "Debug route memory use\n"
        )
 {
   unsigned char level = 0;
@@ -1354,21 +1352,18 @@
     level = OSPF6_DEBUG_ROUTE_INTRA;
   else if (! strncmp (argv[0], "inter", 5))
     level = OSPF6_DEBUG_ROUTE_INTER;
-  else if (! strncmp (argv[0], "memor", 5))
-    level = OSPF6_DEBUG_ROUTE_MEMORY;
   OSPF6_DEBUG_ROUTE_ON (level);
   return CMD_SUCCESS;
 }
 
 DEFUN (no_debug_ospf6_route,
        no_debug_ospf6_route_cmd,
-       "no debug ospf6 route (table|intra-area|inter-area|memory)",
+       "no debug ospf6 route (table|intra-area|inter-area)",
        NO_STR
        DEBUG_STR
        OSPF6_STR
        "Debug route table calculation\n"
-       "Debug intra-area route calculation\n"
-       "Debug route memory use\n")
+       "Debug intra-area route calculation\n")
 {
   unsigned char level = 0;
 
@@ -1378,8 +1373,6 @@
     level = OSPF6_DEBUG_ROUTE_INTRA;
   else if (! strncmp (argv[0], "inter", 5))
     level = OSPF6_DEBUG_ROUTE_INTER;
-  else if (! strncmp (argv[0], "memor", 5))
-    level = OSPF6_DEBUG_ROUTE_MEMORY;
   OSPF6_DEBUG_ROUTE_OFF (level);
   return CMD_SUCCESS;
 }
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospf6d/ospf6_message.h	2011-03-21 09:43:34.000000000 -0400
+++ ./ospf6d/ospf6_message.h	2010-10-18 16:13:02.000000000 -0400
@@ -123,7 +123,6 @@
 extern void ospf6_lsack_print (struct ospf6_header *);
 
 extern int ospf6_iobuf_size (unsigned int size);
-extern void ospf6_message_terminate (void);
 extern int ospf6_receive (struct thread *thread);
 
 extern int ospf6_hello_send (struct thread *thread);
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospf6d/ospf6_area.c	2011-03-21 09:43:34.000000000 -0400
+++ ./ospf6d/ospf6_area.c	2010-10-18 16:13:02.000000000 -0400
@@ -199,10 +199,14 @@
   ospf6_lsdb_delete (oa->lsdb);
   ospf6_lsdb_delete (oa->lsdb_self);
 
-  ospf6_spf_table_finish (oa->spf_table);
   ospf6_route_table_delete (oa->spf_table);
   ospf6_route_table_delete (oa->route_table);
 
+#if 0
+  ospf6_spftree_delete (oa->spf_tree);
+  ospf6_route_table_delete (oa->topology_table);
+#endif /*0*/
+
   THREAD_OFF (oa->thread_spf_calculation);
   THREAD_OFF (oa->thread_route_calculation);
 
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospf6d/ospf6_top.h	2011-03-21 09:43:34.000000000 -0400
+++ ./ospf6d/ospf6_top.h	2010-10-18 16:13:02.000000000 -0400
@@ -69,7 +69,6 @@
 
 /* prototypes */
 extern void ospf6_top_init (void);
-extern void ospf6_delete (struct ospf6 *o);
 
 extern void ospf6_maxage_remove (struct ospf6 *o);
 
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospf6d/ospf6_asbr.h	2011-03-21 09:43:34.000000000 -0400
+++ ./ospf6d/ospf6_asbr.h	2010-10-18 16:13:08.000000000 -0400
@@ -79,7 +79,6 @@
 extern int ospf6_redistribute_config_write (struct vty *vty);
 
 extern void ospf6_asbr_init (void);
-extern void ospf6_asbr_terminate (void);
 
 extern int config_write_ospf6_debug_asbr (struct vty *vty);
 extern void install_element_ospf6_debug_asbr (void);
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospf6d/ospf6_asbr.c	2011-03-21 09:43:34.000000000 -0400
+++ ./ospf6d/ospf6_asbr.c	2010-10-18 16:13:07.000000000 -0400
@@ -1219,11 +1219,6 @@
   install_element (OSPF6_NODE, &no_ospf6_redistribute_cmd);
 }
 
-void
-ospf6_asbr_terminate (void)
-{
-  route_map_finish ();
-}
 
 DEFUN (debug_ospf6_asbr,
        debug_ospf6_asbr_cmd,
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospf6d/ospf6_interface.c	2011-03-21 05:43:52.000000000 -0400
+++ ./ospf6d/ospf6_interface.c	2010-10-18 16:13:02.000000000 -0400
@@ -1394,9 +1394,6 @@
   oi->plist_name = XSTRDUP (MTYPE_PREFIX_LIST_STR, argv[0]);
 
   ospf6_interface_connected_route_update (oi->interface);
-
-  if (oi->area)
-    {
       OSPF6_LINK_LSA_SCHEDULE (oi);
       if (oi->state == OSPF6_INTERFACE_DR)
         {
@@ -1404,7 +1401,6 @@
           OSPF6_INTRA_PREFIX_LSA_SCHEDULE_TRANSIT (oi);
         }
       OSPF6_INTRA_PREFIX_LSA_SCHEDULE_STUB (oi->area);
-    }
 
   return CMD_SUCCESS;
 }
@@ -1437,9 +1433,6 @@
     }
 
   ospf6_interface_connected_route_update (oi->interface);
-
-  if (oi->area)
-    {
       OSPF6_LINK_LSA_SCHEDULE (oi);
       if (oi->state == OSPF6_INTERFACE_DR)
         {
@@ -1447,7 +1440,6 @@
           OSPF6_INTRA_PREFIX_LSA_SCHEDULE_TRANSIT (oi);
         }
       OSPF6_INTRA_PREFIX_LSA_SCHEDULE_STUB (oi->area);
-    }
 
   return CMD_SUCCESS;
 }
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospf6d/ospf6_top.c	2011-03-21 09:43:34.000000000 -0400
+++ ./ospf6d/ospf6_top.c	2010-10-18 16:13:05.000000000 -0400
@@ -51,8 +51,6 @@
 /* global ospf6d variable */
 struct ospf6 *ospf6;
 
-static void ospf6_disable (struct ospf6 *o);
-
 static void
 ospf6_top_lsdb_hook_add (struct ospf6_lsa *lsa)
 {
@@ -145,17 +143,15 @@
   return o;
 }
 
-void
+#if 0
+static void
 ospf6_delete (struct ospf6 *o)
 {
   struct listnode *node, *nnode;
   struct ospf6_area *oa;
 
-  ospf6_disable (ospf6);
-
   for (ALL_LIST_ELEMENTS (o->area_list, node, nnode, oa))
     ospf6_area_delete (oa);
-  list_delete (o->area_list);
 
   ospf6_lsdb_delete (o->lsdb);
   ospf6_lsdb_delete (o->lsdb_self);
@@ -168,6 +164,7 @@
 
   XFREE (MTYPE_OSPF6_TOP, o);
 }
+#endif
 
 static void
 ospf6_enable (struct ospf6 *o)
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospf6d/ospf6_main.c	2011-03-21 09:43:34.000000000 -0400
+++ ./ospf6d/ospf6_main.c	2010-10-18 16:13:07.000000000 -0400
@@ -124,35 +124,6 @@
   exit (status);
 }
 
-static void
-ospf6_exit (int status)
-{
-  extern struct ospf6 *ospf6;
-  extern struct zclient *zclient;
-
-  if (ospf6)
-    ospf6_delete (ospf6);
-
-  ospf6_message_terminate ();
-  ospf6_asbr_terminate ();
-  ospf6_lsa_terminate ();
-
-  if_terminate ();
-  vty_terminate ();
-  cmd_terminate ();
-
-  if (zclient)
-    zclient_free (zclient);
-
-  if (master)
-    thread_master_free (master);
-
-  if (zlog_default)
-    closezlog (zlog_default);
-
-  exit (status);
-}
-
 /* SIGHUP handler. */
 static void 
 sighup (void)
@@ -165,7 +136,7 @@
 sigint (void)
 {
   zlog_notice ("Terminating on signal SIGINT");
-  ospf6_exit (0);
+  exit (0);
 }
 
 /* SIGTERM handler. */
@@ -173,7 +144,7 @@
 sigterm (void)
 {
   zlog_notice ("Terminating on signal SIGTERM");
-  ospf6_exit (0);
+  exit (0);
 }
 
 /* SIGUSR1 handler. */
@@ -337,7 +308,7 @@
   zlog_warn ("Thread failed");
 
   /* Not reached. */
-  ospf6_exit (0);
+  exit (0);
 }
 
 
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./ospf6d/ospf6_intra.c	2011-03-21 09:43:34.000000000 -0400
+++ ./ospf6d/ospf6_intra.c	2010-10-18 16:13:09.000000000 -0400
@@ -1177,8 +1177,6 @@
             }
           ospf6_route_remove (route, oa->route_table);
         }
-      if (route)
-	ospf6_route_unlock (route);
     }
 
   if (current != end && IS_OSPF6_DEBUG_EXAMIN (INTRA_PREFIX))
--- /users/kyehwanl/Download/quagga-originals/quagga-0.99.18/./tests/aspath_test.c	2011-03-21 09:52:26.000000000 -0400
+++ ./tests/aspath_test.c	2010-10-18 16:13:56.000000000 -0400
@@ -649,7 +649,7 @@
       s = stream_new (len);
       stream_put (s, data, len);
     }
-  as = aspath_parse (s, len, use32bit, 0);
+  as = aspath_parse (s, len, use32bit);
   
   if (s)
     stream_free (s);
